---
title: Java集合核心知识总结
date: 2023-05-12 11:12:40
permalink: /pages/2e780e/
---
# Java集合核心知识总结

## 集合概述

### Java 集合框架如下图所示：

![image-20230411210606868](https://jsd.cdn.zzko.cn/gh/cmty256/imgs-blog@main/images/image-20230411210606868.50typmz8n440.jpg)

### 说说 List, Set, Queue, Map 四者的区别？

- `List`(对付顺序的好帮手): 存储的元素是**有序的、可重复的**。
- `Set`(注重独一无二的性质): 存储的元素是**无序的、不可重复**的。
- `Queue`(实现排队功能的叫号机): 按特定的排队规则来确定先后顺序，存储的元素是**有序的、可重复**的。
- `Map`(用 key 来搜索的专家): 使用键值对（key-value）存储，类似于数学上的函数 y=f(x)，"x" 代表 key，"y" 代表 value，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。

### 无序性和不可重复性的含义是什么

- 无序性不等于随机性 ，无序性是指存储的数据在底层数组中并非按照数组索引的顺序添加 ，而是根据数据的哈希值决定的。
- 不可重复性是指添加的元素按照 `equals()` 判断时 ，返回 false，需要同时重写 `equals()` 方法和 `hashCode()` 方法。

### 集合框架底层数据结构总结

#### 1. List

- `ArrayList`： `Object[]` 数组
- `Vector`：`Object[]` 数组
- `LinkedList`： 双向链表(JDK1.6 之前为循环链表，JDK1.7 取消了循环)

#### 2. Set

- `HashSet`(无序，唯一): 基于 `HashMap` 实现的，底层采用 `HashMap` 来保存元素

- `LinkedHashSet`(有序，唯一): `LinkedHashSet` 是 `HashSet` 的子类，并且其内部是通过 `LinkedHashMap` 来实现的。有点类似于我们之前说的 `LinkedHashMap` 其内部是基于 `HashMap` 实现一样，不过还是有一点点区别的

- `TreeSet`(有序，唯一): 红黑树(自平衡的排序二叉树)

  > 红黑树（Red-Black Tree）是一种自平衡的二叉查找树。它的**特点**是：每个节点要么是红色，要么是黑色；树的根节点是黑色的；所有叶子节点都是黑色的空节点（NIL节点）；如果一个节点是红色的，则其子节点必须是黑色的；从根节点到叶子节点的所有路径上，不能有两个连续的红色节点；从任意一个节点到其子树中每个叶子节点的路径都包含相同数目的黑色节点。

#### 3. Queue

- `PriorityQueue`: `Object[]` 数组来实现二叉堆
- `ArrayQueue`: `Object[]` 数组 + 双指针

再来看看 `Map` 接口下面的集合。

#### 4. Map

- `HashMap`： JDK1.8 之前 `HashMap` 由数组+链表组成的，数组是 `HashMap` 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，**如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树**）时，将链表转化为红黑树，以减少搜索时间

- `LinkedHashMap`（有序的）： `LinkedHashMap` 继承自 `HashMap`，所以它的底层仍然是基于拉链式散列结构即**由数组和链表或红黑树组成**。另外，`LinkedHashMap` 在上面结构的基础上，增加了一条双向链表，使得上面的结构**可以保持键值对的插入顺序**。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。

- `Hashtable`： **数组+链表**组成的，数组是 `Hashtable` 的主体，链表则是主要为了解决哈希冲突而存在的

  > `HashTable` 是线程安全的，而 `HashMap` 不是。在多线程环境下，使用 `HashTable` 可以避免数据竞争和并发访问的问题，但是对于单线程环境，使用 `HashMap` 可以提高性能

- `TreeMap`： 红黑树（自平衡的排序二叉树）

#### 哈希冲突

> 哈希冲突是指在哈希表中，不同的关键字（Key）通过哈希函数被映射到了同一个槽位（Bucket）中，导致同一个槽位中存储了多个关键字的情况。

#### **为什么链表可以解决哈希冲突（拉链法：数组+链表）：**

> 当一个桶中存储多个键值对时，可以将它们存储在一个链表中，每个节点存储一个键值对。当需要查找或删除某个键值对时，可以按照哈希函数的规则找到对应的桶，然后遍历链表中的节点，查找或删除目标键值对

### 哈希表是什么

哈希表（Hash Table），也称为散列表，是一种数据结构，用于实现关联数组（Associative Array）或映射（Map）等抽象数据类型。它通过将关键字映射到表中一个位置来访问记录，以加快查找的速度。哈希表实际上是一个数组，其中每个元素都是一个链表的头节点，每个链表中包含了哈希值相同的所有元素。 哈希表的基本思想是：将关键字通过哈希函数计算出一个哈希值，然后将该值作为数组的下标，将元素存储在对应的数组位置中。在查找元素时，通过哈希函数计算出关键字的哈希值，然后在对应的数组位置中查找元素。 哈希表的优点是查找速度快，时间复杂度为 O(1)，而不像线性表的查找时间复杂度为 O(n)。但是，哈希表的缺点是空间利用率相对较低，因为需要预留足够的空间来存储哈希冲突的元素。此外，哈希表的性能还受到哈希函数的影响，如果哈希函数设计不好，可能会导致哈希冲突率过高，降低哈希表的性能。

### 线程不安全的接口

`ArrayList`，`LinkedList`， `HashSet`，`LinkedHashSet`，`TreeSet`，`PriorityQueue` ，`ArrayQueue`，`HashMap`，`LinkedHashMap` ，`TreeMap` 都是线程不安全的

### 线程安全的接口

`Vector`，`Hashtable`，`ConcurrentHashMap` 

### 为什么要使用集合

是因为数组一旦声明之后，长度就不可变了；同时，声明数组时的数据类型也决定了该数组存储的数据的类型；而且，数组存储的数据是有序的、可重复的，特点单一。 而**集合提高了数据存储的灵活性，Java 集合不仅可以用来存储不同类型不同数量的对象，还可以保存具有映射关系的数据。**

## Collection 子接口之 List

### ArrayList 和 Vector 的区别

1. 线程安全性：Vector 是线程安全的，它的方法都是同步的，多个线程可以同时访问和修改 Vector 对象；而 ArrayList 是非线程安全的，它的方法不是同步的，多个线程访问和修改同一个 ArrayList 对象可能会导致数据竞争和并发访问的问题。
2. 扩容方式：Vector 和 ArrayList 在扩容时采用不同的策略。**Vector 在扩容时会增加一倍的容量，而 ArrayList 则会增加 50% 的容量。**
3. 性能：由于 Vector 是线程安全的，它在并发访问时需要进行同步操作，因此性能相对较低；而 ArrayList 在单线程环境下的性能较好，但**在多线程环境下需要使用同步机制来保证线程安全**。
4. 初始容量：当创建 Vector 或 ArrayList 对象时，可以指定它们的初始容量。Vector 的默认初始容量为 10，而 ArrayList 的默认初始容量为 0。在实际使用中，可以根据数据量和性能需求等因素，选择合适的初始容量。 

> 综上所述，Vector 和 ArrayList 都是动态数组的实现，但 Vector 是线程安全的，扩容方式和性能相对较差，初始容量为 10；而 ArrayList 是非线程安全的，扩容方式和性能相对较好，初始容量为 0。在实际使用中，应根据具体需求选择合适的动态数组实现。

### ArrayList 与 LinkedList 区别

1. **底层数据结构**：ArrayList 底层采用**数组**实现，而 LinkedList 底层采用**链表**实现。
2. **随机访问(相当于查询）和插入/删除操作的性能**：由于 ArrayList 的底层实现是数组，因此随机访问的性能较好，时间复杂度为 O(1)；而插入/删除操作需要移动其他元素，时间复杂度为 O(n)。相反，LinkedList 的底层实现是链表，因此插入/删除操作的性能较好，时间复杂度为 O(1)；而随机访问需要遍历链表，时间复杂度为 O(n)。
3. **内存占用**：由于 ArrayList 底层采用数组实现，因此需要预先分配一定大小的连续内存空间，因此可能会浪费一些内存空间；而 LinkedList 的底层采用链表实现，因此每个节点可以分布在不同的内存空间，内存利用率相对较高。
4. **迭代器的性能**：由于 ArrayList 的底层实现是数组，因此迭代器的性能相对较好；而 LinkedList 的底层实现是链表，因此迭代器需要遍历链表，性能较差。 

> 综上所述，ArrayList 和 LinkedList 都是线性表数据结构实现，但底层数据结构、随机访问和插入/删除操作的性能、内存占用和迭代器的性能等方面有所不同。在实际使用中，应根据具体需求选择合适的线性表数据结构实现。
>
> 我们在项目中**一般是不会**使用到 `LinkedList` 的，需要用到 `LinkedList` 的场景几乎都可以使用 `ArrayList` 来代替，并且，性能通常会更好！

#### 什么是迭代器

迭代器是一种Java中的接口，用于遍历集合类（Collection）和映射类（Map）中的元素。使用迭代器可以依次访问集合中的每个元素，而不需要知道集合的内部实现方式。在迭代器设计模式中，迭代器提供了一个通用的访问方法，使得可以在不暴露集合内部实现的情况下对集合进行迭代遍历。 迭代器通常包含以下方法：

```
hasNext()：判断集合中是否还有下一个元素，如果有返回 true，否则返回 false。

next()：获取集合中的下一个元素。

remove()：从集合中删除上一次返回的元素。 
```

使用迭代器遍历集合时，可以避免使用传统的 for 循环或者增强 for 循环带来的一些限制，如不能在遍历过程中删除或添加元素，并且可以在遍历过程中对元素进行修改等操作。此外，迭代器还支持对集合中的元素进行过滤、映射和归约等操作，提供了更加灵活和高效的遍历方式。 需要注意的是，**在多线程环境下，使用迭代器遍历集合时需要进行同步操作，以避免并发修改集合导致的数据竞争和不一致性问题**。

```java
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
public class ArrayListExample {
    public static void main(String[] args) {
        // 创建一个 ArrayList 对象
        List<String> arrayList = new ArrayList<>();
        // 向 ArrayList 中添加元素
        arrayList.add("apple");
        arrayList.add("banana");
        arrayList.add("orange");
        // 创建一个同步的 ArrayList 对象
        List<String> synchronizedArrayList = Collections.synchronizedList(arrayList);
        // 使用迭代器遍历 ArrayList
        synchronized (synchronizedArrayList) {
            Iterator<String> iterator = synchronizedArrayList.iterator();
            while (iterator.hasNext()) {
                String element = iterator.next();
                System.out.println(element);
            }
        }
    }
}
```

## Collection 子接口之 Set

### comparable 和 Comparator 的区别

1. Comparable 接口只有一个方法 `compareTo()`，用于比较对象自身与另一个对象的大小关系。实现 Comparable 接口的类可以直接通过调用 `Arrays.sort()` 或 `Collections.sort()` 方法进行排序。 Comparator 接口有两个方法 `compare()` 和 `equals()`，其中 `compare()` 方法用于比较两个对象的大小关系，可以通过 `Collections.sort()` 方法的重载版本或者使用 TreeMap、PriorityQueue 等需要比较对象的集合类来进行排序。`equals()` 方法用于比较两个对象是否相等，但在比较大小时并不会使用到。
2. Comparable 接口是在类的定义时就实现的，实现 Comparable 接口意味着该类支持自然排序（natural ordering），即可以根据对象自身的属性进行排序。而 Comparator 接口是在排序时作为参数传递进去的，可以根据不同的比较规则进行排序，也就是说可以定义多个 Comparator 来比较同一个类的对象。
3. Comparable 接口的实现在集合类中被广泛使用，例如在 TreeSet、TreeMap 等集合类中需要比较元素的大小关系时，会首先尝试使用元素自身实现的 Comparable 接口进行比较。如果元素没有实现 Comparable 接口，则需要通过传递一个 Comparator 对象来进行比较。因此，实现 Comparable 接口可以使得类更加通用，因为它可以被广泛应用于不同的集合类中。
4. Comparable 接口是 Java 的内部接口，定义在 java.lang 包中，而 Comparator 接口是 Java 的标准类库中的接口，定义在 java.util 包中。 综上所述，Comparable 和 Comparator 都是用于比较对象的接口，但是它们之间的区别主要在于实现方式、应用场景和使用方式等方面。需要根据实际情况选择合适的接口来进行对象的比较。

> 综上所述，Comparable 和 Comparator 都是**用于比较对象**的接口，但是它们之间的区别主要在于实现方式、应用场景和使用方式等方面。需要根据实际情况选择合适的接口来进行对象的比较。

#### Comparator 定制排序（直接方法中重写）

```java
ArrayList<Integer> arrayList = new ArrayList<Integer>();
arrayList.add(-1);
arrayList.add(3);
arrayList.add(3);
arrayList.add(-5);
arrayList.add(7);
arrayList.add(4);
arrayList.add(-9);
arrayList.add(-7);
System.out.println("原始数组:");
System.out.println(arrayList);
// void reverse(List list)：反转
Collections.reverse(arrayList);
System.out.println("Collections.reverse(arrayList):");
System.out.println(arrayList);

// void sort(List list),按自然排序的升序排序
Collections.sort(arrayList);
System.out.println("Collections.sort(arrayList):");
System.out.println(arrayList);
// 定制排序的用法
Collections.sort(arrayList, new Comparator<Integer>() {

    @Override
    public int compare(Integer o1, Integer o2) {
        return o2.compareTo(o1);
    }
});
System.out.println("定制排序后：");
System.out.println(arrayList);
```

Output:

```java
原始数组:
[-1, 3, 3, -5, 7, 4, -9, -7]
Collections.reverse(arrayList):
[-7, -9, 4, 7, -5, 3, 3, -1]
Collections.sort(arrayList):
[-9, -7, -5, -1, 3, 3, 4, 7]
定制排序后：
[7, 4, 3, 3, -1, -5, -7, -9]
```

#### 重写 compareTo 方法实现按年龄来排序（在实体类中重写方法）

```java
// person对象没有实现Comparable接口，所以必须实现，这样才不会出错，才可以使treemap中的数据按顺序排列
// 前面一个例子的String类已经默认实现了Comparable接口，详细可以查看String类的API文档，另外其他
// 像Integer类等都已经实现了Comparable接口，所以不需要另外实现了
public  class Person implements Comparable<Person> {
    private String name;
    private int age;

    public Person(String name, int age) {
        super();
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    /**
     * T重写compareTo方法实现按年龄来排序
     */
    @Override
    public int compareTo(Person o) {
        if (this.age > o.getAge()) {
            return 1;
        }
        if (this.age < o.getAge()) {
            return -1;
        }
        return 0;
    }
}
```

```java
 public static void main(String[] args) {
        TreeMap<Person, String> pdata = new TreeMap<Person, String>();
        pdata.put(new Person("张三", 30), "zhangsan");
        pdata.put(new Person("李四", 20), "lisi");
        pdata.put(new Person("王五", 10), "wangwu");
        pdata.put(new Person("小红", 5), "xiaohong");
        // 得到key的值的同时得到key所对应的值
        Set<Person> keys = pdata.keySet();
        for (Person key : keys) {
            System.out.println(key.getAge() + "-" + key.getName());

        }
    }
```

Output：

```java
5-小红
10-王五
20-李四
30-张三
```

### 比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同

- `HashSet`、`LinkedHashSet` 和 `TreeSet` 都是 `Set` 接口的实现类，都能保证元素唯一，并且都不是线程安全的。
- `HashSet`、`LinkedHashSet` 和 `TreeSet` 的主要区别在于底层数据结构不同。`HashSet` 的底层数据结构是**哈希表**（基于 `HashMap` 实现）。`LinkedHashSet` 的底层数据结构是**链表和哈希表**，元素的插入和取出顺序满足 FIFO。`TreeSet` 底层数据结构是**红黑树**，元素是有序的，排序的方式有自然排序和定制排序。
- 底层数据结构不同又导致这三者的应用场景不同。`HashSet` 用于不需要保证元素插入和取出顺序的场景，`LinkedHashSet` 用于保证元素的插入和取出顺序满足 FIFO 的场景，`TreeSet` 用于支持对元素自定义排序规则的场景。

## Collection 子接口之 Queue

### Queue 与 Deque 的区别

`Queue` 是**单端队列**，只能从一端插入元素，另一端删除元素，实现上一般遵循 **先进先出（FIFO）** 规则。

`Queue` 扩展了 `Collection` 的接口，根据 **因为容量问题而导致操作失败后处理方式的不同** 可以分为两类方法: 一种在操作失败后会抛出异常，另一种则会返回特殊值。

| `Queue` 接口 | 抛出异常  | 返回特殊值 |
| ------------ | --------- | ---------- |
| 插入队尾     | add(E e)  | offer(E e) |
| 删除队首     | remove()  | poll()     |
| 查询队首元素 | element() | peek()     |

`Deque` 是**双端队列**，在队列的两端均可以插入或删除元素。

`Deque` 扩展了 `Queue` 的接口, 增加了在队首和队尾进行插入和删除的方法，同样根据失败后处理方式的不同分为两类：

| `Deque` 接口 | 抛出异常      | 返回特殊值      |
| ------------ | ------------- | --------------- |
| 插入队首     | addFirst(E e) | offerFirst(E e) |
| 插入队尾     | addLast(E e)  | offerLast(E e)  |
| 删除队首     | removeFirst() | pollFirst()     |
| 删除队尾     | removeLast()  | pollLast()      |
| 查询队首元素 | getFirst()    | peekFirst()     |
| 查询队尾元素 | getLast()     | peekLast()      |

事实上，`Deque` 还提供有 `push()` 和 `pop()` 等其他方法，可用于模拟栈。

###  ArrayDeque 与 LinkedList 的区别

`ArrayDeque` 和 `LinkedList` 都实现了 `Deque` 接口，两者**都具有队列的功能**，但两者有什么区别呢？

- `ArrayDeque` 是**基于可变长的数组和双指针**来实现，而 `LinkedList` 则通过**链表**来实现。
- `ArrayDeque` 不支持存储 `NULL` 数据，但 `LinkedList` 支持。
- `ArrayDeque` 是在 JDK1.6 才被引入的，而`LinkedList` 早在 JDK1.2 时就已经存在。
- `ArrayDeque` 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 `LinkedList` 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。

> 从性能的角度上，选用 `ArrayDeque` 来实现队列要比 `LinkedList` 更好。此外，`ArrayDeque` 也可以用于实现栈。

### 说一说 PriorityQueue（优先级队列）

`PriorityQueue` 是在 JDK1.5 中被引入的, 其与 `Queue` 的**区别在于**元素出队顺序是与优先级相关的，即**总是优先级最高的元素先出队**。

这里列举其相关的一些要点：

- `PriorityQueue` 利用了**二叉堆的数据结构**来**实现**的，底层**使用可变长的数组来存储数据**
- `PriorityQueue` 通过堆元素的上浮和下沉，实现了在 O(logn) 的时间复杂度内插入元素和删除堆顶元素。
- `PriorityQueue` 是**非线程安全**的，且不支持存储 `NULL` 和 `non-comparable` 的对象。
- `PriorityQueue` **默认是小顶堆**，但可以接收一个 `Comparator` 作为构造参数，从而来自定义元素优先级的先后。

> 二叉堆（binary heap）是一种基于完全二叉树的数据结构，它满足如下两个性质：
>
> 1. 父节点的键值总是大于或等于（小于或等于）任何一个子节点的键值。
> 2. 每个节点的左子树和右子树都是一个二叉堆（称为堆的性质）。 根据性质1，我们可以将二叉堆划分为两种类型：最大堆和最小堆。
>
> - 在最大堆中，父节点的键值总是**大于或等于**任何一个子节点的键值。
> - 在最小堆中，父节点的键值总是**小于或等于**任何一个子节点的键值。 
>
> `PriorityQueue` 在面试中可能更多的会出现在手撕算法的时候，典型例题包括堆排序、求第K大的数、带权图的遍历等，所以需要会熟练使用才行。

## Map 接口

### HashMap 和 Hashtable 的区别

**线程安全性：** 

`HashMap` 是非线程安全的，`Hashtable` 是线程安全的,因为 `Hashtable` 内部的方法基本都经过`synchronized` 修饰。（如果你要保证线程安全的话就使用 `ConcurrentHashMap` 吧！）；

**效率：** 

因为线程安全的问题，`HashMap` 要比 `Hashtable` 效率高一点。另外，`Hashtable` **基本被淘汰，不要在代码中使用它**；

**对 null 键 和 null 值 的支持：** 

`HashMap` 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个；Hashtable 不允许有 null 键和 null 值，否则会抛出 `NullPointerException`。

**初始容量大小和每次扩充容量大小的不同 ：** 

① 创建时如果不指定容量初始值，`Hashtable` 默认的初始大小为 **11**，之后每次扩充，容量变为原来的 **2n+1**。`HashMap` 默认的初始化大小为 **16**。之后每次扩充，容量变为**原来的 2 倍**。

② 创建时如果给定了容量初始值，那么 `Hashtable` 会直接使用你给定的大小，而 `HashMap` 会将其扩充为 2 的幂次方大小（`HashMap` 中的`tableSizeFor()`方法保证，利用右位移运算）。也就是说 `HashMap` 总是使用 2 的幂作为哈希表的大小,后面会介绍到为什么是 2 的幂次方。

**底层数据结构：** 

- JDK1.8 以后的 `HashMap` 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树），以减少搜索时间（后文中我会结合源码对这一过程进行分析）。
- `Hashtable` 没有这样的机制。

### HashMap 和 HashSet 区别

![image-20230412165201719](https://jsd.cdn.zzko.cn/gh/cmty256/imgs-blog@main/images/image-20230412165201719.2bc46rnd9474.jpg)

**HashSet 使用成员对象来计算 hashcode 值，对于两个对象来说 hashcode 可能相同，所以equals()方法用来判断对象的相等性。什么情况下两个对象的hashcode相同，hashcode是地址吗？**

`HashSet` 使用成员对象的 `hashCode()` 方法来计算哈希值，因此如果两个对象的 `hashCode()` 值相同，它们将被存储在同一个桶中。但是，`hashCode()` 方法**并不是唯一**的，不同的对象可能会返回相同的哈希值（这种情况称为哈希冲突）。因此，当两个对象的 `hashCode()` 值相同时，需要使用 `equals()` 方法来进一步比较它们的内容是否相等。 

### hashCode源码

`hashCode()` 方法返回的值是一个 `int` 类型的数字，用于表示对象的哈希值。这个哈希值不一定是对象的地址，也不一定是唯一的。在计算哈希值时，一般会使用对象的属性来计算。例如，如果一个 `Person` 类具有 `name` 和 `age` 两个属性，那么可以将它们的哈希值合并起来计算：

```java
javaCopy codepublic int hashCode() {
    int result = 17;
    result = 31 * result + name.hashCode();
    result = 31 * result + age;
    return result;
}
```

这段代码中使用了一个经典的哈希算法，称为“31 哈希法”。**这个算法将初始值设为一个质数 17，然后将属性的哈希值依次乘以 31 并相加，得到最终的哈希值。由于 31 是一个奇素数，可以保证乘法过程不会产生哈希冲突。** 

> 需要注意的是，虽然哈希值不一定是地址，但是在 Java 中，如果没有为对象指定 `hashCode()` 方法的实现，那么默认情况下，它的 `hashCode()` 方法会返回对象的地址，因此在这种情况下，两个对象的哈希值可能会相同，但这并不是一个好的哈希算法。因此，在实现自定义的哈希算法时，需要保证哈希值的分布尽可能均匀，并且不容易产生哈希冲突。

### HashMap 和 TreeMap 区别

`TreeMap` 和`HashMap` 都继承自`AbstractMap` ，但是需要注意的是`TreeMap`它还实现了`NavigableMap`接口和`SortedMap` 接口。

![image-20230414162045562](https://jsd.cdn.zzko.cn/gh/cmty256/imgs-blog@main/images/image-20230414162045562.59ky7y3jbgs0.jpg)

实现 `NavigableMap` 接口让 `TreeMap` 有了**对集合内元素的搜索的能力**。

实现`SortedMap`接口让 `TreeMap` 有了**对集合中的元素根据键排序的能力**。默认是按 key 的升序排序，不过我们也可以指定排序的比较器。示例代码如下：

```java
public class Person {
    private Integer age;
    public Person(Integer age) {
        this.age = age;
    }
    public Integer getAge() {
        return age;
    }

    public static void main(String[] args) {
        TreeMap<Person, String> treeMap = new TreeMap<>(new Comparator<Person>() {
            @Override
            public int compare(Person person1, Person person2) {
                int num = person1.getAge() - person2.getAge();
                return Integer.compare(num, 0);
            }
        });
        treeMap.put(new Person(3), "person1");
        treeMap.put(new Person(18), "person2");
        treeMap.put(new Person(35), "person3");
        treeMap.put(new Person(16), "person4");
        treeMap.entrySet().stream().forEach(personStringEntry -> {
            System.out.println(personStringEntry.getValue());
        });
    }
}
```

可以看出，`TreeMap` 中的元素已经是按照 `Person` 的 age 字段的升序来排列了。

上面，我们是通过传入**匿名内部类**的方式实现的，你可以将代码替换成 **Lambda 表达式**实现的方式：

```java
TreeMap<Person, String> treeMap = new TreeMap<>((person1, person2) -> {
  int num = person1.getAge() - person2.getAge();
  return Integer.compare(num, 0);
});
```

综上，相比于`HashMap`来说 `TreeMap` 主要多了**对集合中的元素根据键排序的能力**（`SortedMap`）以及**对集合内元素的搜索的能力**（`NavigableMap`）。

### HashSet 如何检查重复?

> 当你把对象加入`HashSet`时，`HashSet` 会先计算对象的`hashcode`值来判断对象加入的位置，同时也会与其他加入的对象的 `hashcode` 值作比较，如果没有相符的 `hashcode`，`HashSet` 会假设对象没有重复出现。但是如果发现有相同 `hashcode` 值的对象，这时会调用`equals()`方法来检查 `hashcode` 相等的对象是否真的相同。如果两者相同，`HashSet` 就不会让加入操作成功。

直接看一下`HashSet`中的源码：

```java
// Returns: true if this set did not already contain the specified element
// 返回值：当 set 中没有包含 add 的元素时返回真
public boolean add(E e) {
        return map.put(e, PRESENT)==null;
}
```

### HashMap的底层实现

#### JDK1.8 之前

JDK1.8 之前 `HashMap` 底层是 **数组和链表** 结合在一起使用也就是 **链表散列**。HashMap 通过 key 的 `hashcode` 经过**扰动函数（hash方法）**处理过后得到 hash 值，然后通过 `(n - 1) & hash` 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过**拉链法（数组+链表）解决冲突**。

#### JDK1.8 之后

相比于之前的版本， JDK1.8 之后在解决哈希冲突时有了较大的变化，当**链表长度大于阈值（默认为 8）**（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，**将链表转化为红黑树**，以减少搜索时间。

> TreeMap、TreeSet 以及 JDK1.8 之后的 HashMap 底层都用到了红黑树。红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。

#### JDK1.7和JDK1.8的hash方法源码对比：

1. JDK 1.8 的 hash 方法 （运用了三目运算符）相比于 JDK 1.7 hash 方法更加简化，但是原理不变；
2. JDK 1.7 的 hash 方法的性能会稍差一点点，因为扰动了 4 次

使用扰动函数（hash方法）之后可以减少碰撞

### HashMap 的长度为什么是 2 的幂次方

这是因为 HashMap 在**计算 key 的哈希值后，需要通过哈希值和数组长度计算出该 key 在数组中的位置**，具体的计算方式是 `(n - 1) & hash`（数组的长度减一的差和 key 的哈希值相与），其中 `n` 是数组的长度，`hash` 是 key 的哈希值。这个计算方式的作用是将哈希值的高位和低位进行一次异或运算，得到 key 在数组中的位置。 如果数组的长度不是 2 的幂次方，那么在计算 `(n - 1) & hash` 时，得到的结果可能会存在一些**哈希值无法均匀分布到数组中的位置的情况**，从而导致某些位置上的链表或红黑树会变得过长，影响 HashMap 的性能。因此，**为了避免这种情况的发生**，HashMap 的长度总是保持为 2 的幂次方。 另外，对于长度为 2 的幂次方的数组，计算 `(n - 1) & hash` 时，**等价于对数组长度取模，这种计算方式的效率比较高，而且可以保证均匀分布**。因此，HashMap 采用长度为 2 的幂次方的数组，**可以提高 HashMap 的性能和效率**。

### HashMap 多线程操作导致死循环问题

在多线程环境下，如果多个线程同时对 HashMap 进行操作，可能会导致 HashMap 的链表或红黑树出现环形，从而导致死循环问题。这种问题通常发生在以下情况下：

1. 多个线程同时调用 `put()` 方法，导致链表或红黑树的结构发生变化，从而导致链表或红黑树出现环形。
2. 多个线程同时调用 `resize()` 方法，导致数组扩容时链表或红黑树的结构发生变化，从而导致链表或红黑树出现环形。 当出现链表或红黑树环形时，会导致 HashMap 的遍历操作进入死循环，从而影响程序的性能和可靠性。

为了解决这个问题，可以采用以下几种方式：

1. **使用线程安全的 ConcurrentHashMap**，它是线程安全的 HashMap，可以安全地在多线程环境下进行操作。
2. 对于需要在多线程环境下使用 HashMap 的情况，可以**使用锁**来保证同一时间只有一个线程能够对 HashMap 进行操作。
3. 避免多个线程同时对 HashMap 进行操作，可以将对 HashMap 的操作**放在同步块中**，确保同一时间只有一个线程能够对 HashMap 进行修改。
4. 通过使用线程安全的并发数据结构，例如 ConcurrentLinkedQueue、ConcurrentHashMap 等，避免在多线程环境下使用 HashMap。

### HashMap 有哪几种常见的遍历方式?

[HashMap 的 7 种遍历方式与性能分析！](https://mp.weixin.qq.com/s/zQBN3UvJDhRTKP6SzcZFKw)

### ConcurrentHashMap 和 Hashtable 的区别

`ConcurrentHashMap` 和 `Hashtable` 都是线程安全的集合类，但是它们在实现和性能上有一些区别：

1. **底层数据结构：** JDK1.7 的 `ConcurrentHashMap` 底层采用 **分段的数组+链表** 实现，JDK1.8 采用的数据结构跟 `HashMap1.8` 的结构一样，数组+链表/红黑二叉树。`Hashtable` 和 JDK1.8 之前的 `HashMap` 的底层数据结构类似都是采用 **数组+链表** 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；

2. **实现线程安全的方式（重要）：**

- 在 JDK1.7 的时候，`ConcurrentHashMap` 对整个桶数组进行了分割分段(`Segment`，分段锁)，每一把锁只锁容器其中一部分数据（下面有示意图），多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。
- 到了 JDK1.8 的时候，`ConcurrentHashMap` 已经摒弃了 `Segment` 的概念，而是直接用 `Node` 数组+链表 / 红黑树的数据结构来实现，并发控制使用 `synchronized` 和 CAS 来操作。（JDK1.6 以后 `synchronized` 锁做了很多优化） 整个看起来就像是优化过且线程安全的 `HashMap`，虽然在 JDK1.8 中还能看到 `Segment` 的数据结构，但是已经简化了属性，只是为了兼容旧版本；
- **`Hashtable`(同一把锁)** :使用 `synchronized` 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。

3. **对 null 值的支持不同**：`Hashtable` 不允许 `key` 或 `value` 为 `null`，而 `ConcurrentHashMap` 则**（ JDK7 时）**允许 `key` 和 value 均为 `null`，**JDK8 后不再允许**。

4. **扩容机制不同：**`Hashtable` 在扩容时使用的是原来容量的 2 倍加 1，而 `ConcurrentHashMap` 在扩容时采用的则是分段锁技术，只需要对其中一个段进行扩容即可。

###  ConcurrentHashMap 线程安全的具体实现方式/底层具体实现

#### JDK1.8 之前

**`ConcurrentHashMap` 是由 `Segment` 数组结构和 `HashEntry` 数组结构组成**。

`Segment` 继承了 `ReentrantLock`,所以 `Segment` 是一种可重入锁，扮演锁的角色。`HashEntry` 用于存储键值对数据。

一个 `ConcurrentHashMap` 里包含一个 `Segment` 数组，`Segment` 的个数一旦**初始化就不能改变**。 `Segment` 数组的大小默认是 16，也就是说默认可以同时支持 16 个线程并发写。

`Segment` 的结构和 `HashMap` 类似，是一种数组和链表结构，一个 `Segment` 包含一个 `HashEntry` 数组，每个 `HashEntry` 是一个链表结构的元素，每个 `Segment` 守护着一个 `HashEntry` 数组里的元素，当对 `HashEntry` 数组的数据进行修改时，必须首先获得对应的 `Segment` 的锁。也就是说，对同一 `Segment` 的并发写入会被阻塞，不同 `Segment` 的写入是可以并发执行的。

#### JDK1.8 之后

- Java 8 几乎完全重写了 `ConcurrentHashMap`，代码量从原来 Java 7 中的 1000 多行，变成了现在的 6000 多行。
- `ConcurrentHashMap` 取消了 `Segment` 分段锁，采用 `Node + CAS + synchronized` 来保证并发安全。数据结构跟 `HashMap` 1.8 的结构类似，数组+链表/红黑二叉树。Java 8 在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为 O(N)）转换为红黑树（寻址时间复杂度为 O(log(N))）。
- Java 8 中，**锁粒度**更细，`synchronized` 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，就不会影响其他 Node 的读写，效率大幅提升。

锁粒度

> 锁粒度指的是锁定的范围大小，通常分为粗粒度锁和细粒度锁两种类型。
>
> 1. 粗粒度锁 粗粒度锁指的是**锁定范围较大的锁，通常是对整个对象或整个方法进行加锁**。粗粒度锁的优点是实现简单，易于控制，缺点是锁定范围太大，会导致并发性能下降，降低程序的并发度。
> 2. 细粒度锁 细粒度锁指的是**锁定范围较小的锁，通常是对对象中的某个属性或某一段代码进行加锁**。细粒度锁的优点是锁定范围小，可以提高程序的并发度，缺点是实现复杂，容易出现死锁等问题。 
>
> 在实际开发中，应该根据实际情况选择合适的锁粒度。**如果锁的范围太大，会导致并发性能下降，如果锁的范围太小，会增加锁的竞争，降低程序的并发度**。**可以通过压力测试等方式来确定合适的锁粒度**。

### JDK 1.7 和 JDK 1.8 的 ConcurrentHashMap 实现有什么不同？

**线程安全实现方式** ：

- JDK 1.7 采用 `Segment` 分段锁来保证安全， `Segment` 是继承自 `ReentrantLock`。
- JDK1.8 放弃了 `Segment` 分段锁的设计，采用 `Node + CAS + synchronized` 保证线程安全，锁粒度更细，`synchronized` 只锁定当前链表或红黑二叉树的首节点。

**Hash 碰撞解决方法** : 

- JDK 1.7 采用拉链法，
- JDK1.8 采用拉链法结合红黑树（链表长度超过一定阈值时，将链表转换为红黑树）。

**并发度** ：

- JDK 1.7 最大并发度是 Segment 的个数，默认是 16。
- JDK 1.8 最大并发度是 Node 数组的大小，并发度更大。

# Java集合使用注意事项总结

##  集合判空

> **判断所有集合内部的元素是否为空，使用 `isEmpty()` 方法，而不是 `size()==0` 的方式**

这是因为 `isEmpty()` 方法的可读性更好，并且时间复杂度为 O(1)。

## 集合转 Map

> **在使用 `java.util.stream.Collectors` 类的 `toMap()` 方法转为 `Map` 集合时，一定要注意当 value 为 null 时会抛 NPE 异常**。

## 集合遍历

> **不要在 foreach 循环里进行元素的 `remove/add` 操作。remove 元素请使用 `Iterator` 方式，如果并发操作，需要对 `Iterator` 对象加锁。**

**原因：**通过反编译你会发现 foreach 语法底层其实还是依赖 `Iterator` 。不过， `remove/add` 操作直接调用的是集合自己的方法，而不是 `Iterator` 的 `remove/add`方法

这就导致 `Iterator` 莫名其妙地发现自己有元素被 `remove/add` ，然后，它就会抛出一个 `ConcurrentModificationException` 来提示用户发生了并发修改异常。这就是单线程状态下产生的 **fail-fast 机制**。

> **fail-fast 机制** ：多个线程对 fail-fast 集合进行修改的时候，可能会抛出`ConcurrentModificationException`。 即使是单线程下也有可能会出现这种情况，上面已经提到过。
>
> 相关阅读：[什么是fail-fast](https://www.cnblogs.com/54chensongxia/p/12470446.html) 。

Java8 开始，可以使用 `Collection#removeIf()`方法删除满足特定条件的元素,如

```java
List<Integer> list = new ArrayList<>();
for (int i = 1; i <= 10; ++i) {
    list.add(i);
}
list.removeIf(filter -> filter % 2 == 0); /* 删除list中的所有偶数 */
System.out.println(list); /* [1, 3, 5, 7, 9] */
```

除了上面介绍的直接使用 `Iterator` 进行遍历操作之外，你还可以：

- 使用普通的 for 循环
- 使用 fail-safe 的集合类。`java.util`包下面的所有的集合类都是 fail-fast 的，而`java.util.concurrent`包下面的所有的类都是 fail-safe 的。
- ......

## 集合去重

> **可以利用 `Set` 元素唯一的特性，可以快速对一个集合进行去重操作，避免使用 `List` 的 `contains()` 进行遍历去重或者判断包含操作。**

两者的核心差别在于 `contains()` 方法的实现。

`HashSet` 的 `contains()` 方法底部依赖的 `HashMap` 的 `containsKey()` 方法

## 集合转数组

> **使用集合转数组的方法，必须使用集合的 `toArray(T[] array)`，传入的是类型完全一致、长度为 0 的空数组。**

`toArray(T[] array)` 方法的参数是一个泛型数组，如果 `toArray` 方法中没有传递任何参数的话返回的是 `Object`类 型数组。

```java
String [] s= new String[]{
    "dog", "lazy", "a", "over", "jumps", "fox", "brown", "quick", "A"
};
List<String> list = Arrays.asList(s);
Collections.reverse(list);
//没有指定类型的话会报错
s=list.toArray(new String[0]);
```

`new String[0]`就是起一个模板的作用，指定了返回数组的类型，0 是为了节省空间，因为它只是为了说明返回的类型。

##  数组转集合

> 使用工具类 `Arrays.asList()` 把数组转换成集合时，不能使用其修改集合相关的方法， 它的 `add/remove/clear` 方法会抛出 `UnsupportedOperationException` 异常。

`Arrays.asList()`在平时开发中还是比较常见的，我们可以使用它将一个数组转换为一个 `List` 集合。

```java
String[] myArray = {"Apple", "Banana", "Orange"};
List<String> myList = Arrays.asList(myArray);
//上面两个语句等价于下面一条语句
List<String> myList = Arrays.asList("Apple","Banana", "Orange");
```

JDK 源码对于这个方法的说明：

```java
/**
  *返回由指定数组支持的固定大小的列表。此方法作为基于数组和基于集合的API之间的桥梁，
  * 与 Collection.toArray()结合使用。返回的List是可序列化并实现RandomAccess接口。
  */
public static <T> List<T> asList(T... a) {
    return new ArrayList<>(a);
}
```

下面我们来总结一下使用注意事项。

**1、`Arrays.asList()`是泛型方法，传递的数组必须是对象数组，而不是基本类型。**

```java
int[] myArray = {1, 2, 3};
List myList = Arrays.asList(myArray);
System.out.println(myList.size());//1
System.out.println(myList.get(0));//数组地址值
System.out.println(myList.get(1));//报错：ArrayIndexOutOfBoundsException
int[] array = (int[]) myList.get(0);
System.out.println(array[0]);//1
```

当传入一个原生数据类型数组时，`Arrays.asList()` 的真正得到的参数就不是数组中的元素，而是数组对象本身！此时 `List` 的唯一元素就是这个数组，这也就解释了上面的代码。

我们使用包装类型数组就可以解决这个问题。

```java
Integer[] myArray = {1, 2, 3};
```

**2、使用集合的修改方法: `add()`、`remove()`、`clear()`会抛出异常。**

```java
List myList = Arrays.asList(1, 2, 3);
myList.add(4);//运行时报错：UnsupportedOperationException
myList.remove(1);//运行时报错：UnsupportedOperationException
myList.clear();//运行时报错：UnsupportedOperationException
```

`Arrays.asList()` 方法返回的并不是 `java.util.ArrayList` ，而是 `java.util.Arrays` 的一个内部类,这个内部类并没有实现集合的修改方法或者说并没有重写这些方法。

```java
List myList = Arrays.asList(1, 2, 3);
System.out.println(myList.getClass());//class java.util.Arrays$ArrayList
```



### **那我们如何正确的将数组转换为 `ArrayList` ?**

1、手动实现工具类

```java
//JDK1.5+
static <T> List<T> arrayToList(final T[] array) {
  final List<T> l = new ArrayList<T>(array.length);

  for (final T s : array) {
    l.add(s);
  }
  return l;
}


Integer [] myArray = { 1, 2, 3 };
System.out.println(arrayToList(myArray).getClass());//class java.util.ArrayList
```

#### 2、最简便的方法

```java
List list = new ArrayList<>(Arrays.asList("a", "b", "c"))
```

#### 3、使用 Java8 的 `Stream`(推荐)

```java
Integer [] myArray = { 1, 2, 3 };
List myList = Arrays.stream(myArray).collect(Collectors.toList());
//基本类型也可以实现转换（依赖boxed的装箱操作）
int [] myArray2 = { 1, 2, 3 };
List myList = Arrays.stream(myArray2).boxed().collect(Collectors.toList());
```

#### 4、使用 Guava

对于不可变集合，你可以使用[`ImmutableList`open in new window](https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/ImmutableList.java)类及其[`of()`open in new window](https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/ImmutableList.java#L101)与[`copyOf()`open in new window](https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/ImmutableList.java#L225)工厂方法：（参数不能为空）

```java
List<String> il = ImmutableList.of("string", "elements");  // from varargs
List<String> il = ImmutableList.copyOf(aStringArray);      // from array
```

对于可变集合，你可以使用[`Lists`open in new window](https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/Lists.java)类及其[`newArrayList()`open in new window](https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/Lists.java#L87)工厂方法：

```java
List<String> l1 = Lists.newArrayList(anotherListOrCollection);    // from collection
List<String> l2 = Lists.newArrayList(aStringArray);               // from array
List<String> l3 = Lists.newArrayList("or", "string", "elements"); // from varargs
```

5、使用 Apache Commons Collections

```java
List<String> list = new ArrayList<String>();
CollectionUtils.addAll(list, str);
```

6、 使用 Java9 的 `List.of()`方法

```java
Integer[] array = {1, 2, 3};
List<Integer> list = List.of(array);
```

## 讲一下在java中的对象类型、包装类型、引用类型

1. **对象类型**（Object Type）是指使用关键字new创建的对象类型，如String、Integer等。**对象类型是一种引用类型**，即这些对象存储在堆内存中，并由引用变量指向。 
2. **包装类型**（Wrapper Type）是Java提供的一种将基本数据类型转换为对象类型的机制，如int对应的包装类型是Integer。**包装类型也是对象类型的一种**。 
3. **引用类型**（Reference Type）是指使用引用变量来引用的类型，**包括对象类型和数组类型**。引用类型的变量存储的是一个内存地址，指向实际存储数据的位置。引用类型和基本数据类型的区别在于，基本数据类型的变量直接存储数据本身，而引用类型的变量存储的是内存地址。 

总结来说，对象类型和包装类型都是引用类型的一种，都是使用new创建的对象，但**包装类型是将基本数据类型转换为对象类型**，而**对象类型则是直接使用类名创建的对象**。而**引用类型则是指使用引用变量来引用的类型**，包括对象类型和数组类型。
