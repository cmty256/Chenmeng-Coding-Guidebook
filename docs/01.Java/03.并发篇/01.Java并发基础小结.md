---
title: Java并发基础小结
date: 2023-06-12 22:24:58
permalink: /pages/846d88/
---
# Java并发基础小结

## 线程和进程的区别

### 什么是进程？

**进程是系统运行程序的基本单位**，我们计算机启动的每一个应用程序都是一个进程。如下图所示，在 `Windows` 中这一个个 `exe` 文件，都是一个进程。而在 `JVM` 下，每一个启动的 `Main` 方法都可以看作一个进程。

![image](https://cdn.jsdelivr.net/gh/cmty256/imgs-blog@main/Java/image.1nbsrx7zj5ds.webp)

### 什么是线程？

**线程是一个比进程更小的执行单位，是 CPU 调度的基本单位。**一个进程在其执行的过程中可以产生多个线程。所以在进行线程切换时的开销会远远小于进程，线程也常常被称为**轻量级进程**。

与进程不同的是同类的多个线程共享进程的**堆**和**方法区**资源，但每个线程有自己的**程序计数器**、**虚拟机栈**和**本地方法栈**。

### 区别

1. **线程是轻量级的执行单元，而进程是重量级的执行单元**。在 Java 中，线程由 Java 虚拟机来创建和管理，**一个进程可以包含多个线程**。
2. 线程共享进程的内存空间和资源，**可以通过共享内存来进行通信和同步**。进程拥有自己的内存空间和资源，**需要通过进程间通信（IPC）来进行通信和同步**。
3. **线程之间的切换开销比进程小**，因为线程共享进程的资源，不需要切换进程的内存空间和资源。线程之间的切换只需要切换线程的执行上下文即可。
4. **线程之间的同步和通信比进程更容易**，因为线程之间共享进程的内存空间，可以直接共享数据和对象。而进程之间需要通过IPC机制来进行通信和同步，开销较大。
5. **线程的生命周期受到进程的影响**，一个进程退出时，它包含的所有线程都会被强制退出。而进程的生命周期不受其他进程的影响，一个进程可以独立于其他进程运行。

## 什么是线程上下⽂切换?

线程上下文切换是指：**CPU 从一个线程中断执行转而执行另一个线程的过程**。

在多线程编程中，线程上下文切换是非常常见的操作。

这个过程需要耗费一定的时间和资源，因此线程上下文切换的频繁发生会导致系统的性能下降。

> *1、什么是上下文*

**线程在执行过程中会有自己的运行条件和状态**（也称上下文）。

比如程序计数器，栈信息等。当出现如下情况的时候，线程会从占用 CPU 状态中退出。（上下文切换通常发生在以下几种情况）

- **主动让出 CPU**，比如调用了 `sleep()`, `wait()` 等。
- **时间片用完**，因为操作系统要防止一个线程或者进程长时间占用 CPU 导致其他线程或者进程饿死。
- **调用了阻塞类型的系统中断**，比如请求 IO，线程被阻塞。
- **被终止或结束运行**。

> *2、为了减少线程上下文切换带来的性能损失，可以采取以下措施：*

- **减少线程数**，避免无谓的上下文切换；
- **采用线程池技术**，避免线程的频繁创建和销毁；
- **使用非阻塞式 I/O**，避免线程等待 I/O 完成时的上下文切换；
- **优化线程的调度算法**，减少线程上下文切换的次数。

## sleep() 和 wait()

### 共同点

两者都可以暂停线程的执行。

### 区别

1. **`sleep()` 方法没有释放锁，而 `wait()` 方法释放了锁** 。
2. `wait()` 通常被用于线程间交互/通信，`sleep()` 通常被用于暂停执行。
3. `wait()` 方法被调用后，线程**不会自动苏醒**，需要别的线程调用同一个对象上的 `notify()` 或者 `notifyAll()` 方法。`sleep()` 方法执行完成后，线程**会自动苏醒**，或者也可以使用 `wait(long timeout)` 超时后线程会自动苏醒。
4. `sleep()` 是 `Thread` 类的静态本地方法，`wait()` 则是 `Object` 类的本地方法。

## 讲⼀下 JMM(Java 内存模型)

Java 内存模型（Java Memory Model，JMM）**是 Java 虚拟机规范中的一部分**，它**定义了 Java 程序中各种变量的访问方式和存储方式**。

JMM 的**作用**是：解决并发编程中的线程安全问题，确保多线程环境下程序的正确性和稳定性。

主要包括以下几个方面：

1. **主内存和工作内存**：Java 内存模型将内存分为主内存和工作内存两部分。

   - 主内存是所有线程共享的内存区域，而每个线程都有自己的工作内存，工作内存中保存了该线程使用到的变量的副本。

   - 线程不能直接对主内存进行操作，而是需要先将变量的副本从主内存中读取到工作内存中，然后再对变量进行操作，操作完成后再将变量的副本写回到主内存中。

2. **内存屏障**：内存屏障（Memory Barrier）是一种**机制，用于确保线程之间的内存可见性和操作的有序性**。

   - JMM 中定义了四种内存屏障：Load Barrier、Store Barrier、Read Barrier、Write Barrier，分别用于确保变量的读、写和读写操作的顺序和可见性。

3. **happens-before 关系**：happens-before 是 Java 内存模型中的一个**概念，用于描述变量之间的先后顺序和可见性**。

   - 如果一个操作 happens-before 另一个操作，那么第一个操作的结果对第二个操作是可见的，而且第一个操作的执行顺序在第二个操作之前。

4. **原子性、可见性和有序性**：JMM 保证了原子性、可见性和有序性的内存操作。

   - 原子性指的是一个操作是不可分割的整体，要么全部执行，要么全部不执行；

   - 可见性指的是一个线程对变量的修改对其他线程是可见的；
   - 有序性指的是指令的执行顺序是有序的，保证了程序的正确性。 

## AQS

### 什么是 AQS

AQS，全称为 AbstractQueuedSynchronizer，是 Java 并发编程中的一个重要组件。

它提供了一种灵活的框架，**可以用来实现各种同步工具**，比如锁、信号量、倒计时门栓等。

### AQS 原理了解么？

AQS 的**核心思想**是使用一个 FIFO 的等待队列来管理线程的获取和释放资源。

AQS 维护一个 state 变量，用来表示同步状态，同时通过一个双向链表来实现等待队列，并提供了 acquire、release、tryAcquire、tryRelease 等方法，允许子类通过重写这些方法来实现特定的同步逻辑。

### 用过 CountDownLatch 么？什么场景下用的？

> 概念

CountDownLatch 是 Java 并发编程中的一个**同步工具**，它允许一个或多个线程等待其他线程完成操作后再执行。

> 原理

CountDownLatch 的**核心思想**是：通过一个计数器来实现，计数器初始值为线程数，每个线程完成操作后会将计数器 -1，当计数器减为 0 时，所有等待的线程都会被唤醒。

> 用法

CountDownLatch 的**用法如下**：

1. 创建 CountDownLatch 对象，并指定计数器的初始值。
2. 各个线程执行任务，并在任务完成后调用 CountDownLatch 的 countDown 方法，将计数器 -1。
3. 主线程调用 CountDownLatch 的 await 方法，等待所有任务完成。 

> 应用场景

CountDownLatch 的**应用场景**包括：

1. 主线程等待多个子线程完成任务后再执行，可以使用 CountDownLatch 来实现。
2. 一些任务需要等待其他任务完成后才能执行，可以使用 CountDownLatch 来实现。
3. 测试场景中，可以使用 CountDownLatch 来控制测试用例的执行顺序。
4. 多个线程并发执行，需要等待所有线程完成后再进行合并操作，可以使用 CountDownLatch 来实现。