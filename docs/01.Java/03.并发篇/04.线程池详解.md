---
title: 线程池详解
date: 2023-06-14 20:18:11
permalink: /pages/040070/
---
# 线程池详解

## 什么是线程池？

线程池就是管理一系列线程的资源池。

当有任务要处理时，直接从线程池中获取线程来处理，处理完之后线程并不会立即被销毁，而是等待下一个任务。

## 为什么要用线程池？

简单来说，是因为使用线程池可以**提高资源的利用率**。

使用线程池有三大好处：

1. **提高响应速度**。通过线程池创建一系列线程，使用时直接通过线程池获取，不再需要手动创建线程，响应速度自然就大大提高了。
2. **降低资源消耗**。由于线程池被池化管理了，我们无需为了某些功能去手动创建和销毁线程，资源消耗自然降低。
3. **提高线程的可管理性**。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。

## Java 线程池有哪些参数？

通过 `Executors` 框架创建的线程池，从源码可以看到，它底层是通过 `ThreadPoolExecutor` 完成线程池的创建，具体参数如下：

```java
 public static ExecutorService newFixedThreadPool(int nThreads) {
        return new ThreadPoolExecutor(nThreads, nThreads,
                                      0L, TimeUnit.MILLISECONDS,
                                      new LinkedBlockingQueue<Runnable>());
    }

```

1. corePoolSize：线程池的**核心线程数**，即线程池中始终保持的线程数。

2. maximumPoolSize：线程池中**最大的线程数**，包括核心线程数和非核心线程数。

   > 核心线程数和最大线程数的区别在于：
   >
   > 在任务数超过核心线程数时，线程池会优先创建核心线程来执行任务，只有当任务队列已满且核心线程都在执行任务时，才会创建非核心线程来执行任务，直到达到最大线程数为止。

3. keepAliveTime：**非核心线程的闲置时间**，超过该时间后将被回收。

4. unit：keepAliveTime 非核心线程的闲置**时间的单位**。

5. workQueue：**任务队列**，用于存储还未被执行的任务。

6. threadFactory：**线程工厂**，用于创建线程。

7. handler：**饱和策略**，即当线程池中的线程都在执行任务时，新的任务会如何处理。（**也称为拒绝策略**）

## 拒绝策略有⼏种？

有四种常见的拒绝策略：

1. AbortPolicy：直接抛出异常，阻止系统正常运行。
2. CallerRunsPolicy：只用调用者所在线程来执行任务。
3. DiscardOldestPolicy：丢弃队列中最老的一个任务，尝试再次提交当前任务。
4. DiscardPolicy：直接丢弃任务，不做任何处理。

## 阻塞队列有⼏种？

Java 中常用的阻塞队列有以下几种：

1. `ArrayBlockingQueue`：一个由**数组结构组成的有界阻塞队列**，按照先进先出的原则对元素进行排序。

2. `LinkedBlockingQueue`：一个由**链表结构组成的可选有界阻塞队列**，按照先进先出的原则对元素进行排序。

   如果队列容量没有限制，则为**无界阻塞队列**。

3. `PriorityBlockingQueue`：一个支持**优先级排序的无界阻塞队列**。

4. `SynchronousQueue`：一个**不存储元素的阻塞队列**，每个插入操作必须等待另一个线程的移除操作，否则插入操作一直处于阻塞状态。

## 新线程添加的流程?

新线程的添加有以下 4 个流程：

1. 如果当前线程池中的线程数**小于核心线程数**，那么就创建一个新的核心线程来执行这个任务；

2. 如果当前线程池中的线程数已经**达到了核心线程数**，那么就将任务添加到任务队列中等待执行；

3. 如果**任务队列已满**，但当前线程池中的线程数**还没有达到最大线程数**，那么就创建一个新的非核心线程来执行这个任务；

   > 非核心线程在执行完任务之后会被回收，直到线程池中的线程数又重新降至核心线程数。

4. 如果当前线程池中的线程数已经**达到了最大线程数，那么就根据饱和策略来处理这个任务**。

## 实现 Runnable 接⼝和 Callable 接⼝的区别？

Java 中的 Runnable 接口和 Callable 接口都是用来创建多线程的接口，它们的区别如下：

1. **方法名不同**。

   - Runnable 接口**只有一个 `run()` 方法**，
   - 而 Callable 接口**只有一个 `call()` 方法**。

2. **返回值不同**。

   - Runnable 的 `run()` 方法**没有返回值**，

   - 而 Callable 的 `call()` 方法**可以返回执行结果**。

3. **异常处理不同**。

   - Runnable 的 `run()` 方法**不能抛出异常**，
   - 而 Callable 的 `call()` 方法**可以抛出异常**，并且需要在调用 `Future.get()` 方法时进行异常处理。

4. **调用方式不同**。

   - Runnable 接口**可以通过 Thread 类的构造方法来创建一个新的线程并启动它**，
   - 而 Callable 接口则**需要借助 Executor 框架来执行**。

5. **用途不同**。

   - Runnable 接口**通常用于需要执行一些简单的任务的场景**，
   - Callable 接口**通常用于需要返回结果、或者需要抛出异常、或者需要在执行任务前进行一些初始化操作的场景**。

