---
title: 开发小记
date: 2023-08-31 09:08:03
permalink: /pages/3cd6be/
---
# 开发小记

## 开发整体流程

任务安排 -> 环境服务配置 -> 开发 -> 本地测试 -> Maven 打包 -> 服务器测试 -> 发布上线

*具体开发情况*

1. 先写个小 demo
2. 然后逐步完善功能，以最快的方式完成任务需求
3. 融进项目模块，上传到远程仓库
4. 优化代码结构
5. 完善代码逻辑，比如让日志打印的更加清晰，方便线上排查问题

## 开发注意事项

1. 需打印日志，方便后续排查问题（控制台打印不行，因为看不到）
2. 遇到写动态 URL 的场景，要把服务 ip 和参数写活，然后字符串拼接，服务 ip 地址可以在 nacos 上配置，然后动态注入



## 使用服务器配置属性

```java
@Data
@Component("properties")
@Configuration
public class Properties {

  /**
   * 图像链接前缀
   */
  @Value("${url.pre}")
  private String urlPre;

}
```

*为什么 @Component("properties") 这里要加参数？*

`@Component` 注解用于将一个类标记为 Spring 容器中的一个组件，以便 Spring 在启动时能够扫描并将该类初始化为一个 Bean。

通常情况下，`@Component` 注解不需要参数，但在特定情况下，你可能会为该注解提供一个参数。

在上面的代码中，`@Component("properties")` 中的参数 `"properties"` 是一个用来标识该组件的名称。这个名称在 Spring 容器中是唯一的，可以用来作为 Bean 的标识符。使用该参数的目的通常是为了明确指定这个 Bean 的名称，而不是使用默认的类名首字母小写作为 Bean 的名称。

例如，如果没有指定参数 `"properties"`，Spring 容器会默认使用类名 `Properties` 首字母小写作为 Bean 的名称。但是，类名 `Properties` 可能与 Java 标准库中的 `java.util.Properties` 类名相同，可能会引起混淆。为了避免这种混淆，并明确指定 Bean 的名称，你可以使用 `@Component("properties")`。

总之，参数 `"properties"` 并不是必需的，但它可以帮助你在 Spring 容器中标识和管理这个组件，特别是当类名可能引起命名冲突时。

*使用*

只需要在指定类里面注入 bean 即可。

```java
  @Resource
  private Properties properties;
```

然后通过 get 方法获取对应值

```java
String urlPre = properties.getUrlPre();
```

## 代码优化

### KafkaProvider

> KafkaProvider 消息生产者类优化

#### 优化前

```java
@Slf4j
@Component
public class KafkaProvider {
  private final StreamBridge streamBridge;

  public KafkaProvider(StreamBridge streamBridge) {
    this.streamBridge = streamBridge;
  }

  public void sendFace(Object msg) {

    streamBridge.send("face_output", MessageBuilder.withPayload(msg).build());
    log.info("-----------------send faceMessage success-------------------");

  }

  public void sendHuman(Object msg) {

    streamBridge.send("human_output", MessageBuilder.withPayload(msg).build());
    log.info("-----------------send humanMessage success-------------------");

  }

  public void sendVehicle(Object msg) {

    streamBridge.send("vehicle_output", MessageBuilder.withPayload(msg).build());
    log.info("-----------------send vehicleMessage success-------------------");

  }

}
```

#### 优化考虑

1. **重复代码的提取**：在 `sendFace`、`sendHuman` 和 `sendVehicle` 方法中，有重复的代码。你可以将发送消息的部分提取为一个私有方法，以减少重复代码。
2. **日志统一管理**：在每个发送消息的方法中，都有一个日志输出。你可以考虑将日志的部分提取为一个私有方法，以便统一管理和修改日志输出格式。
3. **使用常量**：在消息通道的名称上，你使用了字符串字面值。考虑使用常量来定义这些名称，这样可以避免在多个地方使用相同的字符串时出现拼写错误。
4. **添加异常处理**：在发送消息时，可能会发生一些异常情况，例如连接失败。你可以考虑添加适当的异常处理，以便在发生异常时能够处理和记录异常信息。

#### 优化后

```java
@Slf4j
@Component
public class KafkaProvider {
    private final StreamBridge streamBridge;
    private static final String FACE_OUTPUT_CHANNEL = "face_output";
    private static final String HUMAN_OUTPUT_CHANNEL = "human_output";
    private static final String VEHICLE_OUTPUT_CHANNEL = "vehicle_output";

    public KafkaProvider(StreamBridge streamBridge) {
        this.streamBridge = streamBridge;
    }

    public void sendFace(Object msg) {
        sendToChannel(FACE_OUTPUT_CHANNEL, msg);
    }

    public void sendHuman(Object msg) {
        sendToChannel(HUMAN_OUTPUT_CHANNEL, msg);
    }

    public void sendVehicle(Object msg) {
        sendToChannel(VEHICLE_OUTPUT_CHANNEL, msg);
    }

    private void sendToChannel(String channelName, Object msg) {
        try {
            streamBridge.send(channelName, MessageBuilder.withPayload(msg).build());
            logInfo("send " + channelName + "Message success !!!");
        } catch (Exception e) {
            logError("Error sending message to " + channelName + " channel: " + e.getMessage());
        }
    }

    private void logInfo(String message) {
        log.info("----------------" + message + "-------------------");
    }

    private void logError(String message) {
        log.error("----------------" + message + "-------------------");
    }
}
```

### KafkaConsumer

> KafkaConsumer 消费者类优化

#### 优化前

```java
@Slf4j
@Component
public class KafkaConsumer {

  @Resource
  private KafkaProvider kafkaProvider;
  @Resource
  private Properties properties;

  @Bean
  public Consumer<String> face_input() {
    return message -> {

      // 1、将消息中的 \t 转换成 四个空格
      String formattedJson = message.replace("\t", "    "); // 4 spaces

      // 2、获取消息中对应 key 中的值
      cn.hutool.json.JSONObject jsonObject = JSONUtil.parseObj(formattedJson);

      String json = jsonObject.getStr("data");
      cn.hutool.json.JSONObject dataObject = JSONUtil.parseObj(json);
      cn.hutool.json.JSONObject faceListObject = dataObject.getJSONObject("FaceListObject");
      JSONArray faceObject = faceListObject.getJSONArray("FaceObject");

      List<Dict> list = JSONUtil.toList(faceObject, Dict.class);
      int leftTopY = (int) list.get(0).get("LeftTopY");
      int leftTopX = (int) list.get(0).get("LeftTopX");
      int ageLowerLimit = (int) list.get(0).get("AgeLowerLimit");
      String deviceID = String.valueOf(list.get(0).get("DeviceID"));
      int ageUpLimit = (int) list.get(0).get("AgeUpLimit");
      String genderType = String.valueOf(list.get(0).get("GenderType"));
      String faceID = String.valueOf(list.get(0).get("FaceID"));

      // 获取人脸图像 base64
      JSONObject subImageList = (JSONObject) list.get(0).get("SubImageList");
      JSONArray subImageInfoObjectArray = subImageList.getJSONArray("SubImageInfoObject");
      List<Dict> subImageInfoObjectList = JSONUtil.toList(subImageInfoObjectArray, Dict.class);
      String faceImageData = String.valueOf(subImageInfoObjectList.get(0).get("Data"));
      int height = (int) subImageInfoObjectList.get(0).get("Height");
      int width = (int) subImageInfoObjectList.get(0).get("Width");
      String shotTime = String.valueOf(subImageInfoObjectList.get(0).get("ShotTime"));
      String smallType = String.valueOf(subImageInfoObjectList.get(0).get("Type"));
      String bigType = String.valueOf(subImageInfoObjectList.get(1).get("Type"));

      // 3、给需要生产的 DTO 对象赋值
      FaceDTO faceDTO = new FaceDTO();
      faceDTO.setCJSJ(null); // 接入时间
      FaceRectDTO faceRectDTO = new FaceRectDTO(leftTopY, leftTopX, height, width);
      faceDTO.setFACE_RECT(faceRectDTO);
      faceDTO.setAGE_LOWER_LIMIT(ageLowerLimit);
      faceDTO.setDEVICE_ID(deviceID);
      faceDTO.setFaceImageData(faceImageData);
      faceDTO.setJGSK(Long.valueOf(shotTime)); // 抓拍时间 -- 拍摄时间
      faceDTO.setAGE(null); // 年龄段
      faceDTO.setPIC(properties.getUrlPre() + "/get/image?type=face&id=" + faceID + "&channelCode=" + deviceID + "&imageType=" + bigType); // 背景图接口地址
      faceDTO.setOBJ_PIC(properties.getUrlPre() + "/get/image?type=face&id=" + faceID + "&channelCode=" + deviceID + "&imageType=" + smallType); // 人脸图接口地址
      faceDTO.setWITH_HAT(null); // 是否戴帽子
      faceDTO.setAGE_UP_LIMIT(ageUpLimit);
      faceDTO.setGENDER_CODE(Integer.valueOf(genderType));
      faceDTO.setINFO_ID(faceID);
      faceDTO.setWITH_GLASSES(null); // 是否戴眼镜
      faceDTO.setFACE_EXPRESSION(null); // 表情
      faceDTO.setVIID_OBJECT_ID("null"); // 人脸抓拍视图库标识 -- 有字段
      faceDTO.setFACE_SCORE(null); // 人脸分数
      faceDTO.setDATA_SRC(null); // 数据来源 int
      faceDTO.setSMILE(null); // 是否微笑
      faceDTO.setRACE(null); // 种族
      faceDTO.setWITH_RESPIRATOR(null); // 是否戴口罩

      // 4、将DTO对象转换成JSON对象 -- 不跳过空值，输出的字段顺序和Bean的字段顺序保持一致
      cn.hutool.json.JSONObject faceRes = JSONUtil.parseObj(faceDTO, false, true);

      // 5、转成字符串类型并美化输出
      String faceStr = faceRes.toStringPretty();

      log.info("------------------Face--------------------------");
      // 6、判断字符串不为空，则发送消息
      if (faceStr != null) {
        log.info("人脸ID：{}", faceID);
        log.info("全景图URL：{}", faceDTO.getPIC());
        log.info("人脸图URL：{}", faceDTO.getOBJ_PIC());
        kafkaProvider.sendFace(faceStr);
      }
    };
  }

  @Bean
  public Consumer<String> human_input() {
    return message -> {

      // 1、将消息中的 \t 转换成 四个空格
      String formattedJson = message.replace("\t", "    "); // 4 spaces

      // 2、获取消息中对应 key 中的值
      cn.hutool.json.JSONObject jsonObject = JSONUtil.parseObj(formattedJson);

      String json = jsonObject.getStr("data");
      cn.hutool.json.JSONObject dataObject = JSONUtil.parseObj(json);
      cn.hutool.json.JSONObject personListObject = dataObject.getJSONObject("PersonListObject");
      JSONArray personObject = personListObject.getJSONArray("PersonObject");

      // System.out.println(personObject.toStringPretty());

      List<Dict> list = JSONUtil.toList(personObject, Dict.class);
      String coatColor = String.valueOf(list.get(0).get("CoatColor"));
      String genderCode = String.valueOf(list.get(0).get("GenderCode"));
      String personID = String.valueOf(list.get(0).get("PersonID"));
      String coatLength = String.valueOf(list.get(0).get("CoatLength"));
      int leftTopY = (int) list.get(0).get("LeftTopY");
      int leftTopX = (int) list.get(0).get("LeftTopX");
      String deviceID = String.valueOf(list.get(0).get("DeviceID"));

      // 获取人体图像 base64
      JSONObject subImageList = (JSONObject) list.get(0).get("SubImageList");
      JSONArray subImageInfoObjectArray = subImageList.getJSONArray("SubImageInfoObject");
      List<Dict> subImageInfoObjectList = JSONUtil.toList(subImageInfoObjectArray, Dict.class);
      String shotTime = String.valueOf(subImageInfoObjectList.get(0).get("ShotTime"));
      String smallType = String.valueOf(subImageInfoObjectList.get(0).get("Type"));
      String bigType = String.valueOf(subImageInfoObjectList.get(1).get("Type"));
      int height = (int) subImageInfoObjectList.get(0).get("Height");
      int width = (int) subImageInfoObjectList.get(0).get("Width");

      // 3、给需要生产的 DTO 对象赋值
      HumanDTO humanDTO = new HumanDTO();
      humanDTO.setCJSJ(null); // 采集时间
      humanDTO.setVIID_OBJECT_ID("null"); // 行人抓拍视图库标识
      humanDTO.setJGSK(Long.valueOf(shotTime)); // 经过日期时间
      humanDTO.setWITH_RESPIRATOR(null); // 是否戴口罩
      humanDTO.setAGE(null); // 年龄段String urlPre = properties.getUrlPre();
      humanDTO.setPIC(properties.getUrlPre() + "/get/image?type=person&id=" + personID + "&channelCode=" + deviceID + "&imageType=" + bigType); // 全景图接口地址
      humanDTO.setOBJ_PIC(properties.getUrlPre() + "/get/image?type=person&id=" + personID + "&channelCode=" + deviceID + "&imageType=" + smallType); // 人体图接口地址
      humanDTO.setWITH_HAT(null); // 是否带帽子
      humanDTO.setCOAT_COLOR(Integer.valueOf(coatColor)); // 上衣颜色
      humanDTO.setHAIR_LENGTH(null);
      humanDTO.setGENDER_CODE(Integer.valueOf(genderCode));
      humanDTO.setINFO_ID(null); // 转换 Long 失败
      humanDTO.setWITH_BACKPACK(null);
      humanDTO.setWITH_GLASSES(null);
      humanDTO.setCOAT_LENGTH(Integer.valueOf(coatLength));
      humanDTO.setRIDE_BIKE(null);
      humanDTO.setFACE_SCORE(null);
      humanDTO.setDATA_SRC(null);
      humanDTO.setOBJ_RECT(new ObjRectDTO(leftTopY, leftTopX, height, width));
      humanDTO.setMOTION_SPEED(null);
      humanDTO.setDEVICE_ID(deviceID);

      // 4、将DTO对象转换成JSON对象 -- 不跳过空值，输出的字段顺序和Bean的字段顺序保持一致
      JSONObject humanRes = JSONUtil.parseObj(humanDTO, false, true);

      // 5、转成字符串类型并美化输出
      String humanStr = humanRes.toStringPretty();

      log.info("------------------Human--------------------------");
      // 6、判断字符串不为空，则发送消息
      if (humanStr != null) {
        log.info("人体ID：{}", personID);
        log.info("全景图URL：{}", humanDTO.getPIC());
        log.info("人体图URL：{}", humanDTO.getOBJ_PIC());
        kafkaProvider.sendHuman(humanStr);
      }

    };
  }

  @Bean
  public Consumer<String> vehicle_input() {
    return message -> {
      // 1、将消息中的 \t 转换成 四个空格
      String formattedJson = message.replace("\t", "    "); // 4 spaces

      // 2、获取消息中对应 key 中的值
      JSONObject jsonObject = JSONUtil.parseObj(formattedJson);

      String json = jsonObject.getStr("data");
      JSONObject dataObject = JSONUtil.parseObj(json);
      JSONObject vehicleListObject = dataObject.getJSONObject("MotorVehicleListObject");
      JSONArray vehicleObject = vehicleListObject.getJSONArray("MotorVehicleObject");

      List<Dict> list = JSONUtil.toList(vehicleObject, Dict.class);
      String vehicleColor = String.valueOf(list.get(0).get("VehicleColor"));
      String plateColor = String.valueOf(list.get(0).get("PlateColor"));
      String hasPlate = String.valueOf(list.get(0).get("HasPlate"));
      String plateClass = String.valueOf(list.get(0).get("PlateClass"));
      String plateNo = String.valueOf(list.get(0).get("PlateNo"));
      String deviceID = String.valueOf(list.get(0).get("DeviceID"));
      String motorVehicleID = String.valueOf(list.get(0).get("MotorVehicleID"));
      String vehicleClass = String.valueOf(list.get(0).get("VehicleClass"));
      String vehicleBrand = String.valueOf(list.get(0).get("VehicleBrand"));
      String vehicleStyles = String.valueOf(list.get(0).get("VehicleStyles"));

      // 获取车辆图像 base64
      JSONObject subImageList = (JSONObject) list.get(0).get("SubImageList");
      JSONArray subImageInfoObjectArray = subImageList.getJSONArray("SubImageInfoObject");
      List<Dict> subImageInfoObjectList = JSONUtil.toList(subImageInfoObjectArray, Dict.class);
      String smallType = String.valueOf(subImageInfoObjectList.get(0).get("Type"));
      String bigType = String.valueOf(subImageInfoObjectList.get(1).get("Type"));

      // 3、给需要生产的实体类对象赋值
      Q_VEHICLE_INPUT qVehicleInput = new Q_VEHICLE_INPUT();
      qVehicleInput.setTOLLGATE_ID("null");
      qVehicleInput.setTollgate_id("null");
      qVehicleInput.setPic_abbreviate(properties.getUrlPre() + "/get/image?type=vehicle&id=" + motorVehicleID + "&channelCode=" + deviceID + "&imageType=" + bigType);
      qVehicleInput.setPIC_ABBREVIATE(properties.getUrlPre() + "/get/image?type=vehicle&id=" + motorVehicleID + "&channelCode=" + deviceID + "&imageType=" + bigType); // 全景图URL
      qVehicleInput.setINFO_ID("null");
      qVehicleInput.setInfo_id("null");
      qVehicleInput.setPIC_PLATE(properties.getUrlPre() + "/get/image?type=vehicle&id=" + motorVehicleID + "&channelCode=" + deviceID + "&imageType=" + smallType); // 车辆小图URL
      qVehicleInput.setPic_plate(properties.getUrlPre() + "/get/image?type=vehicle&id=" + motorVehicleID + "&channelCode=" + deviceID + "&imageType=" + smallType);
      qVehicleInput.setData_src("null");
      qVehicleInput.setDATA_SRC(null);
      qVehicleInput.setTollgate_name("null");
      qVehicleInput.setTOLLGATE_NAME("null");
      qVehicleInput.setDirection_id("null");
      qVehicleInput.setDIRECTION_ID(null);
      qVehicleInput.setDevice_id(deviceID);
      qVehicleInput.setDEVICE_ID(deviceID);
      qVehicleInput.setLane_no("null");
      qVehicleInput.setLANE_NO("null");

      qVehicleInput.setVehicle_color(vehicleColor);
      qVehicleInput.setHPYS(Integer.valueOf(plateColor));
      qVehicleInput.setVehicle_speed("null");
      qVehicleInput.setCOPILOT_CALL("null");
      qVehicleInput.setCARD("null");
      qVehicleInput.setTHIRD_DATA("null");
      qVehicleInput.setDriving_state("null");
      qVehicleInput.setNO_PLATE_CAR(hasPlate);
      qVehicleInput.setBRAND_RELIABILITY("null");
      qVehicleInput.setAERIAL("null");
      qVehicleInput.setHPZL(plateClass);
      qVehicleInput.setPILOT_SUNVISOR("null");
      qVehicleInput.setIN_OUT_TYPE("null");
      qVehicleInput.setPIC_VEHICLE(properties.getUrlPre() + "/get/image?type=vehicle&id=" + motorVehicleID + "&channelCode=" + deviceID + "&imageType=" + smallType); // 车辆小图
      qVehicleInput.setWITH_SUNROOF("null");
      qVehicleInput.setROOF_RACK("null");
      qVehicleInput.setHPHM(plateNo);
      qVehicleInput.setREGION("null");
      qVehicleInput.setORIGINAL_TOLLGATE_ID("null");
      qVehicleInput.setVEHICLE_LENGTH("null");
      qVehicleInput.setPENDANTS("null");
      qVehicleInput.setNODE_CJSJ4("null");
      qVehicleInput.setORG_CODE("null");
      qVehicleInput.setPRE_CAR_LOGO(vehicleBrand);
      qVehicleInput.setCAR_RECT("null");
      qVehicleInput.setLane_type("null");
      qVehicleInput.setRECEIVE_TIMESTAMP("null");
      qVehicleInput.setECSB("null");
      qVehicleInput.setPRE_HPZL("null");
      qVehicleInput.setManufacturer("null");
      qVehicleInput.setSend_flag("null");
      qVehicleInput.setORIGINAL_DEVICE_ID("null");
      qVehicleInput.setBACK_VEHICLE("null");
      qVehicleInput.setCAR_YEAR(vehicleStyles);
      qVehicleInput.setPlate_info("null");
      qVehicleInput.setOCCUPANT_CO_DRIVER("null");
      qVehicleInput.setVEHICLE_APPEARANCE("null");
      qVehicleInput.setPlate_color("null");
      qVehicleInput.setPILOT_SEATBELT("null");
      qVehicleInput.setPass_time("null");
      qVehicleInput.setPRE_HPYS(null);
      qVehicleInput.setTISSUE("null");
      qVehicleInput.setUSING_PROPERTIES_CODE("null");
      qVehicleInput.setVehicle_type("null");
      qVehicleInput.setSend_analysis_req_time("null");
      qVehicleInput.setINPUT_DATE("null");
      qVehicleInput.setPRE_HPHM("null");
      qVehicleInput.setJGSK(null);
      qVehicleInput.setDAMAGED_PARTS("null");
      qVehicleInput.setTHIRD_SRC("null");
      qVehicleInput.setCOMPOSITE_URL("null");
      qVehicleInput.setPRE_CAR_YEAR("null");
      qVehicleInput.setSPEED(null);
      qVehicleInput.setCSYS(null);
      qVehicleInput.setIS_ALTERED(null);
      qVehicleInput.setPLATE_RECT("null");
      qVehicleInput.setHEAVY_TRUCK_COVER("null");
      qVehicleInput.setNAME_OF_PASSED_ROAD("null");
      qVehicleInput.setCOPILOT_SUNVISOR("null");
      qVehicleInput.setPILOT_CALL("null");
      qVehicleInput.setCLLX(vehicleClass);
      qVehicleInput.setPLATE_CHAR_RELIABILITY("null");
      qVehicleInput.setPlate_type("null");
      qVehicleInput.setVEHICLE_WIDTH("null");
      qVehicleInput.setPLATE_RELIABILITY("null");
      qVehicleInput.setALGORITHM_ID("null");
      qVehicleInput.setLATITUDE("null");
      qVehicleInput.setAccess_time("null");
      qVehicleInput.setTHUMBNAIL_URL("null");
      qVehicleInput.setPass_id("null");
      qVehicleInput.setPRE_CLLX(vehicleClass);
      qVehicleInput.setLONGITUDE("null");
      qVehicleInput.setPLATE_UNIFORM("null");
      qVehicleInput.setTHIRD_ID("null");
      qVehicleInput.setVEHICLE_HEIGHT("null");
      qVehicleInput.setSPARE_TIRE("null");
      qVehicleInput.setGRAFFITI("null");
      qVehicleInput.setCOPILOT_SEATBELT("null");
      qVehicleInput.setHPGS("null");
      qVehicleInput.setIS_RENEWAL("null");
      qVehicleInput.setCAR_SERIES("null");
      qVehicleInput.setVEHICLE_MASK("null");
      qVehicleInput.setTrail_plate_info("null");
      qVehicleInput.setCJSJ("null");
      qVehicleInput.setVEHICLE_QUALITY("null");
      qVehicleInput.setVEHICLE_SUNVISOR("null");
      qVehicleInput.setYELLOW_LABEL_CAR("null");
      qVehicleInput.setORGAN_NAME("null");
      qVehicleInput.setILLEGAL("null");
      qVehicleInput.setNeedDelete("null");
      qVehicleInput.setPRE_CSYS(null);
      qVehicleInput.setACCESSORY("null");
      qVehicleInput.setCAR_LOGO(vehicleBrand);
      qVehicleInput.setIS_COVERED("null");
      qVehicleInput.setVIID_OBJECT_ID("null");


      // 4、将DTO对象转换成JSON对象 -- 不跳过空值，输出的字段顺序和Bean的字段顺序保持一致
      JSONObject VehicleRes = JSONUtil.parseObj(qVehicleInput, false, true);

      // 5、转成字符串类型并美化输出
      String vehicleStr = VehicleRes.toStringPretty();

      log.info("------------------Vehicle--------------------------");
      // 6、判断字符串不为空，则发送消息
      if (vehicleStr != null) {
        log.info("车辆ID：{}", motorVehicleID);
        log.info("全景图URL：{}", qVehicleInput.getPIC_ABBREVIATE());
        log.info("车辆小图URL：{}", qVehicleInput.getPIC_PLATE());
        kafkaProvider.sendVehicle(vehicleStr);
      }

    };
  }

}
```

#### 优化考虑

1. **字段处理抽取方法**：在你的代码中，有一些字段处理的逻辑比较复杂，例如从 JSON 数据中获取多层嵌套的字段，可以考虑将这些处理逻辑抽取为私有方法，以提高代码的可读性。
2. **魔法数值的使用**：你在代码中使用了一些魔法数值，如 `0`、`1` 等，建议将这些魔法数值提取为有意义的常量，以增加代码的可读性和维护性。
3. **错误处理**：在你的代码中，对于获取字段值可能会抛出异常，如将字符串转换为整数时。你可以添加适当的错误处理，例如捕获异常并记录错误日志，以便在出现问题时能够更好地定位和排查问题。
4. **逻辑分离**：可以考虑将部分逻辑分离成私有方法，使每个方法保持单一职责，以提高代码的可维护性。
5. **DTO对象的构建**：如果 DTO 对象的字段比较多，可以考虑使用构建者模式或者 Lombok 的 `@Builder` 注解来简化 DTO 对象的构建过程。

#### 优化后

##### MessageProcessor

1、抽象出一个消息处理器，并在其中抽象出公用方法和魔法值

```java
@Component
public class MessageProcessor {

    @Resource
    private Properties properties;
    @Resource
    private TGa1400DataConversionService tGa1400DataConversionService;

    public static final int INDEX_0 = 0; // JSON数组索引 - 0
    public static final int INDEX_1 = 1; // JSON数组索引 - 1

    public FaceDTO processFace(JSONArray faceObject) {

        List<Dict> list = JSONUtil.toList(faceObject, Dict.class);
        Dict faceObjectDict = list.get(INDEX_0);

        String leftTopY = String.valueOf(faceObjectDict.get("LeftTopY"));
        String leftTopX = String.valueOf(faceObjectDict.get("LeftTopX"));
        String ageLowerLimit = String.valueOf(faceObjectDict.get("AgeLowerLimit"));
        String imageCode = String.valueOf(faceObjectDict.get("DeviceID"));
        // 转换值 imageCode - channelCode
        String channelCode = tGa1400DataConversionService.getChannelCode(imageCode);
        String ageUpLimit = String.valueOf(faceObjectDict.get("AgeUpLimit"));
        String genderType = String.valueOf(faceObjectDict.get("GenderType"));
        String faceID = String.valueOf(faceObjectDict.get("FaceID"));

        // 获取人脸图像 base64
        JSONObject subImageList = (JSONObject) faceObjectDict.get("SubImageList");
        JSONArray subImageInfoObjectArray = subImageList.getJSONArray("SubImageInfoObject");

        List<Dict> subImageInfoObjectList = JSONUtil.toList(subImageInfoObjectArray, Dict.class);
        Dict subImageInfoObjectDict = subImageInfoObjectList.get(INDEX_0);
        
        String faceImageData = String.valueOf(subImageInfoObjectDict.get("Data"));
        String height = String.valueOf(subImageInfoObjectDict.get("Height"));
        String width = String.valueOf(subImageInfoObjectDict.get("Width"));
        String shotTime = String.valueOf(subImageInfoObjectDict.get("ShotTime"));
        String smallType = String.valueOf(subImageInfoObjectDict.get("Type"));
        String bigType = String.valueOf(subImageInfoObjectList.get(INDEX_1).get("Type"));

        // 3、给需要生产的 DTO 对象赋值
        FaceDTO faceDTO = new FaceDTO();
        faceDTO.setCJSJ(null); // 接入时间
        faceDTO.setFACE_RECT(createRect(faceObjectDict, subImageInfoObjectDict));
        faceDTO.setAGE_LOWER_LIMIT(ageLowerLimit.equals("null") ? null : Integer.valueOf(ageLowerLimit));
        faceDTO.setDEVICE_ID(channelCode);
        faceDTO.setFaceImageData(faceImageData);
        faceDTO.setJGSK(Long.valueOf(shotTime)); // 抓拍时间 -- 拍摄时间
        faceDTO.setAGE(null); // 年龄段
        faceDTO.setPIC(properties.getUrlPre() + "/get/image?type=face&id=" + faceID + "&channelCode=" + channelCode + "&imageType=" + bigType); // 背景图接口地址
        faceDTO.setOBJ_PIC(properties.getUrlPre() + "/get/image?type=face&id=" + faceID + "&channelCode=" + channelCode + "&imageType=" + smallType); // 人脸图接口地址
        faceDTO.setWITH_HAT(null); // 是否戴帽子
        faceDTO.setAGE_UP_LIMIT(ageUpLimit.equals("null") ? null : Integer.valueOf(ageUpLimit));
        faceDTO.setGENDER_CODE(genderType.equals("null") ? null : Integer.valueOf(genderType));
        faceDTO.setINFO_ID(faceID);
        faceDTO.setWITH_GLASSES(null); // 是否戴眼镜
        faceDTO.setFACE_EXPRESSION(null); // 表情
        faceDTO.setVIID_OBJECT_ID("null"); // 人脸抓拍视图库标识 -- 有字段
        faceDTO.setFACE_SCORE(null); // 人脸分数
        faceDTO.setDATA_SRC(null); // 数据来源 int
        faceDTO.setSMILE(null); // 是否微笑
        faceDTO.setRACE(null); // 种族
        faceDTO.setWITH_RESPIRATOR(null); // 是否戴口罩

        return faceDTO;
    }

    public HumanDTO processPerson(JSONArray personObject) {

        List<Dict> list = JSONUtil.toList(personObject, Dict.class);
        Dict personObjectDict = list.get(INDEX_0);
        
        String coatColor = String.valueOf(personObjectDict.get("CoatColor"));
        String genderCode = String.valueOf(personObjectDict.get("GenderCode"));
        String personID = String.valueOf(personObjectDict.get("PersonID"));
        String coatLength = String.valueOf(personObjectDict.get("CoatLength"));
        String leftTopY = String.valueOf(personObjectDict.get("LeftTopY"));
        String leftTopX = String.valueOf(personObjectDict.get("LeftTopX"));
        String imageCode = String.valueOf(personObjectDict.get("DeviceID"));
        String channelCode = tGa1400DataConversionService.getChannelCode(imageCode);

        // 获取人体图像
        JSONObject subImageList = (JSONObject) personObjectDict.get("SubImageList");
        JSONArray subImageInfoObjectArray = subImageList.getJSONArray("SubImageInfoObject");
        List<Dict> subImageInfoObjectList = JSONUtil.toList(subImageInfoObjectArray, Dict.class);
        Dict subImageInfoObjectDict = subImageInfoObjectList.get(INDEX_0);
        
        String shotTime = String.valueOf(subImageInfoObjectDict.get("ShotTime"));
        String smallType = String.valueOf(subImageInfoObjectDict.get("Type"));
        String bigType = String.valueOf(subImageInfoObjectList.get(INDEX_1).get("Type"));
        String height = String.valueOf(subImageInfoObjectDict.get("Height"));
        String width = String.valueOf(subImageInfoObjectDict.get("Width"));

        // 3、给需要生产的 DTO 对象赋值
        HumanDTO humanDTO = new HumanDTO();
        humanDTO.setCJSJ(null); // 采集时间
        humanDTO.setVIID_OBJECT_ID("null"); // 行人抓拍视图库标识
        humanDTO.setJGSK(Long.valueOf(shotTime)); // 经过日期时间
        humanDTO.setWITH_RESPIRATOR(null); // 是否戴口罩
        humanDTO.setAGE(null); // 年龄段String urlPre = properties.getUrlPre();
        humanDTO.setPIC(properties.getUrlPre() + "/get/image?type=person&id=" + personID + "&channelCode=" + channelCode + "&imageType=" + bigType); // 全景图接口地址
        humanDTO.setOBJ_PIC(properties.getUrlPre() + "/get/image?type=person&id=" + personID + "&channelCode=" + channelCode + "&imageType=" + smallType); // 人体图接口地址
        humanDTO.setWITH_HAT(null); // 是否带帽子
        humanDTO.setCOAT_COLOR(coatColor.equals("null") ? null : Integer.valueOf(coatColor)); // 上衣颜色
        humanDTO.setHAIR_LENGTH(null);
        humanDTO.setGENDER_CODE(genderCode.equals("null") ? null : Integer.valueOf(genderCode));
        humanDTO.setINFO_ID(personID);
        humanDTO.setWITH_BACKPACK(null);
        humanDTO.setWITH_GLASSES(null);
        humanDTO.setCOAT_LENGTH(coatLength.equals("null") ? null : Integer.valueOf(coatLength));
        humanDTO.setRIDE_BIKE(null);
        humanDTO.setFACE_SCORE(null);
        humanDTO.setDATA_SRC(null);
        Integer y = leftTopY.equals("null") ? null : Integer.valueOf(leftTopY);
        Integer x = leftTopX.equals("null") ? null : Integer.valueOf(leftTopX);
        Integer h = height.equals("null") ? null : Integer.valueOf(height);
        Integer w = width.equals("null") ? null : Integer.valueOf(width);
        humanDTO.setOBJ_RECT(createRect(personObjectDict, subImageInfoObjectDict));
        humanDTO.setMOTION_SPEED(null);
        humanDTO.setDEVICE_ID(channelCode);

        return humanDTO;
    }

    public Q_VEHICLE_INPUT processVehicle(JSONArray vehicleObject) {

        List<Dict> list = JSONUtil.toList(vehicleObject, Dict.class);
        String vehicleColor = String.valueOf(list.get(INDEX_0).get("VehicleColor"));
        String plateColor = String.valueOf(list.get(INDEX_0).get("PlateColor"));
        String hasPlate = String.valueOf(list.get(INDEX_0).get("HasPlate"));
        String plateClass = String.valueOf(list.get(INDEX_0).get("PlateClass"));
        String plateNo = String.valueOf(list.get(INDEX_0).get("PlateNo"));
        String imageCode = String.valueOf(list.get(INDEX_0).get("DeviceID"));
        String channelCode = tGa1400DataConversionService.getChannelCode(imageCode);
        String motorVehicleID = String.valueOf(list.get(INDEX_0).get("MotorVehicleID"));
        String vehicleClass = String.valueOf(list.get(INDEX_0).get("VehicleClass"));
        String vehicleBrand = String.valueOf(list.get(INDEX_0).get("VehicleBrand"));
        String vehicleStyles = String.valueOf(list.get(INDEX_0).get("VehicleStyles"));

        // 获取车辆图像 base64
        JSONObject subImageList = (JSONObject) list.get(INDEX_0).get("SubImageList");
        JSONArray subImageInfoObjectArray = subImageList.getJSONArray("SubImageInfoObject");
        List<Dict> subImageInfoObjectList = JSONUtil.toList(subImageInfoObjectArray, Dict.class);
        String smallType = String.valueOf(subImageInfoObjectList.get(INDEX_0).get("Type"));
        String bigType = String.valueOf(subImageInfoObjectList.get(INDEX_1).get("Type"));

        // 3、给需要生产的实体类对象赋值
        Q_VEHICLE_INPUT qVehicleInput = new Q_VEHICLE_INPUT();
        qVehicleInput.setTOLLGATE_ID("null");
        qVehicleInput.setTollgate_id("null");
        qVehicleInput.setPic_abbreviate(properties.getUrlPre() + "/get/image?type=vehicle&id=" + motorVehicleID + "&channelCode=" + channelCode + "&imageType=" + bigType);
        qVehicleInput.setPIC_ABBREVIATE(properties.getUrlPre() + "/get/image?type=vehicle&id=" + motorVehicleID + "&channelCode=" + channelCode + "&imageType=" + bigType); // 全景图URL
        qVehicleInput.setINFO_ID(motorVehicleID);
        qVehicleInput.setInfo_id(motorVehicleID);
        qVehicleInput.setPIC_PLATE(properties.getUrlPre() + "/get/image?type=vehicle&id=" + motorVehicleID + "&channelCode=" + channelCode + "&imageType=" + smallType); // 车辆小图URL
        qVehicleInput.setPic_plate(properties.getUrlPre() + "/get/image?type=vehicle&id=" + motorVehicleID + "&channelCode=" + channelCode + "&imageType=" + smallType);
        qVehicleInput.setData_src("null");
        qVehicleInput.setDATA_SRC(null);
        qVehicleInput.setTollgate_name("null");
        qVehicleInput.setTOLLGATE_NAME("null");
        qVehicleInput.setDirection_id("null");
        qVehicleInput.setDIRECTION_ID(null);
        qVehicleInput.setDevice_id(channelCode);
        qVehicleInput.setDEVICE_ID(channelCode);
        qVehicleInput.setLane_no("null");
        qVehicleInput.setLANE_NO("null");

        qVehicleInput.setVehicle_color(vehicleColor);
        qVehicleInput.setHPYS(plateColor.equals("null") ? null : Integer.valueOf(plateColor));
        qVehicleInput.setVehicle_speed("null");
        qVehicleInput.setCOPILOT_CALL("null");
        qVehicleInput.setCARD("null");
        qVehicleInput.setTHIRD_DATA("null");
        qVehicleInput.setDriving_state("null");
        qVehicleInput.setNO_PLATE_CAR(hasPlate);
        qVehicleInput.setBRAND_RELIABILITY("null");
        qVehicleInput.setAERIAL("null");
        qVehicleInput.setHPZL(plateClass);
        qVehicleInput.setPILOT_SUNVISOR("null");
        qVehicleInput.setIN_OUT_TYPE("null");
        qVehicleInput.setPIC_VEHICLE(properties.getUrlPre() + "/get/image?type=vehicle&id=" + motorVehicleID + "&channelCode=" + channelCode + "&imageType=" + smallType); // 车辆小图
        qVehicleInput.setWITH_SUNROOF("null");
        qVehicleInput.setROOF_RACK("null");
        qVehicleInput.setHPHM(plateNo);
        qVehicleInput.setREGION("null");
        qVehicleInput.setORIGINAL_TOLLGATE_ID("null");
        qVehicleInput.setVEHICLE_LENGTH("null");
        qVehicleInput.setPENDANTS("null");
        qVehicleInput.setNODE_CJSJ4("null");
        qVehicleInput.setORG_CODE("null");
        qVehicleInput.setPRE_CAR_LOGO(vehicleBrand);
        qVehicleInput.setCAR_RECT("null");
        qVehicleInput.setLane_type("null");
        qVehicleInput.setRECEIVE_TIMESTAMP("null");
        qVehicleInput.setECSB("null");
        qVehicleInput.setPRE_HPZL("null");
        qVehicleInput.setManufacturer("null");
        qVehicleInput.setSend_flag("null");
        qVehicleInput.setORIGINAL_DEVICE_ID("null");
        qVehicleInput.setBACK_VEHICLE("null");
        qVehicleInput.setCAR_YEAR(vehicleStyles);
        qVehicleInput.setPlate_info("null");
        qVehicleInput.setOCCUPANT_CO_DRIVER("null");
        qVehicleInput.setVEHICLE_APPEARANCE("null");
        qVehicleInput.setPlate_color("null");
        qVehicleInput.setPILOT_SEATBELT("null");
        qVehicleInput.setPass_time("null");
        qVehicleInput.setPRE_HPYS(null);
        qVehicleInput.setTISSUE("null");
        qVehicleInput.setUSING_PROPERTIES_CODE("null");
        qVehicleInput.setVehicle_type("null");
        qVehicleInput.setSend_analysis_req_time("null");
        qVehicleInput.setINPUT_DATE("null");
        qVehicleInput.setPRE_HPHM("null");
        qVehicleInput.setJGSK(null);
        qVehicleInput.setDAMAGED_PARTS("null");
        qVehicleInput.setTHIRD_SRC("null");
        qVehicleInput.setCOMPOSITE_URL("null");
        qVehicleInput.setPRE_CAR_YEAR("null");
        qVehicleInput.setSPEED(null);
        qVehicleInput.setCSYS(null);
        qVehicleInput.setIS_ALTERED(null);
        qVehicleInput.setPLATE_RECT("null");
        qVehicleInput.setHEAVY_TRUCK_COVER("null");
        qVehicleInput.setNAME_OF_PASSED_ROAD("null");
        qVehicleInput.setCOPILOT_SUNVISOR("null");
        qVehicleInput.setPILOT_CALL("null");
        qVehicleInput.setCLLX(vehicleClass);
        qVehicleInput.setPLATE_CHAR_RELIABILITY("null");
        qVehicleInput.setPlate_type("null");
        qVehicleInput.setVEHICLE_WIDTH("null");
        qVehicleInput.setPLATE_RELIABILITY("null");
        qVehicleInput.setALGORITHM_ID("null");
        qVehicleInput.setLATITUDE("null");
        qVehicleInput.setAccess_time("null");
        qVehicleInput.setTHUMBNAIL_URL("null");
        qVehicleInput.setPass_id("null");
        qVehicleInput.setPRE_CLLX(vehicleClass);
        qVehicleInput.setLONGITUDE("null");
        qVehicleInput.setPLATE_UNIFORM("null");
        qVehicleInput.setTHIRD_ID("null");
        qVehicleInput.setVEHICLE_HEIGHT("null");
        qVehicleInput.setSPARE_TIRE("null");
        qVehicleInput.setGRAFFITI("null");
        qVehicleInput.setCOPILOT_SEATBELT("null");
        qVehicleInput.setHPGS("null");
        qVehicleInput.setIS_RENEWAL("null");
        qVehicleInput.setCAR_SERIES("null");
        qVehicleInput.setVEHICLE_MASK("null");
        qVehicleInput.setTrail_plate_info("null");
        qVehicleInput.setCJSJ("null");
        qVehicleInput.setVEHICLE_QUALITY("null");
        qVehicleInput.setVEHICLE_SUNVISOR("null");
        qVehicleInput.setYELLOW_LABEL_CAR("null");
        qVehicleInput.setORGAN_NAME("null");
        qVehicleInput.setILLEGAL("null");
        qVehicleInput.setNeedDelete("null");
        qVehicleInput.setPRE_CSYS(null);
        qVehicleInput.setACCESSORY("null");
        qVehicleInput.setCAR_LOGO(vehicleBrand);
        qVehicleInput.setIS_COVERED("null");
        qVehicleInput.setVIID_OBJECT_ID("null");

        return qVehicleInput;

    }

    /**
     * 得到整数值
     * 根据属性名从字典中获取整数值，处理 "null" 字符串
     *
     * @param data 数据
     * @param key  关键
     * @return {@code Integer}
     */
    private Integer getIntegerValue(Dict data, String key) {
        String value = String.valueOf(data.get(key));
        return "null".equals(value) ? null : Integer.valueOf(value);
    }

    /**
     * 创建位置坐标DTO
     *
     * @param data1 data1 都是第一个数组元素 dict
     * @param data2 data2
     * @return {@code RectDTO}
     */
    private RectDTO createRect(Dict data1, Dict data2) {
        Integer y = getIntegerValue(data1, "LeftTopY");
        Integer x = getIntegerValue(data1, "LeftTopX");
        Integer h = getIntegerValue(data2, "Height");
        Integer w = getIntegerValue(data2, "Width");
        return new RectDTO(y, x, h, w);
    }

}
```

##### KafkaConsumer

添加异常处理，并打印消息接收数和转发数，字段处理抽取方法

```java
@Slf4j
@Component
public class KafkaConsumer {

  @Resource
  private KafkaProvider kafkaProvider;
  @Resource
  private MessageProcessor messageProcessor;
  @Resource
  private TGa1400DataStatsService tGa1400DataStatsService;

  private final AtomicLong receivedFaceMessages; // 接收数
  private final AtomicLong forwardedFaceMessages; // 转发数
  private final AtomicLong receivedHumanMessages;
  private final AtomicLong forwardedHumanMessages;
  private final AtomicLong receivedVehicleMessages;
  private final AtomicLong forwardedVehicleMessages;

  public KafkaConsumer() {
    int initialValue = 0;
    receivedFaceMessages = new AtomicLong(initialValue);
    forwardedFaceMessages = new AtomicLong(initialValue);
    receivedHumanMessages = new AtomicLong(initialValue);
    forwardedHumanMessages = new AtomicLong(initialValue);
    receivedVehicleMessages = new AtomicLong(initialValue);
    forwardedVehicleMessages = new AtomicLong(initialValue);
  }

  @Bean
  public Consumer<String> face_input() {
    return message -> {

      try {
        // 记录任务开始时间
        long startTime = System.currentTimeMillis();
        // 1、将消息中的 \t 转义
        String formatMessage = formatMessage(message);

        // 2、获取消息中对应 key 中的值
        JSONArray faceObjectArray = getMessageArray(formatMessage, FACE_KEY_2, FACE_KEY_3);

        // 3、处理消息，返回需要输出的DTO
        FaceDTO faceDTO = messageProcessor.processFace(faceObjectArray);

        // 4、转换成需要的字符串格式
        String faceStr = convertToJsonString(faceDTO);

        // 更新接收计数器
        receivedFaceMessages.incrementAndGet();

        // 6、判断字符串不为空，则发送消息
        if (faceStr != null) {
          // System.out.println(faceStr); // 测试用
          log.info("人脸ID：{} --- 设备编号ID：{}", faceDTO.getINFO_ID(), faceDTO.getDEVICE_ID());
          log.info("全景图URL：{}", faceDTO.getPIC());
          log.info("人脸图URL：{}", faceDTO.getOBJ_PIC());
          kafkaProvider.sendFace(faceStr);
          // 计算任务执行时间
          long endTime = System.currentTimeMillis();
          long elapsedTime = endTime - startTime;
          // 更新转发计数器
          forwardedFaceMessages.incrementAndGet();
          log.info("接收到的人脸消息数：{} --- 转发成功的消息数：{} --- 任务耗时：{}ms",
                  getReceivedFaceMessages(), getForwardedFaceMessages(), elapsedTime);
          // 统计消息记录数到数据库
          saveMessageCount(faceDTO.getDEVICE_ID(), getReceivedFaceMessages(), getForwardedFaceMessages(), FACE);
        }
      } catch (Exception e) {
        log.error("-------------------发送 face 消息失败：{} -------------------", e.getMessage(), e);
        // log.error("------------------------Error sending face message------------------------");
        // throw new RuntimeException(e); // 感觉这里遇到异常，不终止程序比较好
      }

    };
  }

  @Bean
  public Consumer<String> human_input() {
    return message -> {

      try {
        // 记录任务开始时间
        long startTime = System.currentTimeMillis();
        // 1、将消息中的 \t 转义
        String formatMessage = formatMessage(message);

        // 2、获取消息中对应 key 中的值
        JSONArray personObjectArray = getMessageArray(formatMessage, PERSON_KEY_2, PERSON_KEY_3);

        // 3、处理消息，返回需要输出的DTO
        HumanDTO humanDTO = messageProcessor.processPerson(personObjectArray);

        // 4、转换成需要的字符串格式
        String personStr = convertToJsonString(humanDTO);

        // 更新接收计数器
        receivedHumanMessages.incrementAndGet();

        // 6、判断字符串不为空，则发送消息
        if (personStr != null) {
          // System.out.println(personStr); // 测试用
          log.info("人体ID：{} --- 设备编号ID：{}", humanDTO.getINFO_ID(), humanDTO.getDEVICE_ID());
          log.info("全景图URL：{}", humanDTO.getPIC());
          log.info("人体图URL：{}", humanDTO.getOBJ_PIC());
          kafkaProvider.sendHuman(personStr);
          // 计算任务执行时间
          long endTime = System.currentTimeMillis();
          long elapsedTime = endTime - startTime;
          // 更新转发计数器
          forwardedHumanMessages.incrementAndGet();
          log.info("接收到的人体消息数：{} --- 转发成功的消息数：{} --- 任务耗时：{}ms",
                  getReceivedHumanMessages(), getForwardedHumanMessages(), elapsedTime);
          // 统计消息记录数到数据库
          saveMessageCount(humanDTO.getDEVICE_ID(), getReceivedFaceMessages(), getForwardedFaceMessages(), PERSON);
        }
      } catch (Exception e) {
        log.error("-------------------发送 person 消息失败：{} -------------------", e.getMessage(), e);
      }

    };
  }

  @Bean
  public Consumer<String> vehicle_input() {
    return message -> {

      try {
        // 记录任务开始时间
        long startTime = System.currentTimeMillis();
        // 1、将消息中的 \t 转义
        String formatMessage = formatMessage(message);

        // 2、获取消息中对应 key 中的值
        JSONArray vehicleObjectArray = getMessageArray(formatMessage, MOTORVEHICLE_KEY_2, MOTORVEHICLE_KEY_3);

        // 3、处理消息，返回需要输出的DTO
        Q_VEHICLE_INPUT qVehicleInput = messageProcessor.processVehicle(vehicleObjectArray);

        // 4、将DTO对象转换成JSON对象 -- 不跳过空值，输出的字段顺序和Bean的字段顺序保持一致
        String vehicleStr = convertToJsonString(qVehicleInput);

        // 更新接收计数器
        receivedVehicleMessages.incrementAndGet();

        // 6、判断字符串不为空，则发送消息
        if (vehicleStr != null) {
          // System.out.println(vehicleStr); // 测试用
          log.info("车辆ID：{} --- 设备编号ID：{}", qVehicleInput.getINFO_ID(), qVehicleInput.getDEVICE_ID());
          log.info("全景图URL：{}", qVehicleInput.getPIC_ABBREVIATE());
          log.info("车辆小图URL：{}", qVehicleInput.getPIC_PLATE());
          kafkaProvider.sendVehicle(vehicleStr);
          // 计算任务执行时间
          long endTime = System.currentTimeMillis();
          long elapsedTime = endTime - startTime;
          // 更新转发计数器
          forwardedVehicleMessages.incrementAndGet();
          log.info("接收到的车辆消息数：{} --- 转发成功的消息数：{} --- 任务耗时：{}ms",
                  getReceivedVehicleMessages(), getForwardedVehicleMessages(), elapsedTime);
          // 统计消息记录数到数据库
          saveMessageCount(qVehicleInput.getDEVICE_ID(), getReceivedFaceMessages(), getForwardedFaceMessages(), MOTORVEHICLE);
        }
      } catch (Exception e) {
        log.error("-------------------发送 vehicle 消息失败：{} -------------------", e.getMessage(), e);
      }

    };
  }

  /**
   * 将消息中的 \t 转换成 四个空格
   *
   * @param message 消息
   * @return {@code String}
   */
  private String formatMessage(String message) {
    return message.replace("\t", "    "); // 4 spaces
  }

  /**
   * 获取消息数组 -- data.xxListObject.xxObject
   *
   * @param formatMessage 格式消息
   * @param key2          key2
   * @param key3          key3
   * @return {@code JSONArray}
   */
  private JSONArray getMessageArray(String formatMessage, String key2, String key3) {

    JSONObject jsonObject = JSONUtil.parseObj(formatMessage);

    JSONObject dataJson = jsonObject.getJSONObject(cn.tisson.etouch.common.constant.MessageKeys.DATA); // data
    JSONObject ListObject = dataJson.getJSONObject(key2); // xxListObject

    return ListObject.getJSONArray(key3); // xxObject
  }

  /**
   * DTO转换为json字符串
   *
   * @param DTO dto
   * @return {@code String}
   */
  private String convertToJsonString(Object DTO) {

    // 将DTO对象转换成JSON对象 -- 不跳过空值，输出的字段顺序和Bean的字段顺序保持一致
    JSONObject jsonObject = JSONUtil.parseObj(DTO, false, true);
    // 转成字符串类型并美化输出
    return JSONUtil.toJsonPrettyStr(jsonObject);

  }

  /**
   * 保存消息记录数到数据库
   * 
   * @param deviceID
   * @param receivedMessages
   * @param forwardedMessage
   * @param identify
   */
  private void saveMessageCount(String deviceID, long receivedMessages, long forwardedMessage, String identify) {

    TGa1400DataStats tGa1400DataStats = new TGa1400DataStats();
    tGa1400DataStats.setChannelCode(deviceID);
    if (identify.equals("Face")) {
      tGa1400DataStats.setFaceReceivedCount(receivedMessages);
      tGa1400DataStats.setFaceForwardedCount(forwardedMessage);
    }
    if (identify.equals("Person")) {
      tGa1400DataStats.setPersonReceivedCount(receivedMessages);
      tGa1400DataStats.setPersonForwardedCount(forwardedMessage);
    }
    if (identify.equals("MotorVehicle")) {
      tGa1400DataStats.setVehicleReceivedCount(receivedMessages);
      tGa1400DataStats.setVehicleForwardedCount(forwardedMessage);
    }
    tGa1400DataStatsService.saveCountMessageStats(tGa1400DataStats);

  }
  
  public long getReceivedFaceMessages() {
    return receivedFaceMessages.get();
  }

  public long getForwardedFaceMessages() {
    return forwardedFaceMessages.get();
  }

  public long getReceivedHumanMessages() {
    return receivedHumanMessages.get();
  }

  public long getForwardedHumanMessages() {
    return forwardedHumanMessages.get();
  }

  public long getReceivedVehicleMessages() {
    return receivedVehicleMessages.get();
  }

  public long getForwardedVehicleMessages() {
    return forwardedVehicleMessages.get();
  }
  
}
```



## Git 相关操作

> 写代码前，务必先**拉取**项目

### 代码仓库提交

### 流程

先写好 .gitignore 文件 -> 创建本地仓库 -> 添加目录文件 -> 提交 -> 拉取 -> 推送

**先拉取，再提交**

拉取时遇到文件冲突

eg: 

远程仓库中有 README 文件，本地项目也有 README 文件，拉取时会起冲突。

解决方法：拉取时选择 `-rebase` 参数

## 排查冗余数据

1、排查表中的 `t_agile_user_org` 表中不存在的用户或组织的关联记录

```sql
# 排查用户-组织关联表
SELECT * FROM t_agile_user_org
WHERE user_id NOT IN (SELECT id FROM t_agile_user)
   OR org_id NOT IN (SELECT id FROM t_agile_org);
```

2、排查未使用的角色：查询 `t_agile_role` 表中未与任何用户绑定的角色。

```sql
# 排查用户-角色关联表
SELECT * FROM t_agile_role
WHERE id NOT IN (SELECT role_id FROM t_agile_user_role);
```

3、排查每个用户除了自身是否绑定了其他角色 -- 绑定了多个角色的用户信息

```sql
SELECT user_id, COUNT(*) as role_count FROM t_agile_user_role
GROUP BY user_id
HAVING role_count > 1;
```

携带 账号 和 手机号 联表查询

```sql
# 查询绑定了多个角色的用户信息 -- 记录数不符合预期，错误
SELECT ur.user_id, u.account, u.phone, COUNT(ur.user_id) as role_count  
FROM t_agile_user_role ur, t_agile_user u
GROUP BY ur.user_id, u.account, u.phone
HAVING role_count > 1;

# 正确写法
SELECT u.account, u.phone, COUNT(ur.user_id) as role_count  
FROM t_agile_user_role ur
INNER JOIN t_agile_user u ON ur.user_id = u.id
GROUP BY u.account, u.phone
HAVING role_count > 1;

# 另一种写法 -- 注意 in 在实际开发中性能比较低（记录数大的时候）
SELECT id, account, phone 
FROM t_agile_user
WHERE id in (SELECT user_id FROM t_agile_user_role
			GROUP BY user_id
			HAVING COUNT(*) > 1);			

# 优化后的写法
SELECT u.id, u.account, u.phone 
FROM t_agile_user u
INNER JOIN (
    SELECT user_id
    FROM t_agile_user_role
    GROUP BY user_id
    HAVING COUNT(*) > 1
) r ON u.id = r.user_id;
```

参考文章：[ChatGPT大模型告诉了我SQL中替换In查询的10种方法，太赞了](https://juejin.cn/post/7266452476378136628#heading-2)

*修改前后统计时间对比*

这里主要是因为统计时间不同，第一条查询语句是统计了两张表的记录，所以比较慢

```sql
SELECT ur.user_id, u.account, u.phone, COUNT(ur.user_id) as role_count  
FROM t_agile_user_role ur, t_agile_user u
GROUP BY ur.user_id, u.account, u.phone
HAVING role_count > 1
> OK
> 查询时间: 5.109s

SELECT u.account, u.phone, COUNT(ur.user_id) as role_count  
FROM t_agile_user_role ur
INNER JOIN t_agile_user u ON ur.user_id = u.id
GROUP BY u.account, u.phone
HAVING role_count > 1
> OK
> 查询时间: 0.013s
```

## 数据脱敏

`BeanUtil.copy()` 工具方法的使用

它的目的是将两个对象之间的属性值进行复制。这是一种更通用的方式，适用于需要在不同类之间复制属性的情况，特别是当类的属性较多时，可以减少重复的手动属性赋值代码。

```java
        // 数据脱敏 -- 写法 1
        DataStatsDTO dataStatsDTO = BeanUtil.copy(dataStats, DataStatsDTO.class);

        // 写法 2
        // DataStatsDTO dataStatsDTO = new DataStatsDTO();
        // dataStatsDTO.setChannelCode(deviceId);
        // dataStatsDTO.setFaceReceivedCount(dataStats.getFaceReceivedCount());
        // dataStatsDTO.setFaceForwardedCount(dataStats.getFaceForwardedCount());
        // dataStatsDTO.setPersonReceivedCount(dataStats.getPersonReceivedCount());
        // dataStatsDTO.setPersonForwardedCount(dataStats.getPersonForwardedCount());
        // dataStatsDTO.setVehicleReceivedCount(dataStats.getVehicleReceivedCount());
        // dataStatsDTO.setVehicleForwardedCount(dataStats.getVehicleForwardedCount());
```

2、`BeanUtils.copyProperties` 与 `BeanUtil.copy` 的对比

```java
// Java 8 的写法
		List<MaintainerAmusementFacilitiesListVO> voList = list.stream().map(entity -> {
			MaintainerAmusementFacilitiesListVO vo = new MaintainerAmusementFacilitiesListVO();
			try {
				BeanUtils.copyProperties(vo, entity); // (目标，来源)
			} catch (IllegalAccessException | InvocationTargetException e) {
				throw new RuntimeException(e);
			}
			return vo;
		}).collect(Collectors.toList());
		
// 工具类写法
		List<MaintainerAmusementFacilitiesListVO> voList = BeanUtil.copy(list, MaintainerAmusementFacilitiesListVO.class);
```



## 遇到的问题

### bean 冲突

*问题*：

本地 Demo 项目使用 `@Resource` 注解注入 `MyMessageChannel` 自定义消息通道接口的时候，没有问题，但融入大项目的时候就会报错（找不到这个 bean），换成使用 Spring 自带的 `@Autowired` 注解就会没问题。

*猜测原因*：

可能是因为是两个注解默认注入 bean 的方式不一样引起的

*参考知识点*：

- [面渣逆袭（有哪些自动装配的方式）](https://tobebetterjavaer.com/sidebar/sanfene/spring.html#_12-spring-有哪些自动装配的方式)
- [autowired-和-resource-的区别是什么](https://cmty256.github.io/pages/9c0b18/#autowired-和-resource-的区别是什么)

### 占位符问题

*错误的写法*

下面这种写法会导致第二个 `{}` 占位符接收不到记录数的数据

```java
log.info("接收到的消息数：{}",getReceivedFaceMessages() + " --- 转发成功的消息数：{}", getForwardedFaceMessages());
```

*正解*

将占位符 `{}` 分别替换为每个计数器的值，类似于以下方式：

确保在日志输出中提供正确的参数，以便正确显示接收数和转发数。

```java
log.info("接收到的消息数：{} --- 转发成功的消息数：{}", getReceivedFaceMessages(), getForwardedFaceMessages());
```

### Navicat 如何设置字段唯一约束

参考文章：[navicat for mysql 如何设置字段唯一](https://blog.csdn.net/ly_solo/article/details/79856139)

### 插入数据时覆盖已经存在的记录

如果你想在插入数据时覆盖已经存在的记录，通常有两种常见的方式：

1. 使用数据库的 "INSERT ON DUPLICATE KEY UPDATE"（MySQL）或 "MERGE INTO"（Oracle）等语法：

   这些数据库支持的语法可以在插入记录时，如果发现唯一键冲突，就执行更新操作而不是抛出异常。这样，如果已经存在记录，就会更新现有记录，而不是创建新记录。

   例如，在 MySQL 中，可以使用以下语法：

   ```sql
   INSERT INTO your_table (unique_column, other_column)
   VALUES (value1, value2)
   ON DUPLICATE KEY UPDATE other_column = value2;
   ```

   这将尝试插入一条新记录，如果唯一键冲突，就会更新 `other_column` 的值。

2. 使用 MyBatis Plus 提供的 `saveOrUpdate` 方法：

   MyBatis Plus 提供了 `saveOrUpdate` 方法，可以在插入数据时检查是否存在相同唯一值的记录，如果存在则执行更新操作，如果不存在则执行插入操作。

   你可以像这样使用 `saveOrUpdate` 方法：

   ```java
   faceStatsService.saveOrUpdate(faceStats);
   ```

   这将根据数据库中是否存在具有相同唯一值的记录来决定是插入新记录还是更新现有记录。

要注意的是，具体的实现方式可能因你所使用的数据库和 MyBatis Plus 的版本而异。如果你使用的是 MySQL 等支持 "INSERT ON DUPLICATE KEY UPDATE" 语法的数据库，你可以选择使用该语法。如果你希望保持代码的数据库无关性，可以使用 `saveOrUpdate` 方法。

*添加事务*

这个功能需要添加成事务，因为保存或更新数据是一个原子操作，如果在这个过程中出现异常，那么之前的数据可能会丢失。为了保证数据的完整性和一致性，建议将这个功能添加成事务。

**需要提取设置好主键，在实体类中的唯一字段上添加 `TableId` 注解**

官方文档：[CRUD 接口 - saveorupdate](https://baomidou.com/pages/49cc81/#saveorupdate)



数据库建表为什么必须包含某些字段？怎么设置的？



### 消费者组 ID 问题

*为什么要使用消费者组 ID，有什么好处？不使用有什么不好？*

消费者组 ID 是 Apache Kafka 中用于管理消费者的重要概念，它具有以下好处：

1. **并行处理**：使用消费者组 ID 可以实现多个消费者并行处理同一个主题的消息。每个消费者都可以处理主题的不同分区，从而提高消息处理的并发性能。
2. **负载均衡**：Kafka 可以确保同一个消费者组中的每个消费者都获得主题中的一部分分区，从而实现负载均衡。这意味着消息处理在消费者组内均匀分布，不会造成某个消费者过载，而其他消费者处于空闲状态。
3. **容错性**：如果一个消费者失败或离线，Kafka 会将它的分区重新分配给其他在线的消费者，确保消息不会丢失，同时保持负载均衡。这有助于实现高可用性。
4. **水平扩展**：通过增加消费者，可以轻松地扩展消息处理能力。只需创建更多的消费者并加入同一个消费者组，Kafka 就会自动分配分区，从而实现水平扩展。

如果不使用消费者组 ID，会导致以下问题：

1. **消息重复处理**：每个消费者都会独立地处理同一主题的所有消息，可能导致消息的重复处理。
2. **无法实现负载均衡**：没有消费者组 ID，无法确保不同消费者之间均匀处理消息，因此某些消费者可能会过载，而其他消费者可能处于空闲状态。
3. **无法实现高可用性**：没有消费者组 ID，无法轻松实现消费者的容错和高可用性，一旦某个消费者失败，消息处理可能会受到影响。

总之，消费者组 ID 是 Kafka 中实现并行、负载均衡、高可用性和水平扩展的关键机制，因此在使用 Kafka 时通常建议使用消费者组 ID。

### 执行插入操作但只有可读权限

*报错*

![image-20230912101103908](https://cdn.staticaly.com/gh/cmty256/imgs-blog@main/project/image-20230912101103908.1pf80s7ssbfk.webp)

```bash
### Error updating database.  Cause: java.sql.SQLException: Connection is read-only. Queries leading to data modification are not allowed
### The error may exist in cn/tisson/etouch/mapper/TGa1400DataStatsMapper.java (best guess)
### The error may involve cn.tisson.etouch.mapper.TGa1400DataStatsMapper.insert-Inline
### The error occurred while setting parameters
### SQL: INSERT INTO t_ga1400_data_stats (channel_code, face_received_count) VALUES (?, ?)
### Cause: java.sql.SQLException: Connection is read-only. Queries leading to data modification are not allowed; Connection is read-only. Queries leading to data modification are not allowed; nested exception is java.sql.SQLException: Connection is read-only. Queries leading to data modification are not allowed -------------------
```

连接只读。不允许修改数据的查询。

*原因*：

接口方法命名不规范，在全局事务管理器中被规定为了只读。

部分 `全局事务管理器(TransactionManagerConfig)` 代码如下：

```java
Map<String, TransactionAttribute> methodMap = new HashMap<>();

		//可以提及事务或回滚事务的方法
		methodMap.put("add*", requiredTx);
		methodMap.put("save*", requiredTx);
		methodMap.put("update*", requiredTx);
		methodMap.put("modify*", requiredTx);
		methodMap.put("edit*", requiredTx);
		methodMap.put("insert*", requiredTx);
		methodMap.put("delete*", requiredTx);
		methodMap.put("remove*", requiredTx);
		methodMap.put("repair*", requiredTx);
		methodMap.put("bind*", requiredTx);
		methodMap.put("binding*", requiredTx);
		methodMap.put("batch*", requiredTx);
		methodMap.put("clear*", requiredTx);
		methodMap.put("append*", requiredTx);
		methodMap.put("create*", requiredTx);
		methodMap.put("import*", requiredTx);
		methodMap.put("change*", requiredTx);
		methodMap.put("mod*", requiredTx);
		methodMap.put("equ*", requiredTx);
		//其他方法无事务，只读
		methodMap.put("*", readOnlyTx);
		source.setNameMap(methodMap);
```

*解决方法*：

将接口命名修改成 `saveXXX` 即可

例如：

```java
// 修改前
void countMessageStats(TGa1400DataStats tGa1400DataStats);
// 修改后
void saveCountMessageStats(TGa1400DataStats tGa1400DataStats);
```

*为什么要编写全局事务管理器？*

编写全局事务管理器的主要目的是确保在应用程序中的不同组件之间或不同服务之间的交互操作时，可以保持数据的一致性和完整性。全局事务管理器的存在有以下几个主要原因和优势：

1. **维护数据一致性：** 当一个操作涉及多个数据源或多个步骤时，如果其中一个步骤失败，可能会导致数据不一致。全局事务管理器可以确保要么所有步骤都成功完成，要么所有步骤都会被回滚，以维护数据的一致性。
2. **简化事务管理：** 使用全局事务管理器，开发人员可以将事务逻辑从业务逻辑中分离出来，这样业务代码就不需要直接管理事务，使代码更清晰和可维护。
3. **处理跨服务事务：** 在微服务架构中，一个业务操作可能涉及多个微服务之间的交互。全局事务管理器可以协调不同微服务上的事务，确保它们在整个操作中保持一致。
4. **提高可靠性：** 通过使用全局事务管理器，可以更容易地处理故障情况。如果某个步骤失败，事务管理器可以协调回滚其他步骤，从而确保系统状态的稳定。
5. **支持分布式事务：** 在分布式系统中，全局事务管理器可以确保跨多个节点的事务在所有节点上以原子方式执行。

综上所述，全局事务管理器是复杂应用程序和分布式系统中确保数据完整性和一致性的关键组件。它简化了事务管理，提高了系统的可靠性，并支持跨多个服务或节点的事务处理。这就是为什么需要编写全局事务管理器的原因。

*为什么要编写统一事务管理器？*

编写统一事务管理器是为了解决分布式系统中的分布式事务管理问题。在分布式系统中，事务可能涉及多个不同的服务或资源，这些服务和资源可能分布在不同的机器或节点上，因此需要一种机制来确保事务的一致性和隔离性。

以下是为什么要编写统一事务管理器的一些原因：

1. **跨服务事务**：在分布式系统中，一个事务可能需要跨越多个不同的服务，每个服务都可能有自己的数据库或资源。统一事务管理器可以协调这些服务之间的事务操作，确保它们在一个事务中要么全部成功，要么全部失败。
2. **事务隔离性**：事务隔离性是 ACID（原子性、一致性、隔离性、持久性）属性之一，它确保在多个并发事务执行时，一个事务的操作不会受到其他事务的影响。统一事务管理器可以确保在分布式环境下的事务隔离性。
3. **分布式数据库事务**：如果系统中使用了多个分布式数据库，统一事务管理器可以管理这些数据库之间的事务，确保它们协同工作，以满足事务的一致性要求。
4. **事务的补偿机制**：在分布式环境中，由于网络故障或其他异常情况，事务可能无法完全成功。统一事务管理器可以实现事务的补偿机制，以处理这些部分失败的事务。
5. **可靠消息传递**：一些分布式事务场景可能涉及消息队列，而消息队列的可靠性传递也是一个事务问题。统一事务管理器可以与消息队列集成，确保事务消息的可靠传递和处理。
6. **容错和回滚**：分布式系统中可能会出现各种故障，包括节点故障、网络故障等。统一事务管理器可以实现容错机制，以确保在发生故障时能够正确回滚事务。

总之，统一事务管理器是为了确保分布式系统中的事务操作具有一致性、隔离性和可靠性，以应对分布式环境下的复杂性和挑战。它可以协调和管理跨越多个服务和资源的事务，提供一致的事务处理机制。



## 平台模型

### rbac 模型

RBAC（Role-Based Access Control）模型是一种访问控制模型，用于管理和控制用户对系统资源的访问权限。在 RBAC 模型中，权限和角色是核心概念，用户被分配到角色，而角色与权限相关联。以下是 RBAC 模型的核心组成部分：

1. **用户（User）：** 用户是系统的最终使用者，他们需要访问系统的资源。每个用户可以被分配一个或多个角色。
2. **角色（Role）：** 角色是一组相关权限的集合。角色定义了用户可以执行的操作和访问的资源。例如，一个系统可以有 "管理员"、"普通用户"、"访客" 等角色。
3. **权限（Permission）：** 权限是系统资源上的操作或访问规则。它们定义了用户在系统中的具体行为，例如读取、写入、删除等操作。权限通常与角色相关联，一个角色可以包含多个权限。
4. **分配（Assignment）：** 分配是将用户与角色关联起来的过程。一个用户可以被分配到一个或多个角色，从而获得这些角色的权限。
5. **访问控制矩阵（Access Control Matrix）：** 这是一个表示用户、角色、权限之间关系的矩阵。它清楚地定义了谁可以做什么。

RBAC 模型的主要优点包括：

- **简化权限管理：** RBAC将权限分配和管理集中在角色级别，使权限管理更加简单和可维护。
- **增强安全性：** 通过将用户分配给角色，RBAC可以确保每个用户只有必要的权限，从而降低了潜在的风险。
- **易于扩展：** 当需要添加新的权限或角色时，RBAC模型使扩展变得相对容易，不会影响到整个系统。
- **提高可维护性：** RBAC模型使系统更易于维护，因为角色和权限的变化可以在中央位置进行管理。

RBAC 模型在许多应用程序和系统中得到广泛使用，特别是在需要强大的访问控制和安全性的环境中，例如企业应用程序、数据库管理系统、操作系统等。它有助于确保系统的安全性和合规性，同时提高了管理和维护的效率。



