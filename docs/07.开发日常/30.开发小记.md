---
title: 开发小记
date: 2023-08-31 09:08:03
permalink: /pages/3cd6be/
---
# 开发小记

## 开发整体流程

任务安排 -> 环境服务配置 -> 开发 -> 本地测试 -> Maven 打包 -> 服务器测试 -> 发布上线

*具体开发情况*

1. 先写个小 demo
2. 然后逐步完善功能，以最快的方式完成任务需求
3. 融进项目模块，上传到远程仓库
4. 优化代码结构
5. 完善代码逻辑，比如让日志打印的更加清晰，方便线上排查问题

## 开发注意事项

1. 需打印日志，方便后续排查问题（控制台打印不行，因为看不到）
2. 遇到写动态 URL 的场景，要把服务 ip 和参数写活，然后字符串拼接，服务 ip 地址可以在 nacos 上配置，然后动态注入



## 使用服务器配置属性

```java
@Data
@Component("properties")
@Configuration
public class Properties {

  /**
   * 图像链接前缀
   */
  @Value("${url.pre}")
  private String urlPre;

}
```

*为什么 @Component("properties") 这里要加参数？*

`@Component` 注解用于将一个类标记为 Spring 容器中的一个组件，以便 Spring 在启动时能够扫描并将该类初始化为一个 Bean。

通常情况下，`@Component` 注解不需要参数，但在特定情况下，你可能会为该注解提供一个参数。

在上面的代码中，`@Component("properties")` 中的参数 `"properties"` 是一个用来标识该组件的名称。这个名称在 Spring 容器中是唯一的，可以用来作为 Bean 的标识符。使用该参数的目的通常是为了明确指定这个 Bean 的名称，而不是使用默认的类名首字母小写作为 Bean 的名称。

例如，如果没有指定参数 `"properties"`，Spring 容器会默认使用类名 `Properties` 首字母小写作为 Bean 的名称。但是，类名 `Properties` 可能与 Java 标准库中的 `java.util.Properties` 类名相同，可能会引起混淆。为了避免这种混淆，并明确指定 Bean 的名称，你可以使用 `@Component("properties")`。

总之，参数 `"properties"` 并不是必需的，但它可以帮助你在 Spring 容器中标识和管理这个组件，特别是当类名可能引起命名冲突时。

*使用*

只需要在指定类里面注入 bean 即可。

```java
  @Resource
  private Properties properties;
```

然后通过 get 方法获取对应值

```java
String urlPre = properties.getUrlPre();
```

## 代码优化

### KafkaProvider

> KafkaProvider 消息生产者类优化

#### 优化前

```java
@Slf4j
@Component
public class KafkaProvider {
  private final StreamBridge streamBridge;

  public KafkaProvider(StreamBridge streamBridge) {
    this.streamBridge = streamBridge;
  }

  public void sendFace(Object msg) {

    streamBridge.send("face_output", MessageBuilder.withPayload(msg).build());
    log.info("-----------------send faceMessage success-------------------");

  }

  public void sendHuman(Object msg) {

    streamBridge.send("human_output", MessageBuilder.withPayload(msg).build());
    log.info("-----------------send humanMessage success-------------------");

  }

  public void sendVehicle(Object msg) {

    streamBridge.send("vehicle_output", MessageBuilder.withPayload(msg).build());
    log.info("-----------------send vehicleMessage success-------------------");

  }

}
```

#### 优化考虑

1. **重复代码的提取**：在 `sendFace`、`sendHuman` 和 `sendVehicle` 方法中，有重复的代码。你可以将发送消息的部分提取为一个私有方法，以减少重复代码。
2. **日志统一管理**：在每个发送消息的方法中，都有一个日志输出。你可以考虑将日志的部分提取为一个私有方法，以便统一管理和修改日志输出格式。
3. **使用常量**：在消息通道的名称上，你使用了字符串字面值。考虑使用常量来定义这些名称，这样可以避免在多个地方使用相同的字符串时出现拼写错误。
4. **添加异常处理**：在发送消息时，可能会发生一些异常情况，例如连接失败。你可以考虑添加适当的异常处理，以便在发生异常时能够处理和记录异常信息。

#### 优化后

```java
@Slf4j
@Component
public class KafkaProvider {
    private final StreamBridge streamBridge;
    private static final String FACE_OUTPUT_CHANNEL = "face_output";
    private static final String HUMAN_OUTPUT_CHANNEL = "human_output";
    private static final String VEHICLE_OUTPUT_CHANNEL = "vehicle_output";

    public KafkaProvider(StreamBridge streamBridge) {
        this.streamBridge = streamBridge;
    }

    public void sendFace(Object msg) {
        sendToChannel(FACE_OUTPUT_CHANNEL, msg);
    }

    public void sendHuman(Object msg) {
        sendToChannel(HUMAN_OUTPUT_CHANNEL, msg);
    }

    public void sendVehicle(Object msg) {
        sendToChannel(VEHICLE_OUTPUT_CHANNEL, msg);
    }

    private void sendToChannel(String channelName, Object msg) {
        try {
            streamBridge.send(channelName, MessageBuilder.withPayload(msg).build());
            logInfo("send " + channelName + "Message success !!!");
        } catch (Exception e) {
            logError("Error sending message to " + channelName + " channel: " + e.getMessage());
        }
    }

    private void logInfo(String message) {
        log.info("----------------" + message + "-------------------");
    }

    private void logError(String message) {
        log.error("----------------" + message + "-------------------");
    }
}
```

### KafkaConsumer

> KafkaConsumer 消费者类优化

#### 优化前

```java
@Slf4j
@Component
public class KafkaConsumer {

  @Resource
  private KafkaProvider kafkaProvider;
  @Resource
  private Properties properties;

  @Bean
  public Consumer<String> face_input() {
    return message -> {

      // 1、将消息中的 \t 转换成 四个空格
      String formattedJson = message.replace("\t", "    "); // 4 spaces

      // 2、获取消息中对应 key 中的值
      cn.hutool.json.JSONObject jsonObject = JSONUtil.parseObj(formattedJson);

      String json = jsonObject.getStr("data");
      cn.hutool.json.JSONObject dataObject = JSONUtil.parseObj(json);
      cn.hutool.json.JSONObject faceListObject = dataObject.getJSONObject("FaceListObject");
      JSONArray faceObject = faceListObject.getJSONArray("FaceObject");

      List<Dict> list = JSONUtil.toList(faceObject, Dict.class);
      int leftTopY = (int) list.get(0).get("LeftTopY");
      int leftTopX = (int) list.get(0).get("LeftTopX");
      int ageLowerLimit = (int) list.get(0).get("AgeLowerLimit");
      String deviceID = String.valueOf(list.get(0).get("DeviceID"));
      int ageUpLimit = (int) list.get(0).get("AgeUpLimit");
      String genderType = String.valueOf(list.get(0).get("GenderType"));
      String faceID = String.valueOf(list.get(0).get("FaceID"));

      // 获取人脸图像 base64
      JSONObject subImageList = (JSONObject) list.get(0).get("SubImageList");
      JSONArray subImageInfoObjectArray = subImageList.getJSONArray("SubImageInfoObject");
      List<Dict> subImageInfoObjectList = JSONUtil.toList(subImageInfoObjectArray, Dict.class);
      String faceImageData = String.valueOf(subImageInfoObjectList.get(0).get("Data"));
      int height = (int) subImageInfoObjectList.get(0).get("Height");
      int width = (int) subImageInfoObjectList.get(0).get("Width");
      String shotTime = String.valueOf(subImageInfoObjectList.get(0).get("ShotTime"));
      String smallType = String.valueOf(subImageInfoObjectList.get(0).get("Type"));
      String bigType = String.valueOf(subImageInfoObjectList.get(1).get("Type"));

      // 3、给需要生产的 DTO 对象赋值
      FaceDTO faceDTO = new FaceDTO();
      faceDTO.setCJSJ(null); // 接入时间
      FaceRectDTO faceRectDTO = new FaceRectDTO(leftTopY, leftTopX, height, width);
      faceDTO.setFACE_RECT(faceRectDTO);
      faceDTO.setAGE_LOWER_LIMIT(ageLowerLimit);
      faceDTO.setDEVICE_ID(deviceID);
      faceDTO.setFaceImageData(faceImageData);
      faceDTO.setJGSK(Long.valueOf(shotTime)); // 抓拍时间 -- 拍摄时间
      faceDTO.setAGE(null); // 年龄段
      faceDTO.setPIC(properties.getUrlPre() + "/get/image?type=face&id=" + faceID + "&channelCode=" + deviceID + "&imageType=" + bigType); // 背景图接口地址
      faceDTO.setOBJ_PIC(properties.getUrlPre() + "/get/image?type=face&id=" + faceID + "&channelCode=" + deviceID + "&imageType=" + smallType); // 人脸图接口地址
      faceDTO.setWITH_HAT(null); // 是否戴帽子
      faceDTO.setAGE_UP_LIMIT(ageUpLimit);
      faceDTO.setGENDER_CODE(Integer.valueOf(genderType));
      faceDTO.setINFO_ID(faceID);
      faceDTO.setWITH_GLASSES(null); // 是否戴眼镜
      faceDTO.setFACE_EXPRESSION(null); // 表情
      faceDTO.setVIID_OBJECT_ID("null"); // 人脸抓拍视图库标识 -- 有字段
      faceDTO.setFACE_SCORE(null); // 人脸分数
      faceDTO.setDATA_SRC(null); // 数据来源 int
      faceDTO.setSMILE(null); // 是否微笑
      faceDTO.setRACE(null); // 种族
      faceDTO.setWITH_RESPIRATOR(null); // 是否戴口罩

      // 4、将DTO对象转换成JSON对象 -- 不跳过空值，输出的字段顺序和Bean的字段顺序保持一致
      cn.hutool.json.JSONObject faceRes = JSONUtil.parseObj(faceDTO, false, true);

      // 5、转成字符串类型并美化输出
      String faceStr = faceRes.toStringPretty();

      log.info("------------------Face--------------------------");
      // 6、判断字符串不为空，则发送消息
      if (faceStr != null) {
        log.info("人脸ID：{}", faceID);
        log.info("全景图URL：{}", faceDTO.getPIC());
        log.info("人脸图URL：{}", faceDTO.getOBJ_PIC());
        kafkaProvider.sendFace(faceStr);
      }
    };
  }

  @Bean
  public Consumer<String> human_input() {
    return message -> {

      // 1、将消息中的 \t 转换成 四个空格
      String formattedJson = message.replace("\t", "    "); // 4 spaces

      // 2、获取消息中对应 key 中的值
      cn.hutool.json.JSONObject jsonObject = JSONUtil.parseObj(formattedJson);

      String json = jsonObject.getStr("data");
      cn.hutool.json.JSONObject dataObject = JSONUtil.parseObj(json);
      cn.hutool.json.JSONObject personListObject = dataObject.getJSONObject("PersonListObject");
      JSONArray personObject = personListObject.getJSONArray("PersonObject");

      // System.out.println(personObject.toStringPretty());

      List<Dict> list = JSONUtil.toList(personObject, Dict.class);
      String coatColor = String.valueOf(list.get(0).get("CoatColor"));
      String genderCode = String.valueOf(list.get(0).get("GenderCode"));
      String personID = String.valueOf(list.get(0).get("PersonID"));
      String coatLength = String.valueOf(list.get(0).get("CoatLength"));
      int leftTopY = (int) list.get(0).get("LeftTopY");
      int leftTopX = (int) list.get(0).get("LeftTopX");
      String deviceID = String.valueOf(list.get(0).get("DeviceID"));

      // 获取人体图像 base64
      JSONObject subImageList = (JSONObject) list.get(0).get("SubImageList");
      JSONArray subImageInfoObjectArray = subImageList.getJSONArray("SubImageInfoObject");
      List<Dict> subImageInfoObjectList = JSONUtil.toList(subImageInfoObjectArray, Dict.class);
      String shotTime = String.valueOf(subImageInfoObjectList.get(0).get("ShotTime"));
      String smallType = String.valueOf(subImageInfoObjectList.get(0).get("Type"));
      String bigType = String.valueOf(subImageInfoObjectList.get(1).get("Type"));
      int height = (int) subImageInfoObjectList.get(0).get("Height");
      int width = (int) subImageInfoObjectList.get(0).get("Width");

      // 3、给需要生产的 DTO 对象赋值
      HumanDTO humanDTO = new HumanDTO();
      humanDTO.setCJSJ(null); // 采集时间
      humanDTO.setVIID_OBJECT_ID("null"); // 行人抓拍视图库标识
      humanDTO.setJGSK(Long.valueOf(shotTime)); // 经过日期时间
      humanDTO.setWITH_RESPIRATOR(null); // 是否戴口罩
      humanDTO.setAGE(null); // 年龄段String urlPre = properties.getUrlPre();
      humanDTO.setPIC(properties.getUrlPre() + "/get/image?type=person&id=" + personID + "&channelCode=" + deviceID + "&imageType=" + bigType); // 全景图接口地址
      humanDTO.setOBJ_PIC(properties.getUrlPre() + "/get/image?type=person&id=" + personID + "&channelCode=" + deviceID + "&imageType=" + smallType); // 人体图接口地址
      humanDTO.setWITH_HAT(null); // 是否带帽子
      humanDTO.setCOAT_COLOR(Integer.valueOf(coatColor)); // 上衣颜色
      humanDTO.setHAIR_LENGTH(null);
      humanDTO.setGENDER_CODE(Integer.valueOf(genderCode));
      humanDTO.setINFO_ID(null); // 转换 Long 失败
      humanDTO.setWITH_BACKPACK(null);
      humanDTO.setWITH_GLASSES(null);
      humanDTO.setCOAT_LENGTH(Integer.valueOf(coatLength));
      humanDTO.setRIDE_BIKE(null);
      humanDTO.setFACE_SCORE(null);
      humanDTO.setDATA_SRC(null);
      humanDTO.setOBJ_RECT(new ObjRectDTO(leftTopY, leftTopX, height, width));
      humanDTO.setMOTION_SPEED(null);
      humanDTO.setDEVICE_ID(deviceID);

      // 4、将DTO对象转换成JSON对象 -- 不跳过空值，输出的字段顺序和Bean的字段顺序保持一致
      JSONObject humanRes = JSONUtil.parseObj(humanDTO, false, true);

      // 5、转成字符串类型并美化输出
      String humanStr = humanRes.toStringPretty();

      log.info("------------------Human--------------------------");
      // 6、判断字符串不为空，则发送消息
      if (humanStr != null) {
        log.info("人体ID：{}", personID);
        log.info("全景图URL：{}", humanDTO.getPIC());
        log.info("人体图URL：{}", humanDTO.getOBJ_PIC());
        kafkaProvider.sendHuman(humanStr);
      }

    };
  }

  @Bean
  public Consumer<String> vehicle_input() {
    return message -> {
      // 1、将消息中的 \t 转换成 四个空格
      String formattedJson = message.replace("\t", "    "); // 4 spaces

      // 2、获取消息中对应 key 中的值
      JSONObject jsonObject = JSONUtil.parseObj(formattedJson);

      String json = jsonObject.getStr("data");
      JSONObject dataObject = JSONUtil.parseObj(json);
      JSONObject vehicleListObject = dataObject.getJSONObject("MotorVehicleListObject");
      JSONArray vehicleObject = vehicleListObject.getJSONArray("MotorVehicleObject");

      List<Dict> list = JSONUtil.toList(vehicleObject, Dict.class);
      String vehicleColor = String.valueOf(list.get(0).get("VehicleColor"));
      String plateColor = String.valueOf(list.get(0).get("PlateColor"));
      String hasPlate = String.valueOf(list.get(0).get("HasPlate"));
      String plateClass = String.valueOf(list.get(0).get("PlateClass"));
      String plateNo = String.valueOf(list.get(0).get("PlateNo"));
      String deviceID = String.valueOf(list.get(0).get("DeviceID"));
      String motorVehicleID = String.valueOf(list.get(0).get("MotorVehicleID"));
      String vehicleClass = String.valueOf(list.get(0).get("VehicleClass"));
      String vehicleBrand = String.valueOf(list.get(0).get("VehicleBrand"));
      String vehicleStyles = String.valueOf(list.get(0).get("VehicleStyles"));

      // 获取车辆图像 base64
      JSONObject subImageList = (JSONObject) list.get(0).get("SubImageList");
      JSONArray subImageInfoObjectArray = subImageList.getJSONArray("SubImageInfoObject");
      List<Dict> subImageInfoObjectList = JSONUtil.toList(subImageInfoObjectArray, Dict.class);
      String smallType = String.valueOf(subImageInfoObjectList.get(0).get("Type"));
      String bigType = String.valueOf(subImageInfoObjectList.get(1).get("Type"));

      // 3、给需要生产的实体类对象赋值
      Q_VEHICLE_INPUT qVehicleInput = new Q_VEHICLE_INPUT();
      qVehicleInput.setTOLLGATE_ID("null");
      qVehicleInput.setTollgate_id("null");
      qVehicleInput.setPic_abbreviate(properties.getUrlPre() + "/get/image?type=vehicle&id=" + motorVehicleID + "&channelCode=" + deviceID + "&imageType=" + bigType);
      qVehicleInput.setPIC_ABBREVIATE(properties.getUrlPre() + "/get/image?type=vehicle&id=" + motorVehicleID + "&channelCode=" + deviceID + "&imageType=" + bigType); // 全景图URL
      qVehicleInput.setINFO_ID("null");
      qVehicleInput.setInfo_id("null");
      qVehicleInput.setPIC_PLATE(properties.getUrlPre() + "/get/image?type=vehicle&id=" + motorVehicleID + "&channelCode=" + deviceID + "&imageType=" + smallType); // 车辆小图URL
      qVehicleInput.setPic_plate(properties.getUrlPre() + "/get/image?type=vehicle&id=" + motorVehicleID + "&channelCode=" + deviceID + "&imageType=" + smallType);
      qVehicleInput.setData_src("null");
      qVehicleInput.setDATA_SRC(null);
      qVehicleInput.setTollgate_name("null");
      qVehicleInput.setTOLLGATE_NAME("null");
      qVehicleInput.setDirection_id("null");
      qVehicleInput.setDIRECTION_ID(null);
      qVehicleInput.setDevice_id(deviceID);
      qVehicleInput.setDEVICE_ID(deviceID);
      qVehicleInput.setLane_no("null");
      qVehicleInput.setLANE_NO("null");

      qVehicleInput.setVehicle_color(vehicleColor);
      qVehicleInput.setHPYS(Integer.valueOf(plateColor));
      qVehicleInput.setVehicle_speed("null");
      qVehicleInput.setCOPILOT_CALL("null");
      qVehicleInput.setCARD("null");
      qVehicleInput.setTHIRD_DATA("null");
      qVehicleInput.setDriving_state("null");
      qVehicleInput.setNO_PLATE_CAR(hasPlate);
      qVehicleInput.setBRAND_RELIABILITY("null");
      qVehicleInput.setAERIAL("null");
      qVehicleInput.setHPZL(plateClass);
      qVehicleInput.setPILOT_SUNVISOR("null");
      qVehicleInput.setIN_OUT_TYPE("null");
      qVehicleInput.setPIC_VEHICLE(properties.getUrlPre() + "/get/image?type=vehicle&id=" + motorVehicleID + "&channelCode=" + deviceID + "&imageType=" + smallType); // 车辆小图
      qVehicleInput.setWITH_SUNROOF("null");
      qVehicleInput.setROOF_RACK("null");
      qVehicleInput.setHPHM(plateNo);
      qVehicleInput.setREGION("null");
      qVehicleInput.setORIGINAL_TOLLGATE_ID("null");
      qVehicleInput.setVEHICLE_LENGTH("null");
      qVehicleInput.setPENDANTS("null");
      qVehicleInput.setNODE_CJSJ4("null");
      qVehicleInput.setORG_CODE("null");
      qVehicleInput.setPRE_CAR_LOGO(vehicleBrand);
      qVehicleInput.setCAR_RECT("null");
      qVehicleInput.setLane_type("null");
      qVehicleInput.setRECEIVE_TIMESTAMP("null");
      qVehicleInput.setECSB("null");
      qVehicleInput.setPRE_HPZL("null");
      qVehicleInput.setManufacturer("null");
      qVehicleInput.setSend_flag("null");
      qVehicleInput.setORIGINAL_DEVICE_ID("null");
      qVehicleInput.setBACK_VEHICLE("null");
      qVehicleInput.setCAR_YEAR(vehicleStyles);
      qVehicleInput.setPlate_info("null");
      qVehicleInput.setOCCUPANT_CO_DRIVER("null");
      qVehicleInput.setVEHICLE_APPEARANCE("null");
      qVehicleInput.setPlate_color("null");
      qVehicleInput.setPILOT_SEATBELT("null");
      qVehicleInput.setPass_time("null");
      qVehicleInput.setPRE_HPYS(null);
      qVehicleInput.setTISSUE("null");
      qVehicleInput.setUSING_PROPERTIES_CODE("null");
      qVehicleInput.setVehicle_type("null");
      qVehicleInput.setSend_analysis_req_time("null");
      qVehicleInput.setINPUT_DATE("null");
      qVehicleInput.setPRE_HPHM("null");
      qVehicleInput.setJGSK(null);
      qVehicleInput.setDAMAGED_PARTS("null");
      qVehicleInput.setTHIRD_SRC("null");
      qVehicleInput.setCOMPOSITE_URL("null");
      qVehicleInput.setPRE_CAR_YEAR("null");
      qVehicleInput.setSPEED(null);
      qVehicleInput.setCSYS(null);
      qVehicleInput.setIS_ALTERED(null);
      qVehicleInput.setPLATE_RECT("null");
      qVehicleInput.setHEAVY_TRUCK_COVER("null");
      qVehicleInput.setNAME_OF_PASSED_ROAD("null");
      qVehicleInput.setCOPILOT_SUNVISOR("null");
      qVehicleInput.setPILOT_CALL("null");
      qVehicleInput.setCLLX(vehicleClass);
      qVehicleInput.setPLATE_CHAR_RELIABILITY("null");
      qVehicleInput.setPlate_type("null");
      qVehicleInput.setVEHICLE_WIDTH("null");
      qVehicleInput.setPLATE_RELIABILITY("null");
      qVehicleInput.setALGORITHM_ID("null");
      qVehicleInput.setLATITUDE("null");
      qVehicleInput.setAccess_time("null");
      qVehicleInput.setTHUMBNAIL_URL("null");
      qVehicleInput.setPass_id("null");
      qVehicleInput.setPRE_CLLX(vehicleClass);
      qVehicleInput.setLONGITUDE("null");
      qVehicleInput.setPLATE_UNIFORM("null");
      qVehicleInput.setTHIRD_ID("null");
      qVehicleInput.setVEHICLE_HEIGHT("null");
      qVehicleInput.setSPARE_TIRE("null");
      qVehicleInput.setGRAFFITI("null");
      qVehicleInput.setCOPILOT_SEATBELT("null");
      qVehicleInput.setHPGS("null");
      qVehicleInput.setIS_RENEWAL("null");
      qVehicleInput.setCAR_SERIES("null");
      qVehicleInput.setVEHICLE_MASK("null");
      qVehicleInput.setTrail_plate_info("null");
      qVehicleInput.setCJSJ("null");
      qVehicleInput.setVEHICLE_QUALITY("null");
      qVehicleInput.setVEHICLE_SUNVISOR("null");
      qVehicleInput.setYELLOW_LABEL_CAR("null");
      qVehicleInput.setORGAN_NAME("null");
      qVehicleInput.setILLEGAL("null");
      qVehicleInput.setNeedDelete("null");
      qVehicleInput.setPRE_CSYS(null);
      qVehicleInput.setACCESSORY("null");
      qVehicleInput.setCAR_LOGO(vehicleBrand);
      qVehicleInput.setIS_COVERED("null");
      qVehicleInput.setVIID_OBJECT_ID("null");


      // 4、将DTO对象转换成JSON对象 -- 不跳过空值，输出的字段顺序和Bean的字段顺序保持一致
      JSONObject VehicleRes = JSONUtil.parseObj(qVehicleInput, false, true);

      // 5、转成字符串类型并美化输出
      String vehicleStr = VehicleRes.toStringPretty();

      log.info("------------------Vehicle--------------------------");
      // 6、判断字符串不为空，则发送消息
      if (vehicleStr != null) {
        log.info("车辆ID：{}", motorVehicleID);
        log.info("全景图URL：{}", qVehicleInput.getPIC_ABBREVIATE());
        log.info("车辆小图URL：{}", qVehicleInput.getPIC_PLATE());
        kafkaProvider.sendVehicle(vehicleStr);
      }

    };
  }

}
```

#### 优化考虑

1. **字段处理抽取方法**：在你的代码中，有一些字段处理的逻辑比较复杂，例如从 JSON 数据中获取多层嵌套的字段，可以考虑将这些处理逻辑抽取为私有方法，以提高代码的可读性。
2. **魔法数值的使用**：你在代码中使用了一些魔法数值，如 `0`、`1` 等，建议将这些魔法数值提取为有意义的常量，以增加代码的可读性和维护性。
3. **错误处理**：在你的代码中，对于获取字段值可能会抛出异常，如将字符串转换为整数时。你可以添加适当的错误处理，例如捕获异常并记录错误日志，以便在出现问题时能够更好地定位和排查问题。
4. **逻辑分离**：可以考虑将部分逻辑分离成私有方法，使每个方法保持单一职责，以提高代码的可维护性。
5. **DTO对象的构建**：如果 DTO 对象的字段比较多，可以考虑使用构建者模式或者 Lombok 的 `@Builder` 注解来简化 DTO 对象的构建过程。

#### 优化后







## 代码仓库提交

### 流程

先写好 .gitignore 文件 -> 创建本地仓库 -> 添加目录文件 -> 提交 -> 拉取 -> 推送

**先拉取，再提交**

拉取时遇到文件冲突

eg: 

远程仓库中有 README 文件，本地项目也有 README 文件，拉取时会起冲突。

解决方法：拉取时选择 `-rebase` 参数

## 遇到的问题

### bean 冲突

*问题*：

本地 Demo 项目使用 `@Resource` 注解注入 `MyMessageChannel` 自定义消息通道接口的时候，没有问题，但融入大项目的时候就会报错（找不到这个 bean），换成使用 Spring 自带的 `@Autowired` 注解就会没问题。

*猜测原因*：

可能是因为是两个注解默认注入 bean 的方式不一样引起的

*参考知识点*：

- [面渣逆袭（有哪些自动装配的方式）](https://tobebetterjavaer.com/sidebar/sanfene/spring.html#_12-spring-有哪些自动装配的方式)
- [autowired-和-resource-的区别是什么](https://cmty256.github.io/pages/9c0b18/#autowired-和-resource-的区别是什么)

### 占位符问题

*错误的写法*

下面这种写法会导致第二个 `{}` 占位符接收不到记录数的数据

```java
log.info("接收到的消息数：{}",getReceivedFaceMessages() + " --- 转发成功的消息数：{}", getForwardedFaceMessages());
```

*正解*

将占位符 `{}` 分别替换为每个计数器的值，类似于以下方式：

确保在日志输出中提供正确的参数，以便正确显示接收数和转发数。

```java
log.info("接收到的消息数：{} --- 转发成功的消息数：{}", getReceivedFaceMessages(), getForwardedFaceMessages());
```

### Navicat 如何设置字段唯一约束

参考文章：[navicat for mysql 如何设置字段唯一](https://blog.csdn.net/ly_solo/article/details/79856139)

### 插入数据时覆盖已经存在的记录

如果你想在插入数据时覆盖已经存在的记录，通常有两种常见的方式：

1. 使用数据库的 "INSERT ON DUPLICATE KEY UPDATE"（MySQL）或 "MERGE INTO"（Oracle）等语法：这些数据库支持的语法可以在插入记录时，如果发现唯一键冲突，就执行更新操作而不是抛出异常。这样，如果已经存在记录，就会更新现有记录，而不是创建新记录。

   例如，在 MySQL 中，可以使用以下语法：

   ```sql
   INSERT INTO your_table (unique_column, other_column)
   VALUES (value1, value2)
   ON DUPLICATE KEY UPDATE other_column = value2;
   ```

   这将尝试插入一条新记录，如果唯一键冲突，就会更新 `other_column` 的值。

2. 使用 MyBatis Plus 提供的 `saveOrUpdate` 方法：MyBatis Plus 提供了 `saveOrUpdate` 方法，可以在插入数据时检查是否存在相同唯一值的记录，如果存在则执行更新操作，如果不存在则执行插入操作。

   你可以像这样使用 `saveOrUpdate` 方法：

   ```java
   faceStatsService.saveOrUpdate(faceStats);
   ```

   这将根据数据库中是否存在具有相同唯一值的记录来决定是插入新记录还是更新现有记录。

要注意的是，具体的实现方式可能因你所使用的数据库和 MyBatis Plus 的版本而异。如果你使用的是 MySQL 等支持 "INSERT ON DUPLICATE KEY UPDATE" 语法的数据库，你可以选择使用该语法。如果你希望保持代码的数据库无关性，可以使用 `saveOrUpdate` 方法。

*使用 MyBatis-Plus 框架如何实现这功能*

```java
public class YourEntityService {

    @Autowired
    private YourEntityMapper yourEntityMapper;

    public void saveOrUpdateEntity(YourEntity entity) {
        // 使用 MyBatis-Plus 的 saveOrUpdate 方法
        yourEntityMapper.insertOrUpdate(entity);
    }
}
```

在这个示例中，`YourEntity` 是你的实体类，`YourEntityMapper` 是对应的 Mapper 接口。

这样，当你调用 `saveOrUpdateEntity` 方法时，MyBatis-Plus 将会根据实体对象中的主键值来判断是执行插入还是更新操作。如果主键已存在于数据库中，就会执行更新操作；如果主键不存在，就会执行插入操作。

请确保你的实体类中的主键字段（或其他唯一字段）正确标识，并且 MyBatis-Plus 的版本与你的项目配置一致，以便使用 `insertOrUpdate` 方法。你也可以根据需要进行异常处理或其他操作。



## TODO

- [x] Apifox 的学习与使用
- [x] 熟悉初始项目(*agile-eax-projectexample*)的代码结构，以及各个部分的功能
- [x] 学习 Kafka 的使用，写生产并监听消息的 demo
- [x] 熟悉 Big Data Tool 插件的使用，了解 SpringCloud Stream 和 Kafka 的区别，结合使用
- [x] 造三个实体类并写数据进 Kafka
- [x] 完成 nacos 配置，编写解析图片的接口，并使用 Apifox 来测试查看
- [x] 接收 topic 消息，转换消息数据，生产消息到指定 topic
- [x] 优化代码结构并上传到 gitLab
- [x] 记录今天接收到多少消息数据，转发了多少数据，并记录任务耗时多少 ms，编写接口查看同一设备编号下不同数据的消息记录数
- [ ] 

