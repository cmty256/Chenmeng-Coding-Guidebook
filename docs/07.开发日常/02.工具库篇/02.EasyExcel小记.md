# EasyExcel 小记

> 官方文档：[写Excel | Easy Excel (alibaba.com)](https://easyexcel.opensource.alibaba.com/docs/current/quickstart/write#web中的写并且失败的时候返回json)

## Date 字段问题

*报错：*

```tex
{
    "code": "1",
    "message": "导出文件失败：java.lang.NoSuchMethodError: org.apache.poi.ss.usermodel.Cell.setCellValue(Ljava/time/LocalDateTime;)V"
}
```

这是因为要导出的列里面有 `Date` 类型，EasyExcel 识别不了

*解决方法：*

1、编写 Date 转换器

```java
public class DateConverter implements Converter<Date> {

	private static  final String PATTERN_YYYY_MM_DD = "yyyy-MM-dd";

	@Override
	public Class<Date> supportJavaTypeKey() {
		return Date.class;
	}

	/**
	 * easyExcel导出数据类型转换
	 * @param cellData
	 * @param contentProperty
	 * @param globalConfiguration
	 * @return
	 * @throws Exception
	 */
	@Override
	public Date convertToJavaData(ReadCellData<?> cellData, ExcelContentProperty contentProperty, GlobalConfiguration globalConfiguration) throws Exception {
		String value = cellData.getStringValue();
		SimpleDateFormat sdf = new SimpleDateFormat(PATTERN_YYYY_MM_DD);
		return sdf.parse(value);
	}

	/**
	 * easyExcel导入Date数据类型转换
	 * @param context
	 * @return
	 * @throws Exception
	 */
	@Override
	public WriteCellData<String> convertToExcelData(WriteConverterContext<Date> context) throws Exception {
		Date date = context.getValue();
		if (date == null) {
			return null;
		}
		SimpleDateFormat sdf = new SimpleDateFormat(PATTERN_YYYY_MM_DD);
		return new WriteCellData<>(sdf.format(date));
	}

}
```

2、修改导出视图类中的 Date 类型字段，加入 `converter = DateConverterUtil.class` 转换属性

```java
	@ExcelProperty(value = "最新维保时间", index = 3, converter = DateConverter.class)
	@DateTimeFormat(pattern = "yyyy-MM-dd HH:mm:ss")
	@JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss", timezone = "GMT+8")
	private Date time;
```

*参考：*

[使用easyExcel导入导出Date类型的转换问题 (mfbz.cn)](http://www.mfbz.cn/a/88010.html)

## 自定义字典映射转换器

*反例：*

直接用 `@Resource` 注入 bean 使用，会报错，不被 Spring IoC 管理。

```java
		List<DictDTO> dictList = documentMapper.getDict(CERTIFICATE);
```

*报错：*

注入的 `bean`，查数据库的时候，报 `空指针异常`，导致转换数据的时候第一条字典映射转换就失败

*原因猜测：*

- 在 EasyExcel 中，转换器通常是默认通过构造函数 `new` 出来的，而不是由 Spring 容器管理的 `Bean`。
- 因此，在转换器中，如果你需要使用 Spring 容器中的其他 `Bean`，你需要手动获取这些 Bean，而不是通过 Spring 的依赖注入。

> :bulb: Spring 管理的 bean 通常是**由 Spring 容器负责创建、配置和管理的**。当你使用 `new` 运算符直接实例化一个对象时，这个对象不会由 Spring 容器来管理，因此 Spring 不会介入该对象的生命周期和依赖注入。

**解决方法**

通过 Spring 容器提供的方法来获取已经由 Spring 管理的 bean。

```java
		DocumentMapper bean = SpringUtil.getBean(DocumentMapper.class);
		List<DictDTO> dictList = bean.getDict(CERTIFICATE);
```

参考：

[EasyExcel 使用Converter 转换注入时报nullPoint异常_converter null入参_地平线上的新曙光的博客-CSDN博客](https://blog.csdn.net/m0_48324758/article/details/121806912)

*完整代码：*

```java
public class DocumentDictConverter implements Converter<String> {

	@Override
	public Class<?> supportJavaTypeKey() {
		return String.class;
	}

	@Override
	public CellDataTypeEnum supportExcelTypeKey() {
		return CellDataTypeEnum.STRING;
	}

	@Override
	public String convertToJavaData(ReadCellData<?> cellData, ExcelContentProperty contentProperty, GlobalConfiguration globalConfiguration) throws Exception {
		return cellData.getStringValue();
	}

	/**
	 * 这里是写的时候会调用
	 *
	 * @return
	 */
	@Override
	public WriteCellData<?> convertToExcelData(WriteConverterContext<String> context) {
		// 获取字典列表
		DocumentMapper bean = SpringUtil.getBean(DocumentMapper.class);
		List<DictDTO> dictList = bean.getDict(CERTIFICATE);
		HashMap<String, String> dictMap = new HashMap<>(16);
		for (DictDTO dictDTO : dictList) {
			dictMap.put(dictDTO.getDictValue(), dictDTO.getDictName());
		}
		// 根据字典映射进行值转换
		String convertedValue = dictMap.get(context.getValue());

		if (convertedValue != null) {
			return new WriteCellData<>(convertedValue);
		} else {
			return new WriteCellData<>(context.getValue());
		}
	}

}
```

### 性能问题

- 每次做字段值映射转换的时候都需要查数据库，太影响性能了。
- 考虑引入**缓存**，达到只需查询一次数据即可。
- 将字典数据在服务启动时加载到内存中，并在转换器中直接使用内存中的字典数据而不是每次都查询数据库。

### 解决方案

> 一、使用 Spring 框架的缓存注解

1. 创建字典业务类

```java
@Service
public class DictionaryService {

    @Resource
    private DocumentExpiredMapper documentExpiredMapper;

    @Cacheable("dictionaryCache")
    public List<DictDTO> getDict(String dictionaryType) {
        return documentExpiredMapper.getDict(dictionaryType);
    }
}
```

2. 修改转换器类

```java
	@Override
	public WriteCellData<?> convertToExcelData(WriteConverterContext<String> context) {
		// 从 Spring 容器中获取 bean
		DictionaryService bean = SpringUtil.getBean(DictionaryService.class);
		// 从缓存中获取字典数据
		List<DictDTO> dictList = bean.getDict(CERTIFICATE);
		HashMap<String, String> dictMap = new HashMap<>(16);
		for (DictDTO dictDTO : dictList) {
			dictMap.put(dictDTO.getDictValue(), dictDTO.getDictName());
		}
		// 根据字典映射进行值转换
		String convertedValue = dictMap.get(context.getValue());

		if (convertedValue != null) {
			return new WriteCellData<>(convertedValue);
		} else {
			return new WriteCellData<>(context.getValue());
		}
	}
```

- 该方法使用 `@Cacheable("dictionaryCache")` 注解来定义缓存区域为 "dictionaryCache"，并且可以根据 `dictionaryType` 参数来查询字典数据。
- 当方法第一次被调用时，数据将被查询并放入缓存中，以后的调用将直接从缓存中获取数据。

> 二、将字典数据在服务启动时加载到内存中

1. 创建一个单例的字典数据加载类，该类**在应用启动时加载字典数据到内存中**。你可以使用 `@PostConstruct` 注解来标记一个初始化方法，该方法在 Spring 容器加载完所有 bean 后执行。

```java
@Service
public class DictionaryDataService {
    private Map<String, String> certificateDict = new HashMap<>();

    @Autowired
    private DocumentExpiredMapper documentExpiredMapper;
    
    // 这个方法会在 bean 初始化时被自动调用
    @PostConstruct
    public void init() {
        // 在 bean 初始化时执行一些初始化操作
        List<DictDTO> dictList = documentExpiredMapper.getDict(CERTIFICATE);
        for (DictDTO dictDTO : dictList) {
            certificateDict.put(dictDTO.getDictValue(), dictDTO.getDictName());
        }
    }

    public String getCertificateDictValue(String key) {
        return certificateDict.get(key);
    }
}
```

2、修改转换器类，使用内存中的字典数据进行转换：

```java
    @Override
    public WriteCellData<?> convertToExcelData(WriteConverterContext<String> context) {
        DictionaryDataService bean = SpringUtil.getBean(DictionaryDataService.class);
        String convertedValue = bean.getCertificateDictValue(context.getValue());
        if (convertedValue != null) {
            return new WriteCellData<>(convertedValue);
        } else {
            return new WriteCellData<>(context.getValue());
        }
    }
```

通过这种方式，字典数据在应用启动时加载到内存中，以后的值转换操作都会使用内存中的数据，避免了重复查询数据库的性能开销。这是一种常见的性能优化方法。

> 优劣分析：

*第一种方法（`DictionaryService` 使用缓存）：*

优点：

1. 使用了 `@Cacheable` 注解，Spring 会自动处理缓存相关逻辑，包括缓存的清除、存储、失效等，减轻了你的工作负担。
2. 缓存数据在运行时动态从数据库中获取，因此数据保持最新，不需要手动更新。
3. 可以灵活地在其他地方使用 `DictionaryService` 服务，而不需要关心缓存细节。

缺点：

1. 需要依赖 Spring 缓存机制，可能需要较多配置和依赖，不如手动控制灵活。
2. 当有多个不同字典类型需要缓存时，可能需要创建多个不同的缓存，增加了管理复杂度。

*第二种方法（`DictionaryDataService` 使用内存缓存）：*

优点：

1. 简单明了，不依赖 Spring 缓存机制，适用于小规模应用或特定场景。
2. 在应用启动时加载字典数据到内存中，查询字典数据的速度非常快，适用于频繁查询字典数据的场景。

缺点：

1. 手动加载字典数据到内存，如果数据库中的数据发生变化，需要手动同步内存数据，容易出现数据不一致的问题。
2. 不支持自动过期和失效处理，需要自己编写逻辑来处理缓存的更新和失效。
3. 在大规模应用中，如果内存占用较多，可能会影响应用性能。

> 场景分析：

- 如果你的应用**要求字典数据保持实时性**，能够自动过期和更新，使用第一种方法更为合适。
- 如果应用规模较小、**字典数据变化不频繁**，或者希望简化配置，第二种方法也是一个不错的选择。
- 理论上来说，第一种用的更为广泛

### @PostConstruct 注解

`@PostConstruct` 是 Java EE（Enterprise Edition）的注解之一，它标识在类实例化后，但在类投入使用之前要执行的方法。通常在使用 Spring 框架或其他依赖注入框架时，`@PostConstruct` 注解用于在 bean 的初始化过程中执行一些额外的初始化操作。以下是关于 `@PostConstruct` 注解的一些重要信息：

1. **生命周期回调方法**：`@PostConstruct` 用于定义在 bean 的生命周期中何时应该执行的初始化方法。它提供了一个方便的方式来执行一些准备工作，如数据加载、资源初始化等。
2. **执行时机**：`@PostConstruct` 注解的方法会在 Spring 容器创建 bean 实例后，依赖注入之前执行。这意味着它是在 bean 的构造函数之后，依赖注入之前执行的，用于初始化 bean 的各种属性。
3. **方法签名**：被 `@PostConstruct` 注解的方法没有参数。方法名可以随意命名，但通常为 `init`、`initialize`、`postConstruct` 等。
4. **依赖注入和容器管理**：`@PostConstruct` 注解通常与依赖注入和容器管理框架（如 Spring、Java EE 容器等）一起使用。容器会在执行构造函数和依赖注入后，自动调用被 `@PostConstruct` 注解的初始化方法。
5. **异常处理**：如果 `@PostConstruct` 注解的方法抛出异常，容器会将异常捕获并处理，通常会导致 bean 创建失败。这可以用于在初始化阶段检测配置错误或其他问题。
6. **多次调用**：`@PostConstruct` 注解的方法只会被调用一次，即使 bean 在容器中被多次注入也是如此。
7. **典型用途**：`@PostConstruct` 常用于执行一些需要在 bean 初始化时进行的操作，例如数据库连接的建立、资源初始化、数据加载等。

### 内存与缓存

*以下是 "加载到内存" 和 "放入缓存" 的相关概念。*

1. **加载到内存**：

   - 加载到内存通常指将数据、资源或对象从持久存储（如硬盘或数据库）加载到【计算机的内存】中，以便在应用程序中使用。
   - 这是一个通用操作，常见于应用程序的启动过程或在需要访问数据时。

2. **放入缓存**：

   - 放入缓存是一种特定的加载到内存操作，它指的是将数据或计算结果存储在一个【临时存储区域】中，通常在内存中，以提高后续访问的性能。
   - 缓存通常包括缓存键（用于检索数据）和缓存值（实际数据或计算结果）。

3. **内存加载的情况**：

   - 内存加载可能是一次性的，例如在应用程序启动时加载配置文件。（一次性初始化）

   - 内存加载也可能是动态的，例如从数据库中加载实时数据或通过用户请求加载。

     > - 如果数据的变化频率较低，可以使用**定时刷新**。
     > - 如果数据变化频繁，**懒加载**或**异步加载**可能更合适。
     > - **缓存加载器**适用于需要复杂逻辑来获取数据的情况。

4. **缓存的情况**：
   - 缓存是一种性能优化技术，通过将频繁访问的数据存储在内存中，以减少重复访问持久存储的开销。
   - 缓存通常采用一定策略，例如缓存过期时间或根据内存大小来管理缓存。

综上所述：

- 加载到内存是一种广泛的操作，它可以用于不同的用途，
- 而缓存是一种内存加载的具体应用，它的主要目的是提高数据访问的性能。缓存通常包括一些管理策略，以确保缓存数据的有效性和一致性。

![image](https://cdn.jsdelivr.net/gh/cmty256/imgs-blog@main/project/image.4l5ynghnfu20.webp)

## 使用案例

参考官方文档案例：[web中的写并且失败的时候返回json](https://easyexcel.opensource.alibaba.com/docs/current/quickstart/write#web中的写并且失败的时候返回json)

```java
	@Override
	public void exportDocument(DocumentDTO documentDTO, HttpServletResponse response) throws IOException {
		// 1、获取证件临期告警列表
		List<DocumentVO> documentList = getDocumentList(documentDTO);
		// 2、 Excel文件标题
		String title = "Excel文件标题";
		// 3、告警类型值替换
		List<DocumentExportVO> exportVOList = BeanUtil.copy(documentList, DocumentExportVO.class);
		// 4、EasyExcel导出
		try {
			// 设置内容类型
			response.setContentType("application/vnd.openxmlformats-officedocument.spreadsheetml.sheet");
			// 设置字符编码
			response.setCharacterEncoding("utf-8");
			// 这里URLEncoder.encode可以防止中文乱码 当然和easy excel没有关系
			String fileName = URLEncoder.encode(title, "UTF-8").replaceAll("\\+", "%20");
			// 设置响应头
			response.setHeader("Content-disposition", "attachment;filename*=utf-8''" + fileName + ".xlsx");
			// 这里需要设置不关闭流
			EasyExcel.write(response.getOutputStream(), DocumentExportVO.class)
				.autoCloseStream(Boolean.FALSE)
				.sheet("模板")
				.doWrite(exportVOList);
		} catch (Exception e) {
			// 重置response
			response.reset();
			String errorMessage = "导出文件失败：" + e.getMessage();
			returnResult(response, errorMessage);
			// e.printStackTrace();
		}
	}
```

*代码规范问题：*

```java
// 将错误信息全部打印在控制台
e.printStackTrace();
```

- 全部错误信息打印出来，有助于排查 `转换器类` 的问题（不会打印到日志文件中，但会一直刷控制台）
- 但是一般生产情况不能打印出来，因为可能会引发事故

*参考：*

- [代码规范：禁用e.printStackTrace()打印异常_e.printstacktrace()禁用-CSDN博客](https://blog.csdn.net/weixin_39309402/article/details/100143790)

- [代码规范之e.printStackTrace（）-CSDN博客](https://blog.csdn.net/m0_49976286/article/details/119565008)
- [【温情提醒】工作中要少用e.printStackTrace()的致命原因之一_printtrace问题-CSDN博客](https://blog.csdn.net/liangcheng0523/article/details/107685646)
