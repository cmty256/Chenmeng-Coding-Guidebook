---
title: 开发疑惑
date: 2023-07-16 09:56:32
permalink: /pages/170fbd/
---
# 开发疑惑

## 什么是 POJO

POJO（Plain Old Java Object）是一种普通的 Java 对象，通常是指与数据模型相关的类。

其中可能涉及以下几个部分：

1. DTO（Data Transfer Object）：DTO 是用于在不同层之间传输数据的对象。它通常包含了与数据库表字段一一对应的属性，并提供了用于数据传输的 getter 和 setter 方法。
2. Entity：Entity（实体类）通常用于映射数据库中的表或文档。它包含了与数据库表字段一一对应的属性，并提供了持久化操作的方法。Entity 对象一般用于 ORM（对象关系映射）框架，如 Hibernate，来进行数据库操作。
3. VO（Value Object）：VO 是一种用于封装某个特定领域的值或数据的对象。它可以包含多个属性，并且这些属性可以是不同的数据类型。VO 对象通常用于在领域模型之间传递数据，而不直接与数据库交互。

这些对象（DTO、Entity、VO）都可以被归类为 POJO，因为它们是普通的 Java 对象，不依赖于特定的框架或技术。它们仅包含数据字段和相应的访问方法，不包含业务逻辑或特定的操作。

## foreach 的三种写法

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

// java 5 引入
for (Integer number : numbers) {
    System.out.println(number);
}

// java 8 写法

// 使用Stream的forEach方法进行迭代
numbers.stream().forEach(number -> System.out.println(number));

// 使用Lambda表达式和方法引用进行迭代
numbers.forEach(System.out::println);
```

## 持久化与半持久化

- **持久化**将数据写入非易失性存储介质中，以确保数据在系统**重启后仍然可用**，
- 而**半持久化**只在系统运行期间保留数据，并在系统关闭或**重启时丢失**。

持久化适用于需要长期保存数据的场景，而半持久化适用于临时数据或不需要长期存储的场景。

## RocketMQ 集群部署问题

在 RocketMQ 中，推荐部署三台服务器的原因是为了实现高可用性和数据冗余。这种部署方式通常被称为主从复制或者主从模式。

部署三台服务器的好处是，当一台服务器发生故障或者需要维护时，系统可以继续正常运行。其中两台服务器承担主从节点的角色，而第三台服务器则可以作为备用节点。这样，即使有一台服务器宕机，消息仍然可以在其他服务器上进行处理和传递，**确保消息的可靠性和持久性**。

另外，将主从节点部署在两台服务器上也有其优势。通过将主节点和从节点部署在不同的服务器上，可以**实现数据的冗余和负载均衡**。主节点负责消息的写入和处理，而从节点则负责消息的备份和复制。这样可以提高系统的吞吐量和性能，并降低单点故障的风险。

总结起来，RocketMQ 推荐部署三台服务器并在两台服务器上部署主从节点，旨在提供**高可用性**、数据冗余和负载均衡，以确保消息系统的可靠性和性能。

## 什么是异步编排

异步编排是一种编程模式或设计方法，用于处理异步操作和任务的并发执行和协调。

- 在传统的同步编程中，代码会按照顺序逐行执行，当遇到耗时的操作时，程序会阻塞等待操作完成后再继续执行下一步。
- 而异步编排则允许在执行一个异步操作时，不会阻塞程序的其他部分，而是可以继续执行其他任务。

异步编排的目的是提高程序的并发性和性能，特别是在处理多个独立异步任务或操作时。它可以帮助程序充分利用系统资源，以提高处理速度和响应性。

在异步编排中，通常会使用以下方法或技术：

1. **回调函数：** 在执行异步任务时，可以指定一个回调函数，该函数会在任务完成后被调用，用于处理任务的结果。
2. **Promise/Future：** 使用 Promise 或 Future 对象可以在执行异步任务后获取其结果，而不需要阻塞程序的其他部分。
3. **异步事件处理：** 使用事件驱动模式来处理异步操作的完成事件，通过注册监听器或订阅事件来处理任务的结果。
4. **异步任务队列：** 将异步任务放入队列中，由专门的线程或进程来处理，以充分利用系统资源和提高并发性。
5. **并行计算：** 在执行多个独立异步任务时，可以将它们并行处理，以加快任务的完成时间。

异步编排在现代编程中得到广泛应用，特别是在处理网络请求、数据库查询、IO 操作等涉及到耗时的任务时，通过异步编排可以提高程序的性能和响应性，使得程序能够更高效地处理并发操作。

## 分布式的含义是什么

分布式的含义是指将一个系统或应用拆分成多个独立的组件（或子系统），这些组件可以在不同的计算机或服务器上运行，并通过网络进行通信和协作。每个组件负责特定的功能或任务，通过相互之间的通信和协作，实现整个系统的功能。

在分布式系统中，各个组件可以独立运行，这使得系统更加灵活、可扩展和容错。分布式系统通常涉及多台计算机，每台计算机可以处理一部分工作负载，从而提高系统的性能和吞吐量。

总的来说，分布式系统是一种将复杂的系统拆分为多个独立组件，分别运行在不同计算机上，通过网络相互通信和协作，以提高系统的性能、可扩展性和可靠性的设计架构。

## Jedis 和 redis 是什么关系

Jedis 是一个 Java 客户端库，用于与 Redis 数据库进行交互。它提供了一组丰富的方法和功能，用于连接、执行命令和操作 Redis 数据库。

Redis 是一个开源的高性能键值存储数据库，支持持久化、数据类型丰富、分布式和高可用性等特性。它以内存中的数据结构存储数据，并通过网络提供对数据的访问。

**Jedis 是 Redis 客户端库之一**，专门为 Java 语言设计和实现。它通过与 Redis 服务器建立连接，发送命令并接收响应来实现与 Redis 的交互。Jedis 提供了简单、直观的 API，使 Java 开发人员可以方便地使用 Redis 数据库。它支持与 Redis 的各种操作，包括字符串、哈希、列表、集合、有序集合等数据结构的读写操作。

在使用 Jedis 时，你需要将 Jedis 客户端库添加到你的项目中，并在代码中创建 Jedis 对象来与 Redis 进行通信。通过 Jedis，你可以执行各种 Redis 命令，如 SET、GET、HSET、HGET、LPUSH、LRANGE 等。

除了 Jedis，还有其他编程语言和平台的 Redis 客户端库，如 StackExchange.Redis（C#）、redis-py（Python）、redis-rb（Ruby）等。这些客户端库都是用于在不同编程语言中与 Redis 进行交互的工具。

因此，Jedis 是 Redis 的 Java 客户端库之一，用于在 Java 应用程序中使用 Redis 数据库。它提供了方便的方法和功能，使 Java 开发人员能够使用 Redis 的各种功能和数据结构。

## 雪花算法和 UUID

雪花算法（Snowflake Algorithm）和 UUID（Universally Unique Identifier）都是用于生成唯一标识符（ID）的方法，但它们在生成方式、长度和适用场景上存在一些区别。

雪花算法是一种**基于时间戳和机器标识的算法**，用于生成趋势递增、有序且唯一的 ID。它使用一个 64 位的整数表示 ID，其中包含时间戳、数据中心 ID、机器 ID 和序列号。通过将这些部分合理地组合在一起，雪花算法可以在分布式系统中生成全局唯一的 ID。由于雪花算法基于时间戳，因此生成的 ID 保留了时间上的排序性。这种算法适合于分布式系统，以确保生成的 ID 在分布式环境中的唯一性。

UUID 是一种标准化的**全局唯一标识符**，它的长度为 128 位（16 字节），通常表示为 32 个十六进制数字的字符串。UUID 是由计算机硬件地址、当前时间戳和随机数等信息生成的。UUID 的生成过程是基于随机性的，因此可以在分布式环境中保持全局唯一性。与雪花算法不同，UUID 并不保留时间上的排序性，因此生成的 ID 是无序的。UUID 适用于需要在不同系统、不同数据库之间保持唯一性的场景。

选择使用雪花算法还是 UUID 取决于具体的需求和应用场景：

- 如果需要在分布式系统中保持全局唯一性并具有趋势递增的特性，可以选择雪花算法。
- 如果需要在不同系统、不同数据库之间保持全局唯一性，并且无需关注排序性和时间相关的特性，可以选择 UUID。

选择自增整数或 UUID 作为主键 ID 取决于以下因素：

- 需求：根据具体需求来判断。如果需要在数据库层面保证递增的唯一性，可以选择自增整数。如果需要在分布式环境下保证全局唯一性，可以选择 UUID。
- 性能：自增整数通常比 UUID 在索引、查询和排序等方面更高效，因为它们可以利用数据库的自增特性和整数索引。UUID 则相对较大，可能会对数据库性能产生一定的影响。
- 可读性：自增整数主键具有可读性，可以更容易地理解和推断出记录的创建顺序。UUID 则相对较长，不具备直观的可读性。

## 如果 redis 数据库宕机了咋办

如果 Redis 数据库宕机了，你可以采取以下步骤来应对这种情况：

1. 检查 Redis 服务器状态：首先，确认 Redis 服务器是否真的宕机了。你可以尝试连接到 Redis 服务器并执行一些基本操作来验证其状态。
2. 恢复 Redis 服务器：如果确认 Redis 服务器宕机了，你需要采取相应的措施来恢复它。具体的步骤可能因你的环境和配置而有所不同。通常，可以尝试重启 Redis 服务器，或者检查日志文件以了解可能的错误原因。
3. 备份和恢复数据：如果 Redis 数据库的数据没有进行持久化保存（如配置了 RDB 持久化或 AOF 持久化），那么在 Redis 宕机后，数据可能会丢失。如果你有 Redis 数据库的备份，可以尝试使用备份数据来进行恢复。否则，你需要考虑重新构建丢失的数据。
4. 容错和高可用性：为了避免单点故障，你可以在 Redis 架构中引入容错和高可用性机制。例如，使用 Redis Sentinel 或 Redis Cluster 来实现故障转移和自动故障恢复。
5. 监控和预警：建立监控系统来实时监测 Redis 服务器的状态。这样，你可以及时收到警报并采取措施来应对宕机或其他问题。

## 什么是 xss

XSS（跨站脚本攻击，Cross-Site Scripting）是一种常见的网络安全漏洞，它允许攻击者将恶意的脚本注入到受信任的网页中，使其在用户浏览器上执行。

XSS 攻击通常利用了 Web 应用程序对用户输入数据的不充分过滤或验证。攻击者可以通过在网页中插入恶意的脚本，例如 JavaScript，来窃取用户的敏感信息、劫持用户会话、修改网页内容或执行其他恶意操作。

XSS 攻击可以分为三种常见类型：

1. 存储型 XSS：恶意脚本被注入到目标网站的服务器端，存储在数据库中，当用户请求包含恶意脚本的页面时，恶意脚本会被服务器返回并在用户的浏览器上执行。
2. 反射型 XSS：恶意脚本作为用户的输入参数，例如通过 URL 的查询参数传递，当用户访问包含恶意脚本的链接时，恶意脚本会被注入到页面中并在用户的浏览器上执行。
3. DOM 型 XSS：恶意脚本通过修改网页的 DOM（文档对象模型）结构，例如修改网页中的 JavaScript 代码或元素属性，当用户浏览被攻击的页面时，恶意脚本会被执行。

XSS 攻击的危害包括窃取用户敏感信息（如登录凭据、个人信息）、盗取用户会话、篡改网页内容、重定向用户到恶意网站等。为了防止 XSS 攻击，开发人员应该采取适当的安全措施，如对用户输入进行严格的验证和过滤、使用安全的编码方式输出数据、设置合适的 HTTP 头部等。

用户也应保持警惕，避免点击来自不可信来源的链接，尤其是那些看起来可疑或提供了用户敏感信息的网页。此外，使用最新版本的浏览器和安全插件可以帮助减少 XSS 攻击的风险。

## 局部变量没有默认值，那包装类型的局部变量呢

局部变量无论是基本数据类型还是包装类型，在 Java 中都没有默认值。局部变量在声明时必须显式地初始化，否则编译器会报错。

对于基本数据类型的局部变量，如果在声明时没有初始化，编译器会提示错误。例如：

```java
public void exampleMethod() {
    int x; // 编译错误，x未初始化
    System.out.println(x);
}
```

对于包装类型的局部变量，同样没有默认值，并且也必须显式地初始化。例如：

```java
public void exampleMethod() {
    Integer y; // 编译错误，y未初始化
    System.out.println(y);
}
```

需要注意的是，类的成员变量（包括静态成员变量和实例成员变量）会有默认值，但局部变量不会。成员变量的默认值是根据数据类型来确定的，例如，整数类型的成员变量默认为 0，布尔类型的成员变量默认为 false，引用类型的成员变量默认为 null 等。但这些规则不适用于局部变量。