# 哈希表

## TreeMap 分析

1. 时间复杂度(平均)
   - 添加、删除、搜索: O(logn)

2. 特点
   - Key 必须具备可比较性
   - 元素的分布是有顺序的

3. **在实际应用中，很多时候的需求**
   - Map 中存储的元素不需要讲究顺序
   - Map 中的 Key 不需要具备可比较性

4. 不考虑顺序、不考虑 Key 的可比较性，Map 有更好的实现方案，平均时间复杂度可以达到 O(1) 
   - 那就是采取**哈希表**来实现 Map

## 初始哈希表

![image-20231113103947640](https://cdn.statically.io/gh/cmty256/imgs-blog@main/basics/image-20231113103947640.60rz7wjvde80.webp)

**空间换时间**：一开始数组里面的索引肯定是比 key 的数量多的。浪费了一定的空间。

## 哈希冲突

![image-20231113105725752](https://cdn.statically.io/gh/cmty256/imgs-blog@main/basics/image-20231113105725752.5g4vc56l1040.webp)

## JDK8的哈希冲突解决方案

![image-20231113110534993](https://cdn.statically.io/gh/cmty256/imgs-blog@main/basics/image-20231113110534993.4sx3vzhpomc0.webp)

## 哈希函数

*1、哈希表中哈希函数的实现步骤大概如下*

- 用与运算（`&`）效率更高，一个【**2 的 n 次方**】的数【减一】，它的**二进制一定全是 1**。
- 两个二进制数做与运算，运算结果一定是小于等于 `table.length-1` 的。（以下图的与运算为例）
- 即最终得出来结果其实就是【0 到 table.length-1】，也就是【**数组索引值**】。

> ❗❗❗ **hash_code & (table.length-1)** 实际上就是保留 `hash_code` 的二进制表示中的低位，忽略掉高位（因为**低位们就是余数**）。
>
> ❗❗❗ 这样就能保证取模运算 `hash_code % length` 的效果和位运算 `hash_code & (table.length-1)` 是一样的，但是位运算的速度更快。

```java

2^1 == 010
2^1 - 1 == 001 == 1
  
2^2 == 100
2^2 - 1 == 011 == 11

 10101       10111
&00111      &00111
-------     ------- 
 00101       00111
  
```



![image-20231113142023610](https://cdn.statically.io/gh/cmty256/imgs-blog@main/basics/image-20231113142023610.yjf4k5xdihc.webp)

*2、良好的哈希函数*

1. 让**哈希值**更加均匀分布 -> 减少哈希冲突次数 -> 提升哈希表的性能。
2. 比如说我们索引是 0 - 100，我们算出来这个索引可能是这个索引范围内的任何位置
   - 如果算出来的索引几乎都集中在前半部分，比如说索引几乎都集中在 0- 50 这个范围，那这样的话就可能会导致哈希冲突比较严重。

## 哈希值计算

### 如何生成 key 的哈希值

*key 的常见种类可能有：*

1. 整数、浮点数、字符串、自定义对象
2. 不同种类的 key，哈希值的生成方式不一样，但目标是一致的
   - 尽量让每个 key 的哈希值是唯一的
   - 尽量让 key 的所有信息参与运算

**在 Java 中，HashMap 的 key 必须实现 hashCode、equals 方法，也允许 key 为 null**

### int 和 float 的哈希值

1. *整数*

- 整数值当做哈希值比如 10 的哈希值就是 10

- ```java
  public static int hashCode(int value) {
    return value;
  }
  ```

2. *浮点数*

- 将存储的**二进制格式**转为整数值

- ```java
  public static int hashCode(float value) {
    return floatToIntBits(value);
  }
  ```

*比如浮点数 `10.6f` 在内存中实际上存储的就是二进制数据*

```java
// 哈希值
int code = Float.floatToIntBits(10.6f);
System.out.printIn(code);
System.out.println(Integer.toBinaryString(code));

// 控制台输出
1093245338
10000010010101100110110011010
```

### Long 和 Double 的哈希值

> long 和 double 都是 8 个字节，即 64 位。
>
> 而哈希值必须是 int，即 32 位。**所以需要计算**。

*需注意以下几点：*

1. 用**异或运算**（`^`）和**无符号右移**（`>>>`）
2. 高 32 位和低 32 位进行异或算出 32 位的哈希值
3. 要充分利用所有信息计算出哈希值

*计算 long 类型：*

```java
public static int hashCode(long value) {
  return (int)(value ^ (value >>> 32));
}
```

*计算 double 类型：*

```java
public static int hashCode(double value) {
  long bits = doubleToLongBits(value);
  return (int)(bits ^ (bits >>> 32));
}
```

*具体如下图所示：*

![image-20231114095514627](https://cdn.statically.io/gh/cmty256/imgs-blog@main/basics/image-20231114095514627.54gmjfuxz000.webp)

**用【原数值的低位】和【无符号右移得到的高位】进行【异或运算】。**

### 字符串的哈希值

*字符串的哈希值计算如下：*

![image-20231114204613215](https://cdn.statically.io/gh/cmty256/imgs-blog@main/basics/image-20231114204613215.4nvcd4kcrci0.webp)

*在 JDK 中，（乘法因子）乘数 n 为 31，为什么会使用 31？*

主要有以下两个优势：

1. **位运算优势：**31 的二进制表示是 `11111`，这个特性使得在进行乘法运算时，可以通过移位和减法的组合来实现，提高了效率。
2. **奇数的好处：** 31 是一个奇数，这有助于避免乘法溢出时产生相同的低位结果。如果使用偶数，可能会导致在哈希值的低位上丢失信息。
   - 这就使得 JVM 能够通过位运算来优化乘法操作。具体来说，JVM 会将 `31 * i` 优化成 `(i << 5) - i`
   - 2^5 == 32, 所以 `(i << 5) - i` == `i * 2^5 - i` == `31 * i`

> **总之，选择 31 是为了在字符串哈希计算中充分利用计算机的位运算和乘法优化，以提高效率和性能。**

*源码分析：*

```java
public int hashCode() {
    int h = hash; // 步骤 1：检查是否已计算哈希值
    if (h == 0 && value.length > 0) {
        char val[] = value;

        for (int i = 0; i < value.length; i++) {
            // 步骤 2：使用乘法因子 31 计算哈希
            // 通过将当前哈希乘以 31 并加上当前字符的 Unicode 编码来更新哈希
            h = 31 * h + val[i];
        }
        // 步骤 3：缓存计算的哈希值以便将来使用
        hash = h;
    }
    // 步骤 4：返回计算的哈希值
    return h;
}

```

这是 `String` 类中的 `hashCode` 方法的源码。这方法的目的是计算字符串的哈希值，以便在哈希表等数据结构中使用。

**具体说明：**

1. 首先，它检查 `hash` 变量是否已经计算过哈希值，如果是，则直接返回这个哈希值。
2. 如果 `hash` 为 0（表示没有计算过哈希值），并且字符串长度大于 0，那么就进入计算哈希值的过程。
3. 使用 31 作为乘数，遍历字符串的每一个字符，不断更新哈希值。更新的方式是将当前哈希值乘以 31，然后加上当前字符的 Unicode 编码值。这里使用了位运算和加法，而不是直接进行乘法操作，这是因为位运算和加法在计算机中更为高效。
4. 最后，将计算得到的哈希值赋给 `hash` 变量，并返回这个哈希值。

这种哈希计算方法具有一定的效率和均匀分布的特点，适用于一般的字符串。通过遍历每个字符，以字符的 Unicode 编码值来影响最终的哈希值，从而保证字符串中每个字符都有影响。这样设计的目的是尽可能减小哈希冲突的概率。

### 自定义对象的哈希值

*如何计算自定义对象的哈希值呢？*

- 假设现在有一个对象 person。
- 把 person 当作是字符串，把 person 当作字符串，然后这每一个哈希值当作是每一个字符。

*代码如下：*

```java
	@Override
	public int hashCode() {
		int hashCode = Integer.hashCode(age);
		hashCode = hashCode * 31 + Float.hashCode(height);
		hashCode = hashCode * 31 + (name != null ? name.hashCode() : 0);
		return hashCode;
	}
```

*思考：*

**1、哈希值太大，整型溢出怎么办？**

不用做任何处理，只要最后返回的是一个 int 类型的值就行。

**2、如果不重写 `hashCode()` 会怎么样？**

- 自定义的对象，如果不重写哈希值的话，那么它**最终生成的哈希值会和这个对象的【内存地址】直接挂钩**的。
- 会利用它默认的哈希值，也就是内存相关的哈希值，由它认定为内存地址相等的对象，哈希值才相等，所以导致的后果其实就是这两个会被当作不同的 key 来处理。
- 两个内容属性值相同的对象，返回的哈希值不一样。

> `@Data` 注解生成的 `hashCode()` 和 MybatisX 插件生成的 `hashCode()` 不一样

### equals







### 总结

- 哈希值必须是整数（`int`），也就是 **32 字节**。
- 可能为正数，也可能为负数，但不会影响计算【索引值】。（因为索引值的计算是位运算，且一定是在某个范围内）
