---
title: Hot 100
date: 2023-05-12 11:17:38
permalink: /pages/9b4014/
author: 
  name: 沉梦听雨
  link: https://gitee.com/dream-deeply-tyu/cmty256
---
## 什么时候用回溯法？

回溯法通常用于解决组合、排列、搜索等问题，其特点是在解决问题的过程中，需要多次尝试不同的选择，直到找到符合条件的解，或者所有的选择都尝试完毕后确定无解。具体来说，当问题满足以下条件时，可以考虑使用回溯法：

1. 问题需要求出所有可能的解。
2. 解空间非常大，但是可以通过剪枝等方式大大减少搜索空间。
3. 问题可以表示成树形结构，每个节点表示一种选择，可以通过深度优先搜索实现回溯。
4. 问题的每个解都可以用一个序列表示，序列中的元素表示选择的顺序。
5. 问题具有单调性，即问题的最优解可以通过一定规则的选择得到。 

例如，求解 N 皇后问题、0-1 背包问题、全排列问题等就可以考虑使用回溯法。回溯法在实现上通常需要使用递归，因此需要注意递归的开销，以及如何剪枝，减少无用的搜索。

## 简单

### [1. 两数之和](https://leetcode.cn/problems/two-sum/)

![image](https://cdn.jsdelivr.net/gh/cmty256/imgs-blog@main/basics/image.4d4ob21ocnq0.webp)

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        int[] result = new int[2];
        for(int i = 0; i < nums.length; i++){
            for(int j = i + 1; j < nums.length; j++){
                if(nums[i] + nums[j] == target){
                    result[0] = i;
                    result[1] = j;
                }
            }
        }
        return result;
    }
}
```

> c1 = (
> c[0] = )
> index = 1
>
> c1 = )
> c[0] == )
> index = 0
>
> c1 = ]

### [20. 有效的括号](https://leetcode.cn/problems/valid-parentheses/)

![image-20230415110215814](https://cdn.jsdelivr.net/gh/cmty256/imgs-blog@main/basics/image-20230415110215814.2fzlqb8oat0k.webp)

```java
class Solution {
    public boolean isValid(String s) {
        // 用数组来做，思想和用栈做一样，但效率高
        char[] c = new char[s.length()];
        // 标记数组 c 中下一个元素应该插入的位置
        int index = 0; 
        // 遍历字符串 s 中的每个字符
        for(int i = 0; i < s.length(); i++) { 
            // 取出字符串 s 中第 i 个字符
            char c1 = s.charAt(i); 
            
            if(c1 == '(') 
                // 如果该字符是左括号 '(', 则将相应的右括号 ')' 存入数组 c 中
                c[index++] = ')';
            else if(c1 == '[') 
                // 如果该字符是左括号 '[', 则将相应的右括号 ']' 存入数组 c 中
                c[index++] = ']';
            else if(c1 == '{') 
                // 如果该字符是左括号 '{', 则将相应的右括号 '}' 存入数组 c 中
                c[index++] = '}';
            else if(index == 0 || c[--index] != c1) 
                // 如果该字符不是左括号，且该字符与数组 c 中最后一个元素不匹配，或者数组 c 中没有元素，则返回 false
                return false;
        }
        // 如果数组 c 中的所有元素都被匹配了，则返回 true，否则返回 false
        return index == 0; 
    }
}
```

```java
        int n = s.length();
        if(n % 2 == 1){
            return false;
        }
        int length = n / 2;
        for( int i = 0;i < length;i++){
            s = s.replace("()","");
            s = s.replace("[]","");
            s = s.replace("{}","");
        }
        return s.length() == 0;
```
```java
        if(s.length() % 2 == 1){
            return false;
        }
        HashMap<Character, Character> map = new HashMap<>();
        map.put('(',')');
        map.put('[',']');
        map.put('{','}');

        char[] arr = new char[s.length()];
        int idx = 0;
        	for (char c: s.toCharArray()) {
        	if (map.containsKey(c)) {
        		arr[idx++] = c;
        		continue;
        	}
        	if (idx == 0) {
        		return false;
        	}
        	if (map.get(arr[idx-1]) == c) {
        		idx--;
        	} else {
        		return false;
        	}
        }
        return idx == 0;
```

### [21. 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/)

![image-20230415110510720](https://cdn.jsdelivr.net/gh/cmty256/imgs-blog@main/basics/image-20230415110510720.5xcssgbjsxs0.webp)

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        if (list1 == null) {
            return list2;
        }
        else if (list2 == null) {
            return list1;
        }
        else if (list1.val < list2.val) {
            list1.next = mergeTwoLists(list1.next, list2);
            return list1;
        }
        else {
            list2.next = mergeTwoLists(list1, list2.next);
            return list2;
        }
    }
}
```

> 先递归，再回溯 return

### [70. 爬楼梯](https://leetcode.cn/problems/climbing-stairs/)

![image](https://cdn.jsdelivr.net/gh/cmty256/imgs-blog@main/basics/image.52wzs04fbm40.webp)

```java
// 动态规划
class Solution {
    public int climbStairs(int n) {
        // 001 011 112 123 235
        int a = 0, b = 0, res = 1;

        for(int i =1; i <= n; i++) {
            a = b;
            b = res;
            res = a + b;
        }
        return res;
    }
}
```

### [94. 二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/)

![image](https://cdn.jsdelivr.net/gh/cmty256/imgs-blog@main/basics/image.1nl92fqcdjxc.webp)

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
 // 递归解法
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        // 新建一个存放遍历结果的集合
        List<Integer> res = new ArrayList<Integer>();
        // 左根右排序 遍历
        midorder(root,res);

        // 返回遍历结果
        return res;
    }

    public void midorder(TreeNode root,List<Integer> res) {
        // 判断到空节点，直接断开
        if(root == null) {
            return;
        }
        // 递归左子树
        midorder(root.left,res);
        // 存值
        res.add(root.val);
        // 递归右子树
        midorder(root.right,res);
    }
}
```

### [104. 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)

![image](https://cdn.jsdelivr.net/gh/cmty256/imgs-blog@main/basics/image.2tb0w8g6p200.webp)

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
//  广度优先 队列
class Solution {
    public int maxDepth(TreeNode root) {
        // 判断 根节点是否为空
        if(root == null) {
            return 0;
        }
        // 建立一个新队列，存每一层的节点
        Queue<TreeNode> queue = new LinkedList<TreeNode>();
        // 根节点进队列
        queue.offer(root);
        // 深度值计数
        int ans = 0;
        
        // 循环直到队列为空
        while(!queue.isEmpty()) {
            // 这一层队列的个数
            int size = queue.size();
            // 遍历这一层所所有节点并 出队列
            while(size > 0) {
                // 出队
                TreeNode node = queue.poll();
                // 左子树不为空，进队
                if(node.left != null) {
                    queue.offer(node.left);
                }
                // 右子树不为空，进队
                if(node.right != null) {   
                    queue.offer(node.right);
                }
                size--;
            }
            // 深度+1
            ans++;
        }
        return ans;
    }
}
```

```java
// 深度搜索 递归
    public int maxDepth(TreeNode root) {
        if (root == null)
            return 0;
        int left = maxDepth(root.left);
        int right = maxDepth(root.right);
        return Math.max(left, right) + 1;
    }
```

### [121. 买卖股票的最佳时机](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/)

![image](https://cdn.jsdelivr.net/gh/cmty256/imgs-blog@main/basics/image.55b1ukozauo0.webp)

```java
class Solution {
    public int maxProfit(int[] prices) {
        // 设置起始最小值
        int minprice = Integer.MAX_VALUE;
        // 最大利润
        int maxprofit = 0;

        for(int i = 0; i < prices.length; i++) {
            if(prices[i] < minprice) {
                minprice = prices[i];
            }else if((prices[i] - minprice) > maxprofit) {
                maxprofit = prices[i] - minprice;
            }
        }
        return maxprofit;
    }
}
```

### [136. 只出现一次的数字](https://leetcode.cn/problems/single-number/)

![image](https://cdn.jsdelivr.net/gh/cmty256/imgs-blog@main/basics/image.28ubf2yhvw4k.webp)

```java
class Solution {
    public int singleNumber(int[] nums) {
        /*
        根据异或性质:
        1. 任何数和 0 做异或运算，结果仍然是原来的数，即 a⊕0=a。
        2. 任何数和其自身做异或运算，结果是 a⊕a=0。
        3. 异或运算满足交换律和结合律，即 a⊕b⊕a=b⊕a⊕a=b⊕(a⊕a)=b⊕0=b。        
        因此将所有元素进行异或即可得到结果
         */
        int res = 0;
        for (int num : nums) {
            res ^= num;
        }
        return res;
    }
}
```

可以利用 Hash 表: 
```java
class Solution {
    public int singleNumber(int[] nums) {
        Map<Integer, Integer> map = new HashMap<>();
        for (Integer i : nums) {
            Integer count = map.get(i);
            count = count == null ? 1 : ++count;
            map.put(i, count);
        }
        for (Integer i : map.keySet()) {
            Integer count = map.get(i);
            if (count == 1) {
                return i;
            }
        }
        return -1; // can't find it.
    }
}
```
双循环：
```java
int singleNumber(int* nums, int numsSize){

    for(int i=0;i<numsSize;i++){
            
            int count=0;

        for(int j=0;j<numsSize;j++){
            
            if(nums[j]==nums[i])
                count++;
        }    
       
        if(count==1)
            return nums[i];
    }
    return -1;
}
```

### [141. 环形链表](https://leetcode.cn/problems/linked-list-cycle/)

![image-20230415112207738](https://cdn.jsdelivr.net/gh/cmty256/imgs-blog@main/basics/image-20230415112207738.dqek3zmxr1c.webp)

![image-20230415112225266](https://cdn.jsdelivr.net/gh/cmty256/imgs-blog@main/basics/image-20230415112225266.8z6bg9zgbag.webp)

快慢指针（双指针）:

```java
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */

public class Solution {
    public boolean hasCycle(ListNode head) {

       // 是否为 空链表或只有一个节点
        if(head == null || head.next == null) {
           // false:没有循环
           return false;
        }

        // 慢指针，初始值头结点
        ListNode slow = head;
        // 快指针，初始值第二个节点
        ListNode fast = head.next;
        // 直到 slow == fast代表有环链
        while(slow != fast) {
            // 到尾部了，则slow必定不等于fast，直接返回false
            if(fast == null || fast.next ==null) {
                return false;
            }
            // 移一位
            slow = slow.next;
            // 移二位（这是单链表）
            fast = fast.next.next;
        }
        return true;
    }
}
```

哈希表解法：
```java
public class Solution {
    public boolean hasCycle(ListNode head) {

        // 创建一个名为seen的HashSet对象，用于记录链表中已经访问过的节点；
		Set<ListNode> seen = new HashSet<ListNode>();
        // 遍历链表
        while(head != null) {
            // 判断是否被访问过，如果添加失败，seen.add(head)的返回值为false
            if(!seen.add(head)){
                return true;
            }
            head = heaad.next;
        }
        return false;
    }
}
```

### [160. 相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/)

![image-20230415112714727](https://cdn.jsdelivr.net/gh/cmty256/imgs-blog@main/basics/image-20230415112714727.2ee7636941xc.webp)

![image-20230415113006835](https://cdn.jsdelivr.net/gh/cmty256/imgs-blog@main/basics/image-20230415113006835.4xnjrn3n7ps0.webp)

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        Set<ListNode> hashSet = new HashSet<ListNode>();
        // 先遍历A链表,并把A链表的所有节点加入到哈希集合中
        ListNode temp = headA;
        while (temp != null) {
            hashSet.add(temp);
            temp = temp.next;
        }
        // 再遍历B链表
        temp = headB;
        while(temp != null) {
            // 判断集合中是否包含B链表的此节点
            if(hashSet.contains(temp)) {
                // 包含，返回相交节点
                return temp;
            }
            // 不包含，遍历下一个节点
            temp = temp.next;
        }
        // 没有相交节点，返回null
        return null;
    }
}
```

双指针：

> pA遍历 a+c+b 次
> pB遍历 b+c+a 次
>
> pA == pB
> 即可得到相交节点

### [169. 多数元素](https://leetcode.cn/problems/majority-element/)

![image-20230415113006835](https://cdn.jsdelivr.net/gh/cmty256/imgs-blog@main/basics/image-20230415113006835.4xnjrn3n7ps0.webp)

```java
class Solution {
    public int majorityElement(int[] nums) {
        Map<Integer, Integer> map = new HashMap<>();
        for (Integer i : nums) {
            Integer count = map.get(i);
            count = count == null ? 1 : ++count;
            map.put(i, count);
        }
        for (Integer i : map.keySet()) {
            Integer count = map.get(i);
            if (count > nums.length/2) {
                return i;
            }
        }
        return -1;
    }
}
```

### [206. 反转链表](https://leetcode.cn/problems/reverse-linked-list/)

![image-20230415113207929](https://cdn.jsdelivr.net/gh/cmty256/imgs-blog@main/basics/image-20230415113207929.75oswfayq040.webp)

迭代 （双指针）：

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
        // 假设最前面是个null
        ListNode prev = null;
        // 当前节点，初始值为头节点。 
        ListNode curr = head;
        
        // 遍历链表，每遍历一次就转换一次箭头
        while(curr != null) {
            // 存储当前节点（头节点）的下一节点
            ListNode next = curr.next;
            // null（prev）->curr 变为 null（prev）<-curr，转换箭头
            curr.next = prev;
            // 前置指针后移一位
            prev = curr;
            // 后置指针后移一位
            curr = next;
        }
        return prev;
    }
}
```

递归：
```java
class Solution {
    public ListNode reverseList(ListNode head) {
		// 空链表 或者 尾结点
        if(head == null || head.next == null) {
            return head;
        }
        // 递归
        ListNode res = reverseList(head.next);
        // 反转箭头
        head.next.next = head;
        // 每一节点指向null，把null放最后
        head.next = null;
        
        return res;
    }
}
```

### [226. 翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/)

![image-20230415113354098](https://cdn.jsdelivr.net/gh/cmty256/imgs-blog@main/basics/image-20230415113354098.4jw9wm3qrj00.webp)

递归：

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if(root == null) {
            return null;
        }
        // 递归左子树
        TreeNode left = invertTree(root.left);
        // 递归右子树
        TreeNode right = invertTree(root.right);
        // 翻转
        root.left = right;
        root.right = left;
        return root;
    }
}
```

层序遍历方式反转：

```java
    public TreeNode invertTreeByQueue(TreeNode root) {
        if (root == null) {
            return null;
        }
        Queue<TreeNode> queue = new ArrayDeque<>();
        queue.offer(root);
        while (!queue.isEmpty()) {
            TreeNode node = queue.poll();
            TreeNode temp = node.left;
            node.left = node.right;
            node.right = temp;
            if (node.left != null) {
                queue.offer(node.left);
            }
            if (node.right != null) {
                queue.offer(node.right);
            }
        }
        return root;
    }
```

深度优先遍历的方式反转：

```java
private TreeNode invertTreeByStack(TreeNode root) {
    if (root == null) {
        return null;
    }
    Stack<TreeNode> stack = new Stack<>();
    stack.push(root);
    while (!stack.isEmpty()) {
        int size = stack.size();
        for (int i = 0; i < size; i++) {
            TreeNode cur = stack.pop();
            TreeNode temp = cur.left;
            cur.left = cur.right;
            cur.right = temp;
            if (cur.right != null) {
                stack.push(cur.right);
            }
            if (cur.left != null) {
                stack.push(cur.left);
            }
        }
    }
    return root;
}
```
### [234. 回文链表](https://leetcode.cn/problems/palindrome-linked-list/)

![image-20230415113739219](https://cdn.jsdelivr.net/gh/cmty256/imgs-blog@main/basics/image-20230415113739219.1nzx898nikgw.webp)

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public boolean isPalindrome(ListNode head) {
        // 空链表或仅包含一个元素的链表无论如何都是回文的
        if (head == null || head.next == null) {
            return true;
        }
        int len = 0;
        ListNode p = head;
        // 得出链表长度
        while (p != null) {
            len++;
            p = p.next;
        }
        // 定义一个与链表一样长的数组
        int[] arr = new int[len];
        // 重新定义一下链表，因为上面定义的已经为空
        p = head;
        for (int i = 0; i < len; i++) {
            arr[i] = p.val;
            p = p.next;
        }
        for (int i = 0; i < len / 2; i++) {
            if (arr[i] != arr[len - 1 - i]) {
                return false;
            }
        }
        return true;
    }
}
```

### [283. 移动零](https://leetcode.cn/problems/move-zeroes/)

![image-20230415113922714](https://cdn.jsdelivr.net/gh/cmty256/imgs-blog@main/basics/image-20230415113922714.24hgpey01ctc.webp)

```java
class Solution {
    public void moveZeroes(int[] nums) {
        
        int[] arr = new int[nums.length];
        int count = 0;
        for(int i = 0; i < nums.length; i++) {
            if(nums[i] != 0) {
                arr[count] = nums[i];
                count++;
            }
        }
        for(int j = count; j < nums.length; j++) {
            arr[j] = 0;
        }
        // nums = Arrays.copyof(arr,arr.length);
        System.arraycopy(arr, 0, nums, 0, arr.length);
    }
}
```

### [338. 比特位计数](https://leetcode.cn/problems/counting-bits/)

![image-20230415114023587](https://cdn.jsdelivr.net/gh/cmty256/imgs-blog@main/basics/image-20230415114023587.6a679w3d6cs0.webp)

最高有效位：

```java
class Solution {
    public int[] countBits(int n) {
        int[] bits = new int[n + 1];
        // 最高有效位
        int highBit = 0;
        for(int i = 1; i <= n; i++) {
            // 判断 i是否是2的幂次方，如果数字i是2的幂次方(10,100)，则它的二进制表示中只有最高位是1，其余位都是0
            if((i & (i - 1)) == 0) {
                // 如果是，更新当前最高位（它的二进制表示中只有最高位是1，其余位都是0）
                highBit = i;
            }
            // 如果当前数字i是2的幂次方，那么它的二进制中1的个数为1；（此时最高位是自己，bits[0] + 1）
            // 否则，它的二进制中1的个数等于它去掉最高位1(110 -> 10)后的数字的二进制中1的个数加1
            bits[i] = bits[i - highBit] + 1;
        }
        return bits;
    }
}
```

> (i & (i - 1)) == 0是一个位运算的判断条件，它的含义是：如果数字i是2的幂次方，则它的二进制表示中只有最高位是1，其余位都是0。因此，当我们将i与i-1进行按位与运算时，如果结果为0，则说明i的二进制表示中只有一个1，即i是2的幂次方。这是因为，当i是2的幂次方时，i-1的二进制表示中的所有位都是1，因此按位与运算之后得到的结果为0；而当i不是2的幂次方时，i-1的二进制表示中会有一些位是0，按位与运算之后得到的结果就不为0。
> 在这段代码中，我们使用这个条件来判断当前数字i是否是2的幂次方，如果是，则更新当前的最高位为该数字；否则，根据上述算法计算当前数字的二进制中1的个数。因此，这个判断条件在这个算法中起到了很重要的作用。
>
> ```java
> class Solution {
>     public int[] countBits(int n) {
>         int[] bits = new int[n + 1];
>         for (int i = 1; i <= n; i++) {
>             bits[i] = bits[i >> 1] + (i & 1);
>         }
>         return bits;
>     }
> }
> ```
> 这也是一个计算数字0到n的二进制中1的个数的算法，具体来说，我们可以通过位运算来计算每个数字的二进制中1的个数。具体来说，对于一个数字i，我们可以将其右移一位，并将结果赋值给bits[i]，然后再判断i的二进制表示中的最低位是否为1，如果是，则将bits[i]加1。例如，对于数字6（二进制表示为110），我们将其右移一位得到3（二进制表示为11），此时bits[6]的值为bits[3]的值；然后我们再判断6的二进制表示中的最低位是否为1，发现是，因此需要将bits[6]加1，最终bits[6]的值为2。
> 这个算法的时间复杂度为O(n)，空间复杂度为O(n)。需要注意的是，这个算法比上一个算法要更加简单和高效，因为它不需要使用特殊的判断条件，而是直接使用位运算来计算每个数字的二进制中1的个数。

### [448. 找到所有数组中消失的数字](https://leetcode.cn/problems/find-all-numbers-disappeared-in-an-array/)

![image-20230415114217649](https://cdn.jsdelivr.net/gh/cmty256/imgs-blog@main/basics/image-20230415114217649.vs9ltf1lcf4.webp)

```java
class Solution {
    public List<Integer> findDisappearedNumbers(int[] nums) {
        int n = nums.length;
        for(int num : nums) {
            // 计算当前数应该出现的位置，并将该位置的数加上n
            int x = (num - 1) % n;
            nums[x] += n;
        }
        List<Integer> res = new ArrayList<Integer>();
        for(int i = 0; i < n; i++) {
            // 如果某个位置的数小于n，则说明该位置对应的数字没有出现过
            if(nums[i] <= n) {
                res.add(i + 1);
            }
        }
        return res;
    }
}
```

### [461. 汉明距离](https://leetcode.cn/problems/hamming-distance/)

![image-20230415114302597](https://cdn.jsdelivr.net/gh/cmty256/imgs-blog@main/basics/image-20230415114302597.4xmyhzhcekg0.webp)

最低位：

```java
class Solution {
    public int hammingDistance(int x, int y) {
        int s = x ^ y, ret = 0;
        while(s != 0) {
            // 累积最低位
            ret += s & 1;
            // 右移一位
            s >>= 1;
        }
        return ret;
    }
}
```

Interger.bitCount()：

```java
class Solution {
    public int hammingDistance(int x, int y) {
        return Integer.bitCount(x ^ y);
    }
}
```
> bitCount实现的功能是计算一个（byte,short,char,int统一按照int方法计算）int,long类型的数值在二进制下“1”的数量

### [543. 二叉树的直径](https://leetcode.cn/problems/diameter-of-binary-tree/)

![image-20230415114648011](https://cdn.jsdelivr.net/gh/cmty256/imgs-blog@main/basics/image-20230415114648011.rlpr4dxozkw.webp)

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    // 全局变量，统计路径节点数
    int ans;
    
    public int diameterOfBinaryTree(TreeNode root) {
        // 二叉树的直径（最长路径上的节点数）
        ans = 1;
        // 计算子树的深度
        depth(root);
        // 节点数 - 1 为边数
        return ans - 1;
    }

    public int depth(TreeNode node) {
        // 访问到空节点了，返回0
        if(node == null) {
            return 0;
        }
        // 当前节点的左子树的深度
        int L = depth(node.left);
        // 当前节点的右子树的深度
        int R = depth(node.right);
        // 更新 ans 的值，以找到最长路径上的节点数
        ans = Math.max(ans, L+R+1);
        // 返回根节点的深度。
        return Math.max(L, R) + 1;
    }
}
```

### [617. 合并二叉树](https://leetcode.cn/problems/merge-two-binary-trees/)

![image-20230415114745917](https://cdn.jsdelivr.net/gh/cmty256/imgs-blog@main/basics/image-20230415114745917.2iidy5q5o8q0.webp)

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {
        if (root1 == null) {
            return root2;
        }
        if (root2 == null) {
            return root1;
        }
        // 深度优先搜索
        TreeNode merged = new TreeNode(root1.val + root2.val);
        merged.left = mergeTrees(root1.left, root2.left);
        merged.right = mergeTrees(root1.right, root2.right);
        return merged;
    }
}
```

## 中等

### [2. 两数相加](https://leetcode.cn/problems/add-two-numbers/)

![image-20230415114941055](https://cdn.jsdelivr.net/gh/cmty256/imgs-blog@main/basics/image-20230415114941055.6xhesdkbsdo0.webp)

```java
@SuppressWarnings("all")
public class _2_两数相加 {

    /**
     * 1、简约版 -- 模拟, 创建虚拟节点 -- 1ms(100%), 42.50MB(8.59%)
     *
     * 输入：l1 = [2,4,3], l2 = [5,6,4]
     * 输出：[7,0,8]
     *
     * 解释：342 + 465 = 807.
     */
    class Solution1 {
        public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
            // 创建一个虚拟节点
            ListNode dummy = new ListNode(0);
            // 进位
            int carry = 0;
            // 当前节点
            ListNode cur = dummy;
            // 当l1或l2不为空或者进位不为0时，循环
            while (l1 != null || l2 != null || carry != 0) {
                // 1、计算两个节点相加的值
                int s = (l1 == null ? 0 : l1.val) + (l2 == null ? 0 : l2.val) + carry;
                // 2、计算进位
                carry = s / 10;
                // 3、将计算的值赋值给当前节点
                cur.next = new ListNode(s % 10);
                // 4、将当前节点指向下一个节点
                cur = cur.next;
                // 5、将l1和l2指向下一个节点
                l1 = l1 == null ? null : l1.next;
                l2 = l2 == null ? null : l2.next;
            }
            // 返回虚拟节点的下一个节点
            return dummy.next;
        }
    }

    /**
     *  2、详细版
     *
     * 输入：l1 = [2,4,3], l2 = [5,6,4]
     * 输出：[7,0,8]
     *
     * 解释：342 + 465 = 807.
     */
    class Solution2 {
        public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
            // 创建一个新的链表pre，并将其头结点赋值为0，用作答案链表的头结点
            ListNode pre = new ListNode(0);
            // 创建一个指针cur，指向pre的最后一个节点
            ListNode cur = pre;
            // 进位数
            int carry = 0;

            while(l1 != null || l2 != null) {
                int x = l1 == null ? 0 : l1.val;//3 4 2
                int y = l2 == null ? 0 : l2.val;//4 6 5
                int sum = x + y + carry;//7 10 8
                // 更新进位
                carry = sum / 10;//0 1 0
                // 当前两位节点的和
                sum = sum % 10;//7 0 8
                // 将sum对10取余得到当前位节点的值，用它创建一个新的节点，并将其作为答案链表的下一个节点
                cur.next = new ListNode(sum);//7 0 8

                // 将指针cur指向新创建的节点，以便后续使用cur指针来连接下一个新节点
                cur = cur.next;//7 0 8
                if(l1 != null)
                    l1 = l1.next;//4 2
                if(l2 != null)
                    l2 = l2.next;//6 5
            }
            // 链表遍历结束后，有carry > 0，还需要在答案链表的后面附加一个节点
            if(carry == 1) {
                cur.next = new ListNode(carry);
            }
            return pre.next;
        }
    }
}
```

### [3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)

![image-20230415115053752](https://cdn.jsdelivr.net/gh/cmty256/imgs-blog@main/basics/image-20230415115053752.5ahfz3lixxs0.webp)

哈希表，**窗口算法**：

```java
@SuppressWarnings("all")
public class _3_无重复字符的最长子串 {

    /**
     * 1、滑动窗口解法 -- 双指针 + 哈希表 -- 7ms(28.98%), 42.81MB(21.13%)
     */
    class Solution1 {
        public int lengthOfLongestSubstring(String s) {
            // 创建一个哈希表，用来存储字符和位置
            HashMap<Character, Integer> map = new HashMap<>();
            // 定义 左 右 指针
            int left = 0;
            int maxLen = 0;

            // 遍历字符串
            for (int right = 0; right < s.length(); right++) {
                // 获取当前字符
                char c = s.charAt(right);
                // 如果哈希表中已经存在当前字符，则更新左指针
                if (map.containsKey(c)) {
                    left = Math.max(left, map.get(c) + 1);
                }
                // 将当前字符和位置存入哈希表
                map.put(c, right);
                // 更新最大长度
                maxLen = Math.max(maxLen, right - left + 1);
            }

            return maxLen;
        }
    }

    /**
     * 2、滑动窗口解法 -- 双指针 + HashSet -- 9ms(20.64%), 43MB(13.47%)
     */
    class Solution2 {
        public int lengthOfLongestSubstring(String s) {
            // 哈希集合，记录每个字符是否出现过
            Set<Character> hashSet = new HashSet<Character>();
            int n = s.length();

            // 右指针，初始值为-1，相当于我们在字符串的左边界的左侧，还没有开始移动
            int rk = -1, ans = 0;
            for (int i = 0; i < n; i++) {
                // 判断是否为第一个字符
                if (i != 0) {
                    // 否，左指针向右移动一格，移除一个字符
                    hashSet.remove(s.charAt(i - 1));
                }
                // 当没有越界 且 右指针的下一个字符没有出现过时
                while (rk + 1 < n && !hashSet.contains(s.charAt(rk + 1))) {
                    // 不断地移动右指针，并将该字符添加到集合 occ 中
                    hashSet.add(s.charAt(rk + 1));
                    rk++;
                }
                // 计算当前找到的最长无重复字符子串的长度，并与之前的结果取最大值
                ans = Math.max(ans, rk + 1 - i);
            }
            return ans;
        }
    }
}
```

> 应该使用 `s.charAt(i)` 来获取字符串中第 i 个字符

### [5. 最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/)

![image-20230415115712023](https://cdn.jsdelivr.net/gh/cmty256/imgs-blog@main/basics/image-20230415115712023.2ty5wgi59ra0.webp)

动态规划：

```java
public class Solution {
    public String longestPalindrome(String s) {
        if (s == null || s.length() < 2) {
            return s;
        }
        int strLen = s.length();
        int maxStart = 0;  //最长回文串的起点
        int maxEnd = 0;    //最长回文串的终点
        int maxLen = 1;  //最长回文串的长度

        // dp[i][j] 表示字符串 s 中从下标 i 到下标 j 的子串是否为回文子串
        boolean[][] dp = new boolean[strLen][strLen];

        // 右边界
        for (int r = 1; r < strLen; r++) {
            // 左边界
            for (int l = 0; l < r; l++) {
                // 左右边界的字符相等 && 左右边界的字符不相等，但是子串的中心部分是回文子串
                // r - l <= 2主要是r=2，即字符串长度为3的时候
                if (s.charAt(l) == s.charAt(r) && (r - l <= 2 || dp[l + 1][r - 1])) {
                    // 将该子串设为回文串
                    dp[l][r] = true;
                    // r - l + 1为该子串长度
                    if (r - l + 1 > maxLen) {
                        maxLen = r - l + 1;
                        maxStart = l;
                        maxEnd = r;
                    }
                }
            }
        }
        // +1是为了返回的子串包括下标为 maxEnd 的字符
        return s.substring(maxStart, maxEnd + 1);
    }
}
```

暴力解法，超出时间限制：
```java
public boolean isPalindromic(String s) {
		int len = s.length();
		for (int i = 0; i < len / 2; i++) {
			if (s.charAt(i) != s.charAt(len - i - 1)) {
				return false;
			}
		}
		return true;
	}

public String longestPalindrome(String s) {
    String ans = "";
    int max = 0;
    int len = s.length();
    for (int i = 0; i < len; i++)
        for (int j = i + 1; j <= len; j++) {
            String test = s.substring(i, j);
            if (isPalindromic(test) && test.length() > max) {
                ans = s.substring(i, j);
                max = Math.max(max, ans.length());
            }
        }
    return ans;
}
```

### [11. 盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/)

![image-20230415160851899](https://cdn.jsdelivr.net/gh/cmty256/imgs-blog@main/basics/image-20230415160851899.5fu4ylhgil00.webp)

```java
class Solution {
    public int maxArea(int[] height) {
        int max = 0;
        int left = 0, right = height.length-1;
        // 直到两指针相遇
        while(left < right) {
            int area = Math.min(height[left], height[right]) * (right - left);
            max = Math.max(max, area);
            // 移动值较小的指针
            if(height[left] < height[right]) {
                left++;
            }else {
                right--;
            }
        }
        return max;
    }
}
```

> 该算法使用了双指针的方法，每次循环会将两个指针中的一个向中间移动一位，因此最多会遍历整个数组一次，时间复杂度为O(N)。 空间复杂度分析： 该算法只使用了常数个变量，因此空间复杂度为O(1)。无论输入的数组大小是多少，算法所占用的空间都不会随着数组大小的增加而增加。

### [15. 三数之和](https://leetcode.cn/problems/3sum/)

![image-20230415161146915](https://cdn.jsdelivr.net/gh/cmty256/imgs-blog@main/basics/image-20230415161146915.5n7w48bbd7o0.webp)

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> ans = new ArrayList<>();
        // 空数组 或 长度是否小于等于2
        if(nums == null || nums.length <= 2) {
            return ans;
        }
        // 将数组按升序排序
        Arrays.sort(nums);

        for(int i = 0; i < nums.length; i++) {
            // 排除第一个数就大于0的情况
            if(nums[i] > 0) {
                break;
            }
            // 排除当前数nums[i]重复的情况
            if(i > 0 && nums[i] == nums[i-1]) {
                continue;
            }
            // 与另外两个数的和的作比较
            int target = -nums[i];
            // 使用双指针left和right，在i的右侧区间中寻找两个数
            int left = i + 1, right = nums.length - 1;
            // 直到两个指针相遇
            while(left < right) {
                // 和等于0的情况
                if(nums[left] + nums[right] == target) {
                    // 符合，加入结果集合
                    ans.add(Arrays.asList(nums[i], nums[left], nums[right]));
                    
                    // 现在要增加 left，减小 right，但是不能重复，比如: [-2, -1, -1, -1, 3, 3, 3] , 
                    // i = 0, left = 1, right = 6, [-2, -1, 3] 的答案加入后，需要排除重复的 -1 和 3
                    left++;right--;
                    // 排除左指针重复的情况
                    while(left < right && nums[left] == nums[left-1]) {
                        left++;
                    }
                    // 排除右指针重复的情况
                    while(left < right && nums[right] == nums[right+1]) {
                        right--;
                    }
                }else if(nums[left] + nums[right] < target) { // 和小于0的情况
                    // 移动小数即左指针
                    left++;
                }else { // 和大于0的情况
                    // 移动大数即右指针
                    right--;
                }
            }
        }
        return ans;
    }
}
```

### [16. 最接近的三数之和](https://leetcode.cn/problems/3sum-closest/)

![image-20230416153048505](https://cdn.jsdelivr.net/gh/cmty256/imgs-blog@main/basics/image-20230416153048505.2nspv14vv2w0.webp)

```java
class Solution {
    public int threeSumClosest(int[] nums, int target) {
        // 先排序
        Arrays.sort(nums);
        // 获取数组长度
        int n = nums.length;
        // 前三数之和，后面用作与其他的三数之和作对比
        int ans = nums[0] + nums[1] + nums[2];
        for (int i = 0; i < nums.length; i++) {
            // 定义左右指针
            int left = i + 1, right = n - 1;
            // 直到左右指针相遇
            while (left < right) {
                // 计算和
                int sum = nums[i] + nums[left] + nums[right];
                // 比较差值
                if (Math.abs(target - sum) < Math.abs(target - ans)) {
                    ans = sum;
                }

                if (sum > target) {
                    // 当前和大于目标值，移动右指针
                    right--;
                }else if (sum < target) {
                    // 当前和小于目标值,移动左指针
                    left++;
                }else {
                    // 当前和与目标值相等,直接返回
                    return ans;
                }
            }
        }
        return ans;
    }
}
```

### [17. 电话号码的字母组合](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/)

![image-20230416164331415](https://cdn.jsdelivr.net/gh/cmty256/imgs-blog@main/basics/image-20230416164331415.19inkczht5pc.webp)

```java
class Solution {
    public List<String> letterCombinations(String digits) {
        // 存储所有字母组合的集合
        List<String> combinations = new ArrayList<String>();
        // 空字符串直接返回空集合
        if (digits.length() == 0) {
            return combinations;
        }
        // 号码-字符串，映射存储
        Map<Character, String> phoneMap = new HashMap<Character,String>();
        phoneMap.put('2', "abc");
        phoneMap.put('3', "def");
        phoneMap.put('4', "ghi");
        phoneMap.put('5', "jkl");
        phoneMap.put('6', "mno");
        phoneMap.put('7', "pqrs");
        phoneMap.put('8', "tuv");
        phoneMap.put('9', "wxyz");
        // 回溯
        backtrack(combinations, phoneMap, digits, 0, new StringBuffer());
        return combinations;
    }

    // 递归 combination：当前的字母集合
    public void backtrack(List<String> combinations, Map<Character, String> phoneMap, String digits, int index, StringBuffer combination) {
        if (index == digits.length()) {
            // 此时枚举完了所有的数字
            combinations.add(combination.toString());// ad ae ...
        } else {
            // 提取号码数字
            char digit = digits.charAt(index);
            // 提取数字对应的字符串
            String letters = phoneMap.get(digit);
            // 对应的字符串的长度
            int lettersCount = letters.length();
            // 递归组合
             for (int i = 0; i < lettersCount; i++) {
                combination.append(letters.charAt(i));
                backtrack(combinations, phoneMap, digits, index + 1, combination);
                // 递归结束后，需要将 combination 中的最后一个字母删除，以便枚举当前数字对应的下一个字母
                // 第一次删除了 d，方便组合 ae
                combination.deleteCharAt(index);
            }
        }
    }
}
```

### [19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)

![image-20230416171049032](https://cdn.jsdelivr.net/gh/cmty256/imgs-blog@main/basics/image-20230416171049032.c4pd15k0fug.webp)

```java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode pre = new ListNode(0, head);
        // 首先定义两个指针 start 和 end，均指向虚拟头节点 pre
        ListNode start = pre, end = pre;
        // start 指针先向前移动 n 步
        for (int i = 0; i < n; i++) {
            start = start.next;
        }
        // 然后 start 和 end 指针同时向前移动，直到 start 指针走到链表的末尾
        while (start.next != null) {
            start = start.next;
            end = end.next;
        }
        // 此时 end 为倒数第 n 个节点的前一节点，执行删除操作
        end.next = end.next.next;
        return pre.next;
    }
}
```

### [22. 括号生成](https://leetcode.cn/problems/generate-parentheses/)

```java
class Solution {
    public List<String> generateParenthesis(int n) {
        // 定义一个结果集合
        List<String> res = new ArrayList<>();
        // 回溯
        backtrack(res, "", n, n);
        return res;
    }
    
    private void backtrack(List<String> res, String str, int left, int right) {
        // 此时已经添加了 n 个左括号和 n 个右括号，将当前字符串添加到答案列表中
        if (left == 0 && right == 0) {
            res.add(str);
            return;
        }
        // 如果剩余左括号数量大于 0，则可以添加一个左括号，并递归调用函数，将 left 减 1
        if (left > 0) {
            backtrack(res, str + "(", left - 1, right);
        }
        // 如果 right 大于 0，且 right 大于 left，则可以添加一个右括号，并递归调用函数，将 right 减 1
        if (right > 0 && right >left) {
            backtrack(res, str + ")", left, right - 1);
        }
    }
}
```

图解：

![image-20230418203502038](https://cdn.jsdelivr.net/gh/cmty256/imgs-blog@main/basics/image-20230418203502038.7jle6cvl2480.webp)

### [31. 下一个排列](https://leetcode.cn/problems/next-permutation/)

![image-20230418203502038](https://cdn.jsdelivr.net/gh/cmty256/imgs-blog@main/basics/image-20230418203502038.7jle6cvl2480.webp)

```java
class Solution {
    public void nextPermutation(int[] nums) {
        // 从倒数第二个数开始向前遍历
        int i = nums.length - 2;
        // 找到第一个非逆序的数
        while (i >= 0 && nums[i] >= nums[i + 1]) {
            i--;
        }
        // 如果存在非逆序数
        if (i >= 0) {
            // 从最后一个数开始向前遍历
            int j = nums.length - 1;
            // 找到比 非逆序数 大的最小数
            while (j >= 0 && nums[i] >= nums[j]) {
                j--;
            }
            // 交换 非逆序数 和 比非逆序数大的最小数
            swap(nums, i, j);
        }
        // 反转非逆序数之后的数字
        reverse(nums, i + 1);
    }

    // 交换数组中的两个位置
    public void swap(int[] nums, int i,int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
    // 反转数组中 start 位置之后的数字
    public void reverse(int[] nums, int start) {
        int left = start, right = nums.length - 1;
        while (left < right) {
            swap(nums, left , right);
            left++;
            right--;
        }
    }
}
```

该算法的思路如下：

1. 
   从右往左遍历数组，找到第一个非逆序的数，记为非逆序数；

2. 如果不存在非逆序数，说明整个数组是逆序的，直接反转整个数组即可；

3. 如果存在非逆序数，从右往左找到比非逆序数大的最小数，将两个数交换位置；

4. 最后，将非逆序数之后的数字反转。
   例如：给定数组[1, 3, 5, 4, 2]，下一个排列为[1, 4, 2, 3, 5]。
   具体实现细节见代码中的注释。

### [33. 搜索旋转排序数组（二分查找）](https://leetcode.cn/problems/search-in-rotated-sorted-array/)

![image-20230418203502038](https://cdn.jsdelivr.net/gh/cmty256/imgs-blog@main/basics/image-20230418203502038.7jle6cvl2480.webp)

```java
class Solution {
    public int search(int[] nums, int target) {
        int n = nums.length;
        // 数组为空，返回 -1
        if (n == 0) {
            return -1;
        }
        // 数组只有一个元素，判断是否为目标值
        if (n == 1) {
            return nums[0] == target ? 0 : -1;
        }
        int left = 0, right = n - 1;
        // 二分查找
        while (left <= right) {
            int mid = (left + right) / 2;
            // 找到目标值，返回下标
            if (nums[mid] == target) {
                return mid;
            }
            
            if(nums[0] <= nums[mid]) { // 左半部分有序
                // 目标值在左半部分
                if (nums[0] <= target && target < nums[mid]) {
                    right = mid - 1;
                } else { // 目标值在右半部分
                    left = mid + 1;
                }
            } else { // 右半部分有序
                // 目标值在右半部分
                if (nums[mid] < target && target <= nums[n - 1]) {
                    left = mid + 1;
                } else { // 目标值在左半部分
                    right = mid - 1;
                }
            }
        }
        return -1;
    }
}
```

**为什么必须满足条件 `nums[0] <= target` ？**

为了确保目标值在左半部分

假设输入[4,5,6,7,0,1,2] 0，此时target < nums[mid] == 7 但是 nums[0] == 4 > target，将会错判 0 在左边

### [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)

![image-20230422205020950](https://cdn.jsdelivr.net/gh/cmty256/imgs-blog@main/basics/image-20230422205020950.4dkfgkuw3r20.webp)

```java
class Solution { // 时间复杂度 O(n)
    public int[] searchRange(int[] nums, int target) {
        int[] res = {-1,-1};
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] == target) {
                res[0] = i;
                break;
            }
        }
        for (int j = nums.length - 1; j >= 0; j--) {
            if (nums[j] == target) {
                res[1] = j;
                break;
            }
        }
        return res;
    }
}
```



### [36. 有效的数独](https://leetcode.cn/problems/valid-sudoku/)

![image-20230422204910639](https://cdn.jsdelivr.net/gh/cmty256/imgs-blog@main/basics/image-20230422204910639.3zekzd8w3ia0.webp)

![image-20230422204932609](https://cdn.jsdelivr.net/gh/cmty256/imgs-blog@main/basics/image-20230422204932609.4ad85n255yi0.webp)

```java
class Solution {
    public boolean isValidSudoku(char[][] board) {
        // 行
        int[][] rows = new int [9][9];
        // 列
        int[][] columns = new int[9][9];
        // 九宫格
        int [][][] area = new int[3][3][9];
        
        // 第 i 行
        for (int i = 0; i < 9; i++) {
            // 第 j 列
            for (int j = 0; j < 9; j++) {
                char c = board[i][j];
                // 如果当前位置不为空格，说明当前位置有数字
                if (c != '.') {
                    // 计算数字在数组中的索引（从0开始）
                    int index = c - '0' - 1;
                    // 将数字出现次数加1
                    rows[i][index]++;
                    columns[j][index]++;
                    area[i / 3][j / 3][index]++;
                    // 如果当前数字在当前行、当前列或当前九宫格中出现了2次以上，说明数独            不合法，直接返回false
                    if (rows[i][index] > 1 || columns[j][index] > 1 || area[i / 3][j / 3][index] > 1) {
                        return false;
                    }
                }
            }
        }
        return true;
    }
}
```

### [39. 组合总和](https://leetcode.cn/problems/combination-sum/)

![image-20230424210104086](https://cdn.jsdelivr.net/gh/cmty256/imgs-blog@main/basics/image-20230424210104086.5c5b5l1e9qg0.webp)

```java
class Solution {
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        int len = candidates.length;
        List<List<Integer>> res = new ArrayList<>(); // 定义结果列表
        if (len == 0) { // 如果候选数组为空，则直接返回空列表
            return res;
        }
        // 回溯 + 剪枝提速
        Arrays.sort(candidates); // 对候选数组进行排序，为后面的剪枝操作做准备
        Deque<Integer> path = new ArrayDeque<>(); // 定义双端队列，用于保存搜索路径
        dfs(candidates, 0, len, target, path, res); // 调用深度优先搜索方法
        return res; // 返回结果列表
    }
    // 深度优先搜索方法，接收候选数组、起始位置、数组长度、目标值、当前搜索路径和结果列表作为参数
    private void dfs(int[] candidates, int begin, int len, int target, Deque<Integer> path, List<List<Integer>> res) {
        // 由于进入更深层的时候，小于 0 的部分被剪枝，因此递归终止条件值只判断等于 0 的情况
        if (target == 0) { // 如果目标值等于 0，说明找到了一组解，将当前搜索路径添加到结果列表中
            res.add(new ArrayList<>(path));
            return; // 返回
        }
        // 遍历候选数组中从起始位置开始的所有元素
        for (int i = begin; i < len; i++) {
            // 如果当前元素比目标值大，则直接退出循环（剪枝操作）
            if (target - candidates[i] < 0) {
                break;
            }
            path.addLast(candidates[i]); // 将当前元素添加到搜索路径的末尾
            dfs(candidates, i, len, target - candidates[i], path, res); // 递归调用深度优先搜索方法
            path.removeLast(); // 将当前元素从搜索路径的末尾删除，继续遍历下一个元素
        }
    }
}
```

>其中，path.removeLast(); 删除了哪个数?
>
>`path.removeLast()` 是将搜索路径 `path` 的末尾元素删除，也就是删除最后一个添加到路径中的元素，这个元素是上一个循环中添加到路径中的元素。可以理解为，每次进入下一层递归时，都会将当前元素添加到路径中，然后进行递归搜索；当递归返回时，需要将当前元素从路径中删除，回到上一层递归。因此，`path.removeLast()` 删除的是上一个递归中添加到路径中的元素。**(比如 [2,2,3] 删除 3，一步步删)**

树形图：

![image-20230424235238800](https://cdn.jsdelivr.net/gh/cmty256/imgs-blog@main/basics/image-20230424235238800.1i7h39i104dc.webp)

## 困难

### [4. 寻找两个正序数组的中位数](https://leetcode.cn/problems/median-of-two-sorted-arrays/)

#### 何为分治？

**分治**（Divide and Conquer）是一种算法设计策略，它将问题划分为更小的子问题，然后解决子问题并将它们的结果合并以获得原始问题的解。分治算法通常包括三个步骤：分解（Divide）、解决（Conquer）和合并（Combine）。在分治算法中，问题被逐步划分成更小的子问题，然后对子问题进行递归求解，最后将子问题的解合并起来得到原始问题的解。

#### 何为二分查找？

**二分查找**是一种在有序数组中查找特定元素的算法。它通过将目标值与数组的中间元素进行比较，然后根据比较结果缩小查找范围，逐步逼近目标值。如果中间元素等于目标值，则查找成功；如果中间元素大于目标值，则在数组的左半部分继续查找；如果中间元素小于目标值，则在数组的右半部分继续查找。通过不断缩小查找范围，最终可以找到目标值或确定目标值不存在于数组中。

#### 题解

```java
/**
 * 寻找两个正序数组的中位数 -- 数组, 二分查找, 分治
 *
 * @author 沉梦听雨
 **/
@SuppressWarnings("all")
public class _4_寻找两个正序数组的中位数 {

    // 算法的时间复杂度应该为 O(log (m+n))

    /**
     * 1、合并有序数组并找到中位数 -- 2ms(33.34%), 43.8MB(7.71%)
     * <p>
     * 时间复杂度为 O(m + n)，空间复杂度为 O(m + n)
     */
    class Solution1 {
        public double findMedianSortedArrays(int[] nums1, int[] nums2) {
            int len1 = nums1.length;
            int len2 = nums2.length;
            int[] nums = new int[len1 + len2];
            int i = 0;
            int j = 0;
            int k = 0;
            while (i < len1 && j < len2) {
                if (nums1[i] < nums2[j]) {
                    nums[k] = nums1[i];
                    i++;
                } else {
                    nums[k] = nums2[j];
                    j++;
                }
                k++;
            }
            while (i < len1) {
                nums[k] = nums1[i];
                i++;
                k++;
            }
            while (j < len2) {
                nums[k] = nums2[j];
                j++;
                k++;
            }
            if (nums.length % 2 != 0) {
                return (double) nums[nums.length / 2];
            } else {
                int pre = nums[nums.length / 2 - 1];
                int mid = nums[nums.length / 2];
                return (pre + mid) / 2.0;
            }
        }
    }

    /**
     * 2、分治 -- 1ms(100%), 43.8MB(9.44%)
     * <p>
     * 时间复杂度为 O( log(m + n) ), 空间复杂度为 O( log(m + n) )
     */
    class Solution2 {
        private int m;
        private int n;
        private int[] nums1;
        private int[] nums2;

        public double findMedianSortedArrays(int[] nums1, int[] nums2) {
            m = nums1.length;
            n = nums2.length;
            this.nums1 = nums1;
            this.nums2 = nums2;
            int a = f(0, 0, (m + n + 1) / 2); // 找到中位数左边的元素
            int b = f(0, 0, (m + n + 2) / 2); // 找到中位数右边的元素
            return (a + b) / 2.0; // 返回中位数
        }

        private int f(int i, int j, int k) {
            if (i >= m) {
                return nums2[j + k - 1]; // nums1 数组已经遍历完，返回 nums2 数组中对应位置的元素
            }
            if (j >= n) {
                return nums1[i + k - 1]; // nums2 数组已经遍历完，返回 nums1 数组中对应位置的元素
            }
            if (k == 1) {
                return Math.min(nums1[i], nums2[j]); // 达到中位数位置，返回两个数组当前位置上较小的元素
            }
            int p = k / 2; // 将 k 分成两部分
            int x = i + p - 1 < m ? nums1[i + p - 1] : 1 << 30; // 获取 nums1 数组中第 p 个元素，如果超出数组范围，设置为一个较大的值
            int y = j + p - 1 < n ? nums2[j + p - 1] : 1 << 30; // 获取 nums2 数组中第 p 个元素，如果超出数组范围，设置为一个较大的值
            return x < y ? f(i + p, j, k - p) : f(i, j + p, k - p); // 如果 x 小于 y，则在 nums1 数组的右侧或者 nums2 数组的左侧继续查找，否则在 nums2 数组的右侧或者 nums1 数组的左侧继续查找
        }
    }
}
```

### 。
