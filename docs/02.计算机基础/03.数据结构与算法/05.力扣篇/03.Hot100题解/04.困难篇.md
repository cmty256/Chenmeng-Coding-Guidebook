---
title: 困难篇
date: 2023-12-14 14:26:31
permalink: /pages/c28479/
author: 
  name: 沉梦听雨
  link: https://gitee.com/dream-deeply-tyu
---
# 困难篇

## [4. 寻找两个正序数组的中位数](https://leetcode.cn/problems/median-of-two-sorted-arrays/)

### 何为分治？

**分治**（Divide and Conquer）是一种算法设计策略，它将问题划分为更小的子问题，然后解决子问题并将它们的结果合并以获得原始问题的解。分治算法通常包括三个步骤：分解（Divide）、解决（Conquer）和合并（Combine）。在分治算法中，问题被逐步划分成更小的子问题，然后对子问题进行递归求解，最后将子问题的解合并起来得到原始问题的解。

### 何为二分查找？

**二分查找**是一种在有序数组中查找特定元素的算法。它通过将目标值与数组的中间元素进行比较，然后根据比较结果缩小查找范围，逐步逼近目标值。如果中间元素等于目标值，则查找成功；如果中间元素大于目标值，则在数组的左半部分继续查找；如果中间元素小于目标值，则在数组的右半部分继续查找。通过不断缩小查找范围，最终可以找到目标值或确定目标值不存在于数组中。

### 题解

```java
/**
 * 寻找两个正序数组的中位数 -- 数组, 二分查找, 分治
 *
 * @author 沉梦听雨
 **/
@SuppressWarnings("all")
public class _4_寻找两个正序数组的中位数 {

    // 算法的时间复杂度应该为 O(log (m+n))

    /**
     * 1、合并有序数组并找到中位数 -- 2ms(33.34%), 43.8MB(7.71%)
     * <p>
     * 时间复杂度为 O(m + n)，空间复杂度为 O(m + n)
     */
    class Solution1 {
        public double findMedianSortedArrays(int[] nums1, int[] nums2) {
            int len1 = nums1.length;
            int len2 = nums2.length;
            int[] nums = new int[len1 + len2];
            int i = 0;
            int j = 0;
            int k = 0;
            while (i < len1 && j < len2) {
                if (nums1[i] < nums2[j]) {
                    nums[k] = nums1[i];
                    i++;
                } else {
                    nums[k] = nums2[j];
                    j++;
                }
                k++;
            }
            while (i < len1) {
                nums[k] = nums1[i];
                i++;
                k++;
            }
            while (j < len2) {
                nums[k] = nums2[j];
                j++;
                k++;
            }
            if (nums.length % 2 != 0) {
                return (double) nums[nums.length / 2];
            } else {
                int pre = nums[nums.length / 2 - 1];
                int mid = nums[nums.length / 2];
                return (pre + mid) / 2.0;
            }
        }
    }

    /**
     * 2、分治 -- 1ms(100%), 43.8MB(9.44%)
     * <p>
     * 时间复杂度为 O( log(m + n) ), 空间复杂度为 O( log(m + n) )
     */
    class Solution2 {
        private int m;
        private int n;
        private int[] nums1;
        private int[] nums2;

        public double findMedianSortedArrays(int[] nums1, int[] nums2) {
            m = nums1.length;
            n = nums2.length;
            this.nums1 = nums1;
            this.nums2 = nums2;
            int a = f(0, 0, (m + n + 1) / 2); // 找到中位数左边的元素
            int b = f(0, 0, (m + n + 2) / 2); // 找到中位数右边的元素
            return (a + b) / 2.0; // 返回中位数
        }

        private int f(int i, int j, int k) {
            if (i >= m) {
                return nums2[j + k - 1]; // nums1 数组已经遍历完，返回 nums2 数组中对应位置的元素
            }
            if (j >= n) {
                return nums1[i + k - 1]; // nums2 数组已经遍历完，返回 nums1 数组中对应位置的元素
            }
            if (k == 1) {
                return Math.min(nums1[i], nums2[j]); // 达到中位数位置，返回两个数组当前位置上较小的元素
            }
            int p = k / 2; // 将 k 分成两部分
            int x = i + p - 1 < m ? nums1[i + p - 1] : 1 << 30; // 获取 nums1 数组中第 p 个元素，如果超出数组范围，设置为一个较大的值
            int y = j + p - 1 < n ? nums2[j + p - 1] : 1 << 30; // 获取 nums2 数组中第 p 个元素，如果超出数组范围，设置为一个较大的值
            return x < y ? f(i + p, j, k - p) : f(i, j + p, k - p); // 如果 x 小于 y，则在 nums1 数组的右侧或者 nums2 数组的左侧继续查找，否则在 nums2 数组的右侧或者 nums1 数组的左侧继续查找
        }
    }
}
```

## 10. 正则表达式匹配

主要思路是使用**动态规划**方法。

### 思路如下

1. 首先，定义一个二维布尔数组 dp，其中 `dp[i][j]` 表示 s 的前 i 个字符是否与 p 的前 j 个字符匹配。
2. 然后，初始化 dp 数组，根据 p 的偶数位置是否为 * 来确定 `dp[0][j]` 的值。
3. 接下来，遍历 s 和 p，根据 p 的当前字符是否为 * 来更新 dp 数组的值。
4. 最后，返回 `dp[m][n]`，即 s 和 p 是否匹配。

### 具体实现过程如下

1. 定义一个二维布尔数组 dp，用于存储 s 和 p 的匹配情况。
2. 初始化 dp 数组的第一列，根据 p 的偶数位置是否为 * 来确定 `dp[0][j]` 的值。
3. 遍历 s 和 p，根据 p 的当前字符是否为 * 来更新 dp 数组的值。
   - 如果 p 的当前字符是 *，则 `dp[i][j]` 的值可以由 `dp[i][j-2]`（不使用 *）或 `dp[i-1][j]`（使用 *）转移而来。
   - 否则，`dp[i][j]` 的值可以由 `dp[i-1][j-1]`（当前字符匹配）或 `dp[i-1][j-1]`（当前字符不匹配但 p 的当前字符为 .）转移而来。
4. 返回 `dp[m][n]`，即 s 和 p 是否匹配。

### 代码如下

```java
    /**
     * 1、动态规划 -- 1ms(100%), 39.79MB(85.76%)
     * <p>
     * 时间复杂度为 O(m * n)，空间复杂度为 O(m * n)
     */
    class Solution {
        public boolean isMatch(String s, String p) {
            int m = s.length();
            int n = p.length();

            // 初始化dp数组，dp[i][j]表示s的前i个字符是否与p的前j个字符匹配
            boolean[][] dp = new boolean[m + 1][n + 1];
            // 初始化 dp[o][o]= true 表示空字符串和空正则表达式是匹配的。
            dp[0][0] = true;

            // 初始化第一行，如果p的偶数位置是*，则dp[0][j] = dp[0][j - 2]
            for (int j = 2; j <= n; j += 2) {
                dp[0][j] = dp[0][j - 2] && p.charAt(j - 1) == '*';
            }

            // 遍历s和p，动态规划
            for (int i = 1; i <= m; i++) {
                for (int j = 1; j <= n; j++) {
                    // 如果p的当前字符是*，则dp[i][j] = dp[i][j - 2] || (dp[i - 1][j] && (s[i - 1] == p[j - 2] || p[j - 2] == '.'))
                    if (p.charAt(j - 1) == '*') {
                        // 考虑了 * 匹配 0 次和匹配至少 1 次的情况
                        dp[i][j] = dp[i][j - 2] || (dp[i - 1][j] && (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.'));
                    } else {
                        // 否则，dp[i][j] = dp[i - 1][j - 1] && (s[i - 1] == p[j - 1] || p[j - 1] == '.')
                        // 处理普通字符匹配的情况，确保了当前位置的匹配状态
                        dp[i][j] = dp[i - 1][j - 1] && (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.');
                    }
                }
            }

            // 返回dp[m][n]
            return dp[m][n];
        }
    }
```

### 问题

> 初始化第一列，如果 p 的偶数位置是 ，则 `dp[0][j] = dp[0][j - 2]`。为什么？

**这是因为正则表达式中的 `*` 表示前面的字符可以重复零次或多次。**

所以，当 `*` 出现在偶数位置时，它前面的字符可以被忽略，即重复零次。

让我们以一个例子来说明：

- 假设正则表达式 `p` 为 `a*b*cd`，而目标字符串 `s` 为 `acd`。
- 在这个例子中，`a*` 中的 `a` 可以重复零次，即可以没有 `a`。同样，`b*` 中的 `b` 也可以重复零次，即可以没有 `b`。因此，正则表达式可以匹配目标字符串。
- 对应到动态规划数组中，`dp[0][j]` 表示【空字符串】是否能够匹配 `p` 的前 `j` 个字符。
- 如果 `p[j-1]` 是 `*`（偶数位置），则 `*` 可以表示零次，所以 `dp[0][j]` 的值可以参考 `dp[0][j-2]`，即忽略 `*` 及其前面的字符。
- 这样的初始化保证了在动态规划的过程中，即使出现 `*`，也会考虑到它可以重复零次的情况，从而正确地判断正则表达式是否匹配目标字符串。

> 动态规划

使用两个嵌套的循环遍历 s 和 p，根据字符匹配规则更新动态规划数组。

1. **对于 `*` 的情况**，根据前面的状态进行更新；
   - `dp[i][j - 2]`：表示忽略掉 `p` 的 `*` 和前面的字符，相当于 `*` 匹配了 0 次。例如，对于 `s = "abc"`，`p = "ab*c"`，这里的 `*` 匹配了 0 次。
   - `dp[i - 1][j] && (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.')`：表示 `*` 匹配了至少 1 次，且 `s` 的当前字符与 `*` 前面的字符相同，或者 `*` 前面的字符是 `.`（可以匹配任意字符）。
   - 例如，对于 `s = "aa"`，`p = "a*"`，这里的 `*` 匹配了 2 次。
2. **对于其他字符的情况**，则根据单字符匹配规则更新。
   - `dp[i - 1][j - 1]`：表示 `s` 的前 `i - 1` 个字符和 `p` 的前 `j - 1` 个字符已经匹配，此时判断当前字符是否匹配。
   - `(s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.')`：表示当前字符匹配的条件，即 `s` 的第 `i - 1` 个字符与 `p` 的第 `j - 1` 个字符相同，或者 `p` 的第 `j - 1` 个字符是 `.`（可以匹配任意字符）。
   - 否则，`dp[i][j] = false`。

## [42. 接雨水](https://leetcode.cn/problems/trapping-rain-water/)

### 题目描述

给定 `n` 个非负整数表示每个宽度为 `1` 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

![image](https://cmty256.github.io/imgs-blog/basics/image.5ucaj4vomxo0.webp)

### 方法一：双指针

```java
    /**
     * 1、双指针 -- 0ms(100.00%), 43.96MB(5.09%)
     * <p>
     * 时间复杂度为 O(n)
     * <p>
     * 空间复杂度为 O(1)
     */
    class Solution {
        public int trap(int[] height) {
            int res = 0;
            // 定义左指针和右指针
            int left = 0, right = height.length - 1;
            // 初始化左右两边的最大高度
            int leftMax = 0, rightMax = 0;

            // 分别记录左右两边的最大高度
            while (left < right) {
                // 记录当前左边的最大高度
                leftMax = Math.max(leftMax, height[left]);
                // 记录当前右边的最大高度
                rightMax = Math.max(rightMax, height[right]);
                // 比较左右两边的最大高度，并记录
                if (height[left] < height[right]) {
                    res += leftMax - height[left];
                    left++;
                } else {
                    res += rightMax - height[right];
                    right--;
                }
            }

            return res;
        }
    }
```



#### 代码解析

在这个问题中，为了计算接雨水的数量，我们需要找到每个位置上能够容纳的雨水量。**这个雨水量实际上是由当前位置的高度和其左右两侧的最大高度中较小的一个决定的。**

在算法的实现中，使用了两个指针 `left` 和 `right`，分别指向数组的起始和结束位置。同时，维护两个变量 `leftMax` 和 `rightMax` 分别表示左边和右边的最大高度。在每一步迭代中，选择左右两侧中较小的最大高度，然后减去当前位置的高度，得到的差值即为当前位置能够容纳的雨水量。

为什么要选择较小的最大高度呢？这是因为如果我们选择较大的最大高度，那么当前位置可能会被左右两侧较小的高度所限制，导致计算得到的雨水量可能超过实际的容量。因此，为了确保计算的准确性，我们选择较小的最大高度来计算雨水量。

具体的判断逻辑如下：

1. 如果 `height[left] < height[right]`，则计算并累加雨水量 `res += leftMax - height[left]`，因为左边的最大高度限制了当前位置的容纳能力。
2. 如果 `height[left] >= height[right]`，则计算并累加雨水量 `res += rightMax - height[right]`，因为右边的最大高度限制了当前位置的容纳能力。

这样的选择确保了在移动指针的过程中，我们始终使用较小的最大高度来计算雨水量，从而得到准确的结果。



### 方法二：动态规划

```java
    /**
     * 2、动态规划 -- 1ms(75.87%), 42.92MB(80.95%)
     * <p>
     * 时间复杂度为 O(n)
     * <p>
     * 空间复杂度为 O(n)
     */
    class Solution {
        public int trap(int[] height) {
            // 获取数组长度
            int n = height.length;
            // 创建两个数组，分别用于存储左侧最大值和右侧最大值
            int[] left = new int[n];
            int[] right = new int[n];
            // 初始化边界值
            left[0] = height[0];
            right[n - 1] = height[n - 1];

            // 遍历数组，计算左侧最大值和右侧最大值
            for (int i = 1; i < n; ++i) {
                // 从左到右
                left[i] = Math.max(left[i - 1], height[i]);
                // 从右到左
                right[n - 1 - i] = Math.max(right[n - i], height[n - 1 - i]);
            }

            // 初始化结果变量
            int res = 0;
            // 遍历数组，计算雨水量
            for (int i = 0; i < n; ++i) {
                res += Math.min(left[i], right[i]) - height[i];
            }
            // 返回雨水量
            return res;
        }
    }
```



#### 代码解析

这个解法与前面的双指针方法不同，这里通过动态规划来**预先计算每个位置左右两侧的最大高度**，然后再遍历一次数组计算雨水量。

以下是代码的主要步骤：

1. 创建两个数组 `left` 和 `right`，分别用于存储每个位置的左侧最大值和右侧最大值。

2. 初始化 `left[0]` 为 `height[0]`，表示数组的第一个元素的左侧最大值即为自身的高度。

3. 初始化 `right[n - 1]` 为 `height[n - 1]`，表示数组的最后一个元素的右侧最大值即为自身的高度。

4. 使用一个循环，

   - 从左向右遍历数组，计算每个位置的左侧最大值并存储到数组 `left` 中。

   - 从右向左遍历数组，计算每个位置的右侧最大值并存储到数组 `right` 中。

5. 初始化结果变量 `res` 为零。

6. 再次遍历数组，计算每个位置的雨水量，并累加到 `res` 中。计算方法为取左右两侧最大值中的较小值减去当前位置的高度。

7. 返回最终的雨水量 `res`。

这种动态规划的方法通过预先计算左右两侧的最大值，避免了在每个位置都进行比较的过程，从而降低了时间复杂度。这个算法的时间复杂度为 O(n)，空间复杂度为 O(n)。



#### 动态规划的体现

这段代码使用了动态规划的思想来解决接雨水问题。**动态规划的关键在于将问题分解为子问题，并使用已解决的子问题的解来构建原问题的解。**

*具体来说，这里的动态规划包括以下步骤：*

1. **左右最大值数组的构建：** 首先，通过遍历数组，分别构建两个数组 `left` 和 `right`，其中 `left[i]` 表示元素 `height[i]` 左侧的最大值，`right[i]` 表示元素 `height[i]` 右侧的最大值。
2. **计算雨水量：** 一旦得到了左侧和右侧的最大值数组，就可以通过遍历数组，计算每个位置上的雨水量。对于每个位置 `i`，可以通过取 `min(left[i], right[i]) - height[i]` 来计算在该位置上可以蓄积的雨水量。
3. **累加雨水量：** 将每个位置上计算得到的雨水量进行累加，得到最终的总雨水量。

这里的动态规划思想在于先解决子问题（构建左右最大值数组），然后通过这些子问题的解构建原问题的解（计算雨水量）。这有助于减小问题的复杂度，并使问题更容易理解和解决。
