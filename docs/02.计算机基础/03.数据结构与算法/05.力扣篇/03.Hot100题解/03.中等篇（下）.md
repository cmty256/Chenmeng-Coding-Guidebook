---
title: 中等篇（下）
date: 2023-12-15 14:38:11
permalink: /pages/33df04/
author: 
  name: 沉梦听雨
  link: https://gitee.com/dream-deeply-tyu
---
# 中等篇（下）

## [128. 最长连续序列](https://leetcode.cn/problems/longest-consecutive-sequence/)

### 题目描述

```java
    /* 给定一个未排序的整数数组 nums，
       找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。
       请你设计并实现时间复杂度为 O(n) 的算法解决此问题。 */
```

### 方法一：排序

```java
    /**
     * 1、排序 -- 12ms(95.50%), 55.59MB(61.59%)
     * <p>
     * 时间复杂度为 O(n * logn)
     * 空间复杂度为 O(logn)
     */
    class Solution {
        public int longestConsecutive(int[] nums) {
            int len = nums.length;
            if (len < 2) {
                return len;
            }

            // 对数组进行排序
            Arrays.sort(nums);
            // 最长序列
            int res = 0;
            // 当前连续序列长度
            int sum = 0;

            // 遍历数组
            for (int i = 0; i < len; i++) {

                // 如果当前元素和下一个元素差1，则sum+1，更新res
                if ((i + 1) < len && nums[i + 1] == (nums[i] + 1)) {
                    sum += 1;
                    res = Math.max(res, sum);
                    // 如果当前元素和下一个元素相等，则跳过
                } else if ((i + 1) < len && nums[i + 1] == (nums[i])) {
                    continue;
                    // 如果当前元素和下一个元素不相等，则sum+1，更新res
                } else {
                    sum += 1;
                    res = Math.max(res, sum);
                    // 重置sum
                    sum = 0;
                }
            }

            return res;
        }
    }
```

### 方法二：哈希表

```java
    /**
     * 2、哈希表官方题解 -- -- 25ms(77.71%), 60.17MB(27.24%)
     * <p>
     * 时间复杂度为 O(n)
     * 空间复杂度为 O(n)
     */
   class Solution {
        public int longestConsecutive(int[] nums) {
            // 创建一个HashSet，用于存储数组中的元素
            Set<Integer> num_set = new HashSet<Integer>();
            // 遍历数组，将数组中的元素添加到HashSet中
            for (int num : nums) {
                num_set.add(num);
            }

            // 定义一个变量，用于存储最长连续序列的长度
            int longestStreak = 0;

            // 遍历HashSet，查找连续序列的最大长度
            for (int num : num_set) {
                // 如果HashSet中不包含num-1，则表示当前元素是连续序列的第一个元素
                if (!num_set.contains(num - 1)) {
                    // 定义一个变量，用于存储当前连续序列的长度
                    int currentNum = num;
                    int currentStreak = 1;

                    // 遍历当前元素，查找连续序列的最大长度
                    while (num_set.contains(currentNum + 1)) {
                        currentNum += 1;
                        currentStreak += 1;
                    }

                    // 将当前连续序列的长度与最长连续序列的长度进行比较，取最大值
                    longestStreak = Math.max(longestStreak, currentStreak);
                }
            }

            // 返回最长连续序列的长度
            return longestStreak;
        }
    }
```



## [438. 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)

### 题目描述

给定两个字符串 `s` 和 `p`，找到 `s` 中所有 `p` 的 **异位词** 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。

**异位词** 指由相同字母重排列形成的字符串（包括相同的字符串）。



**示例 1:**

```
输入: s = "cbaebabacd", p = "abc"
输出: [0,6]
解释:
起始索引等于 0 的子串是 "cba", 它是 "abc" 的异位词。
起始索引等于 6 的子串是 "bac", 它是 "abc" 的异位词。
```

**示例 2:**

```
输入: s = "abab", p = "ab"
输出: [0,1,2]
解释:
起始索引等于 0 的子串是 "ab", 它是 "ab" 的异位词。
起始索引等于 1 的子串是 "ba", 它是 "ab" 的异位词。
起始索引等于 2 的子串是 "ab", 它是 "ab" 的异位词。
```



### 方法一：滑动窗口（双指针+哈希表）

```java
    /**
     * 1、滑动窗口（双指针+哈希表） -- 38ms(26.77%), 42.73MB(62.58%)
     * <p>
     * 时间复杂度为 O(p + s), p 是字符串 p 的长度, s是字符串 s 的长度
     * <p>
     * 空间复杂度为 O(p), p 是字符串 p 的长度
     */
    class Solution {
        public List<Integer> findAnagrams(String s, String p) {
            List<Integer> result = new ArrayList<>();

            // 存储目标字符串 p 中每个字符的出现次数
            HashMap<Character, Integer> targetFreqMap = new HashMap<>();
            for (char c : p.toCharArray()) {
                targetFreqMap.put(c, targetFreqMap.getOrDefault(c, 0) + 1);
            }

            int pLen = p.length();
            int left = 0, right = 0, count = pLen;

            while (right < s.length()) {
                char currentChar = s.charAt(right);

                // 如果当前字符是目标字符串 p 中的字符，更新 count
                if (targetFreqMap.containsKey(currentChar) && targetFreqMap.get(currentChar) > 0) {
                    count--;
                }

                // 更新目标字符串中当前字符的出现次数
                targetFreqMap.put(currentChar, targetFreqMap.getOrDefault(currentChar, 0) - 1);

                // 移动右指针
                right++;

                // 当 count 等于 0 时，表示找到一个合法的字母异位词
                if (count == 0) {
                    result.add(left);
                }

                // 当窗口大小等于目标字符串长度时，左指针右移，恢复 count 和频率表
                if (right - left == pLen) {
                    char leftChar = s.charAt(left);

                    // 恢复 count
                    if (targetFreqMap.containsKey(leftChar) && targetFreqMap.get(leftChar) >= 0) {
                        count++;
                    }

                    // 恢复频率表
                    targetFreqMap.put(leftChar, targetFreqMap.getOrDefault(leftChar, 0) + 1);

                    // 移动左指针
                    left++;
                }
            }

            return result;
        }
    }
```



#### 代码解析

这个解法使用了滑动窗口的思想，通过维护一个窗口，在窗口内判断是否为字母异位词。

下面是该解法的逻辑解释：

1. **初始化：** 首先，构建目标字符串 `p` 的字符频率表 `targetFreqMap`，用于存储每个字符在目标字符串中的出现次数。
2. **滑动窗口：** 使用两个指针 `left` 和 `right` 维护一个窗口，表示当前处理的子字符串。初始化时，窗口大小为目标字符串 `p` 的长度。还有一个计数器 `count`，表示当前窗口中还需要找到的字符的数量。
3. **移动右指针：** 逐步右移 `right` 指针，更新窗口内字符的频率信息。对于每个右移的字符，检查它是否在目标字符串 `p` 的频率表中，并且它的频率是否大于 0。如果是，将 `count` 减一，表示找到了一个符合条件的字符。
4. **找到异位词：** 当 `count` 等于 0 时，表示当前窗口内的字符与目标字符串 `p` 中的字符构成了一个字母异位词，将当前左指针 `left` 的位置加入结果列表。
5. **移动左指针：** 当窗口大小等于目标字符串长度时，左指针右移。在右移之前，检查离开窗口的字符，如果它是目标字符串中的字符，将 `count` 恢复，并更新频率表。
6. **重复过程：** 重复上述过程，直到右指针 `right` 移动到字符串 `s` 的末尾。

通过这种方式，可以有效地在字符串 `s` 中找到所有与目标字符串 `p` 是字母异位词的子串的起始位置。这个算法的时间复杂度为 O(p + s)，其中 p 是字符串 `p` 的长度，s 是字符串 `s` 的长度。空间复杂度为 O(p)。



### 方法二：滑动窗口优化版（双指针+数组）

```java
    /**
     * 2、滑动窗口优化版（双指针+数组） -- 4ms(98.83%), 42.32MB(97.00%)
     * <p>
     * 时间复杂度为 O(m + n), m 是字符串 s 的长度, n 是字符串 p 的长度
     * <p>
     * 空间复杂度为 O(C), C 是字符集大小, 即 C = 26
     */
    class Solution {
        public List<Integer> findAnagrams(String s, String p) {
            // 计算s和p的长度
            int m = s.length(), n = p.length();
            // 创建一个存储结果的列表
            List<Integer> res = new ArrayList<>();
            // 如果s的长度小于p的长度，则直接返回空列表
            if (m < n) {
                return res;
            }
            // 创建一个长度为26的数组，用来存储p中每个字符出现的次数
            int[] cnt1 = new int[26];
            // 遍历p，将每个字符出现的次数存入cnt1中
            for (int i = 0; i < n; ++i) {
                cnt1[p.charAt(i) - 'a']++;
            }
            // 创建一个长度为26的数组，用来存储s中每个字符出现的次数
            int[] cnt2 = new int[26];
            // 遍历s，将每个字符出现的次数存入cnt2中
            for (int i = 0, j = 0; i < m; ++i) {
                int k = s.charAt(i) - 'a';
                cnt2[k]++;
                // 如果cnt2中某个字符出现的次数大于cnt1中对应字符出现的次数，则将cnt2中对应字符出现的次数减1，并且j自增1
                while (cnt2[k] > cnt1[k]) {
                    cnt2[s.charAt(j++) - 'a']--;
                }
                // 如果i - j + 1等于n，则将j的值存入res中
                if (i - j + 1 == n) {
                    res.add(j);
                }
            }
            // 返回res
            return res;
        }
    }
```



#### 代码解析

这个解法同样使用了滑动窗口的思想，不同之处在于**优化了空间复杂度**，使用了长度为 26 的数组 `cnt1` 和 `cnt2` 代替哈希表，用来存储字符的频率信息。

下面是该解法的逻辑解释：

1. **初始化：** 创建两个长度为 26 的数组 `cnt1` 和 `cnt2`，用来分别存储字符串 `p` 和字符串 `s` 中每个字符的频率信息。
2. **遍历字符串 p：** 遍历字符串 `p`，将每个字符出现的次数存入 `cnt1` 中。
3. **遍历字符串 s：** 在遍历字符串 `s` 的同时，维护一个窗口，通过更新 `cnt2` 数组来表示窗口中字符的频率。
4. **滑动窗口：**
   - 对于每个右移的字符，将 `cnt2` 中对应字符的频率加一。
   - 如果某个字符的频率在 `cnt2` 中超过了 `cnt1` 中对应字符的频率，说明这个字符在当前窗口中出现次数过多，需要左移窗口的左边界，即增大 `j`。
   - 左移窗口的同时，更新 `cnt2` 中左边界字符的频率。
   - 如果窗口大小等于字符串 `p` 的长度，说明找到了一个字母异位词，将窗口的左边界 `j` 存入结果列表。
5. **返回结果：** 返回存储结果的列表。

通过这种方式，代码实现了在字符串 `s` 中找到所有与目标字符串 `p` 是字母异位词的子串的起始位置。这个算法的时间复杂度为 O(m + n)，其中 m 是字符串 `s` 的长度，n 是字符串 `p` 的长度。空间复杂度为 O(26)，即 O(1)，因为字符集的大小是固定的。



## [560. 和为 K 的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/)

### 题目描述

给你一个整数数组 `nums` 和一个整数 `k` ，请你统计并返回 *该数组中和为 `k` 的子数组的个数* 。

子数组是数组中元素的连续非空序列。

 

**示例 1：**

```
输入：nums = [1,1,1], k = 2
输出：2
```

**示例 2：**

```
输入：nums = [1,2,3], k = 3
输出：2
```



### 方法一：暴力解法

```java
    /**
     * 1、暴力解法 -- 1606ms(31.36%), 44.44MB(53.38%)
     * <p>
     * 时间复杂度分析：O(n^2)，其中 n 是数组的长度。
     * <p>
     * 空间复杂度分析：O(1)。
     */
    public class Solution {
        public int subarraySum(int[] nums, int k) {
            int count = 0;
            int len = nums.length;

            for (int left = 0; left < len; left++) {
                int sum = 0;
                for (int right = left; right < len; right++) {
                    sum += nums[right];
                    if (sum == k) {
                        count++;
                    }
                }
            }

            return count;
        }
    }
```



### 方法二：前缀和 + 哈希表

```java
    /**
     * 2、前缀和 + 哈希表 -- 25ms(54.20%), 46.03MB(5.03%)
     * <p>
     * 时间复杂度：O(n)。
     * <p>
     * 空间复杂度为：O(n)。
     */
    class Solution {
        public int subarraySum(int[] nums, int k) {
            // 创建一个哈希表，用于存储前缀和及其出现的次数
            Map<Integer, Integer> counter = new HashMap<>();
            // 初始化哈希表，表示前缀和为 0 出现了 1 次
            counter.put(0, 1);
            // 初始化答案为 0，s 用于表示当前的前缀和
            int ans = 0, s = 0;

            // 遍历数组 nums 中的每个元素
            for (int num : nums) {
                // 计算当前的前缀和
                s += num;

                // 更新答案，如果存在前缀和为 (s - k) 的情况，累加对应次数到答案中
                ans += counter.getOrDefault(s - k, 0);

                // 更新哈希表，记录当前前缀和出现的次数
                counter.put(s, counter.getOrDefault(s, 0) + 1);
            }

            // 返回最终答案
            return ans;
        }
    }
```



#### 代码分析

1. 这个算法的关键思想是通过维护前缀和的累加和哈希表，记录前缀和出现的次数。
2. 在遍历数组时，对于当前前缀和 `s`，如果存在 `s - k` 出现过，那么就说明在这之前有子数组的和为 `k`，累加对应的次数到答案中。
3. 最后，更新哈希表，记录当前前缀和的次数。



#### 什么是前缀和？

前缀和与子数组的个数之间存在着紧密的关系，尤其在解决子数组和相关问题时。

> 前缀和是指从数组起始位置开始，到数组中某个位置的所有元素之和。

以下是关于前缀和和子数组个数之间的关系的解释：

1. **前缀和数组：** 给定数组 `nums`，可以计算前缀和数组 `prefixSum`，其中 `prefixSum[i]` 表示数组前 `i` 个元素的和。形式化地，`prefixSum[i] = nums[0] + nums[1] + ... + nums[i-1]`。
2. **子数组和：** 对于数组 `nums` 中的任意子数组 `[i, j]`，其和可以通过前缀和数组计算得到。子数组和为 `nums[i] + nums[i+1] + ... + nums[j]`，可以表示为 `prefixSum[j+1] - prefixSum[i]`。
3. **计算子数组和为 K 的个数：** 对于给定的整数 K，我们可以通过计算前缀和数组来确定子数组和为 K 的个数。假设 `s` 是当前的前缀和，那么我们只需要查找之前是否存在前缀和 `s - K`，如果存在，说明从那个位置到当前位置的子数组和为 K。
   - 如果存在 `counter[s - K]`，则累加 `counter[s - K]` 到答案中，表示有 `counter[s - K]` 个子数组的和为 K。
   - 更新哈希表，将当前前缀和 `s` 的次数加一，表示我们已经经过了当前位置。
4. **计算子数组和为 K 的个数的应用：**
   - **最大子数组和：** 通过计算每个位置的前缀和，可以在 O(n) 的时间复杂度内找到数组中的最大子数组和。
   - **和为 K 的子数组：** 通过维护前缀和和哈希表，在 O(n) 的时间内找到数组中和为 K 的子数组的个数。
   - **连续子数组的最大/最小值：** 通过前缀和和一些额外的处理，可以在 O(n) 的时间内找到连续子数组的最大/最小值。



> 为什么对于当前前缀和 `s`，如果存在 `s - k` 出现过，那么就说明在这之前有子数组的和为 `k` ?

假设 `s` 是当前的前缀和，`s - k` 表示从数组开始的某个位置（在当前位置之前）到当前位置的子数组的和。

如果我们找到了某个位置 `i`，使得 `prefixSum[i] = s - k`，那么说明从 `i` 位置到当前位置的子数组和为 `k`。

