---
title: 实战篇
date: 2023-10-24 15:44:10
permalink: /pages/ac61ed/
author: 
  name: 沉梦听雨
  link: https://gitee.com/dream-deeply-tyu/cmty256
---
# 实战篇

## 编写 Mysql 触发器

> 1、第一条，可执行

```sql
DELIMITER $$

create trigger update_ai_alarm_status
after update on t_ai_alarm_stat for each row
begin
	if new.status <> old.status then

        UPDATE t_ai_alarm_20231011
        SET status = NEW.status
        WHERE org_id = NEW.org_id
        AND dev_id = NEW.dev_id
        AND channel_id = NEW.channel_id
        AND alg_type = NEW.alg_type
        AND alert_type = NEW.alert_type
				AND NEW.alert_date = CONVERT(alarm_time, DATE);

        UPDATE t_ai_alarm_20231012
        SET status = NEW.status
        WHERE org_id = NEW.org_id
        AND dev_id = NEW.dev_id
        AND channel_id = NEW.channel_id
        AND alg_type = NEW.alg_type
        AND alert_type = NEW.alert_type
				AND NEW.alert_date = CONVERT(alarm_time, DATE);
        
    END IF;
END$$

DELIMITER ;
```

有个弊端，不灵活，需要写很多表进去

> 2、触发器中使用动态 sql，不可用，会报错

```sql
DELIMITER $$

CREATE TRIGGER update_ai_alarm_status 
AFTER UPDATE ON t_ai_alarm_stat FOR EACH ROW
BEGIN
  IF NEW.status <> OLD.status THEN
    SET @today = DATE_FORMAT(NEW.alert_date, '%Y%m%d');
    SET @update_status_sql = CONCAT('UPDATE t_ai_alarm_', @today, '
        SET status = NEW.status
        WHERE alarm_time = NEW.alert_date
        AND org_id = NEW.org_id
        AND dev_id = NEW.dev_id
        AND channel_id = NEW.channel_id
        AND alg_type = NEW.alg_type
        AND alert_type = NEW.alert_type');
    PREPARE create_stmt FROM @update_status_sql;
    EXECUTE create_stmt;
    DEALLOCATE PREPARE create_stmt;
  END IF;
END$$

DELIMITER ;
```

报错：
```
1336 - Dynamic SQL is not allowed in stored function or trigger
MySQL不允许在存储函数或触发器中使用动态SQL
```



参考：

- [【精选】【MySQL触发器】触发器的使用、创建、修改及删除_创建一个insert触发器_霸道小明的博客-CSDN博客](https://blog.csdn.net/qq_54169998/article/details/122720159)
- [MySQL 触发器使用教程 - 六种触发器案例详解 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/439273702)

- [触发器（三、条件触发）_触发器条件判断-CSDN博客](https://blog.csdn.net/yoursly/article/details/79360243?ops_request_misc=%7B%22request%5Fid%22%3A%22169813773816800225535196%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=169813773816800225535196&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-79360243-null-null.142^v96^pc_search_result_base1&utm_term=条件触发器&spm=1018.2226.3001.4187)
- [Mysql 预准备语句详解（prepare、execute、deallocate）_mysql prepare execute-CSDN博客](https://blog.csdn.net/qq_34745941/article/details/120454319?spm=1001.2101.3001.6650.7&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-7-120454319-blog-98871552.235^v38^pc_relevant_default_base3&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-7-120454319-blog-98871552.235^v38^pc_relevant_default_base3&utm_relevant_index=14)

## 联表查询问题

```sql
# 基础查询（49条记录）
			 SELECT 
        		 *
        FROM
            t_maintenance_enterprise ent
        WHERE
            ent.is_deleted = 0;
# 反例（18）
        SELECT
						*
        FROM
            t_maintenance_enterprise ent
                LEFT JOIN
            t_maintenance_maintainer main
            ON ent.id = main.enterprise_id
        WHERE ent.is_deleted = 0
						and main.is_deleted = 0;
# 正例（53）
        SELECT
						*
        FROM
            t_maintenance_enterprise ent
                LEFT JOIN
            t_maintenance_maintainer main
            ON ent.id = main.enterprise_id and main.is_deleted = 0
        WHERE ent.is_deleted = 0;
          
```

## Mapping.xml 使用问题

### <= 号的使用

```xml
...
and alert_date <![CDATA[ >= ]]> #{dto.startDay}
..
```

## count(*) 和 count(1) 的区别

`COUNT(*)` 和 `COUNT(1)` 都是用于统计行数的聚合函数，但它们在实现方式上有一些区别。

1. `COUNT(*)`：`COUNT(*)` 用于**计算表中的所有行数**，无论行中的数据是否为 NULL。它会对表的每一行进行计数，包括 NULL 值行。
   - 因此，`COUNT(*)` 返回的结果是表的总行数。
2. `COUNT(1)`：`COUNT(1)` 也用于计算表中的行数，但它不关心行中的实际数据或 NULL 值。它会将一个常量值 1 应用于每一行，并对每一行进行计数。因为它**只是对每一行应用一个固定值，而不需要访问实际的数据内容**。
   - 所以在某些数据库系统中，`COUNT(1)` 的性能可能会比 `COUNT(*)` 稍微好一些。

*两者的区别可以总结如下：*

- `COUNT(*)` 对表的每一行进行计数，包括 NULL 值行。
- `COUNT(1)` 将一个常量值 1 应用于每一行进行计数，不考虑行中的实际数据或 NULL 值。

在实际使用中，通常使用 `COUNT(*)` 来统计行数，因为它更符合直觉和语义。而 `COUNT(1)` 则可以作为一种性能优化手段，在某些情况下可能会稍微提高查询的执行速度。

## 获取行号

利用 `ROW_NUMBER()` 函数。

```sql
SELECT
  ROW_NUMBER() over(order by town, market) rowNumber,
	town,
	market,
	count(*) 
FROM
	tbl_ent 
WHERE
	is_deleted = 0 
	AND create_time BETWEEN '2023-08-27 15:01:09' 
	AND '2023-08-29 15:01:09' 
GROUP BY
	town,
	market;
```

## 替换字段值

用 `replace` 方法：

```sql
UPDATE your_table_name
SET your_column_name = REPLACE(your_column_name, '替换前字符串', '替换后字符串')
```

用途：比如可以用来替换路径前缀

## 截取字段值

用 `substring` 方法：

```sql
UPDATE t_file 
SET no_prefix_path = SUBSTRING( file_path, LENGTH( 'http://172.16.27.40:9001' ) + 1 );

# file_path = http://127.0.0.1:8080/xxxx

-- 赋值之后
# no_prefix_path = /xxxx

```



## 分页查询的 sql 编写

分页查询的 SQL 语句通常包括以下部分：

1. `SELECT` 语句：选择需要查询的字段。
2. `FROM` 语句：指定要查询的表。
3. `WHERE` 语句（可选）：添加筛选条件。
4. `ORDER BY` 语句（可选）：对结果进行排序。
5. `LIMIT` 和 `OFFSET` 语句：实现分页功能。

以下是一个分页查询的 SQL 示例：

```sql
SELECT * FROM 表名
WHERE 条件
ORDER BY 排序字段
LIMIT 每页数量 OFFSET (当前页数 - 1) * 每页数量；
```

**注意：**

实际使用中需要将 "表名"、"条件"、"排序字段"、"每页数量" 和 "当前页数" 替换为实际的值。
