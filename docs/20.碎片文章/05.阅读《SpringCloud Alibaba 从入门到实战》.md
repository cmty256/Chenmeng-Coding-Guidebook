---
title: 阅读《SpringCloud Alibaba 从入门到实战》
date: 2023-09-18 16:34:23
permalink: /pages/75e0cf/
---
# 《SpringCloud Alibaba 从入门到实战》阅读笔记

## 基础知识篇

### 理论篇

俗话说，**没有最好的架构，只有最合适的架构**。

> 微服务架构也是随着信息产业的发展而出现的最有普遍适用性的一套架构模式。

通常来说，我们认为架构发展历史经历了这样一个过程：单体架构 -> SOA 面向服务架构 -> 微服务架构

#### 单体架构

MVC 架构以及由此衍生出来各种多层架构如下图所示：

![image-20230918164349391](https://cdn.jsdelivr.net/gh/cmty256/imgs-blog@main/basics/image-20230918164349391.4etixq55nso0.webp)

*优点*

在程序规模不大，开发人员很少的时候，下面的几点是非常显著的：

1. 开发简单。单体应用的结构，天然决定了所有代码都集中在一起，开发者不需要在多个应用之间来回跳转来寻找其中的调用逻辑。
2. 测试简单。所有代码都在一个应用里，测试人员可以很方便的做到端到端的测试（当然，很多时候测试人员就是开发者自己）。
3. 部署简单。因为一个应用就是产品功能的全集，所以在部署的时候，只需要不是一款应用即可。即使是集群部署，也不会增加多少复杂度：只需要将应用部署多份即可。
4. 开发迅速。上面的各种简单，带来的就是软件功能可以快速实现。很多时候，实现需求的速度是项目成功与否的决定性因素。 

所以，在开发简单和独立的产品时，单体架构依然是第一优先选择。

*弊端*

随着功能的持续增加、团队规模的不断扩大，我们很快就会发现单体应用的弊端：

1. 应用膨胀。所有代码都在一个应用里，导致应用的代码量迅速上升，对于开发者来说，经常需要在海量的代码里找到自己需要维护的哪一行，这种体验往往是令人崩溃的。同时，对于 IDE 来说，一个应用内大量代码也会严重拖慢其运行效率。
2. 团队合作冲突。这种冲突会体现在多个方面：开发阶段，很容易由于修改相同的代码导致代码冲突。部署阶段，又会因为“运行环境里跑的是谁的分支”而造成新的冲突。所有的这些冲突将会严重影响到团队的合作效率。
3. 运行效率 & 稳定性。单体应用，由于逻辑都集中在一起，启动时需要完成所有的初始化工作；同时单一功能的问题也会因为运行在一个进程内，从而导致整个应用宕机。

#### SOA 架构

SOA 是 Service-Oriented Architecture 的简写，直译为“**面向服务的架构**”。

核心思想是：将系统的功能解构为一系列服务。

> 与单体架构按照技术职责进行**水平拆分**不同，SOA 会按照业务领域对应用进行**粗粒度的垂直拆分**

*垂直拆分带来的问题*

应用从单体应用做了垂直拆分以后，就会变成一些相对独立的应用。此时，**应用间的依赖、调用等相关问题**自然而然的就会浮现出来。此时就需要下面这些技术方案来解决这些问题：

1. XML -- 一种标记语言，用于以文档格式描述消息中的数据。
2. SOAP（Simple Object Access Protocol）-- 在计算机网络上交换基于 XML 的消息的协议，通常是用 HTTP。
3. WSDL（Web Services Description Language，Web 服务描述语言）-- 基于 XML 的描述语言，用于描述与服务交互所需的服务的公共接口，协议绑定，消息格式。
4. UDDI（Universal Description, Discovery, and Integration，是统一描述、发现和集成） -- 基于 XML 的注册协议，用于发布 WSDL 并允许第三方发现这些服务。
5. ESB（Enterprise Service Bus, 企业服务总线）-- 支持异构环境中的服务、消息，以及基于事件的交互，并且具有适当的服务级别和可管理性。

*典型 SOA 架构模式图*：

![image-20230918171124589](https://cdn.jsdelivr.net/gh/cmty256/imgs-blog@main/basics/image-20230918171124589.62amj12p1ms0.webp)

*弊端以及不足*

1. 高门槛。ESB 本身就是一套非常复杂的系统，通过 ESB 落地 SOA ，对开发人员的要求很高。甚至还会需要厂商参与；
2. 厂商绑定。由于缺乏统一保准，不同厂商的解决方案之间很难做切换。
3. 不适应云环境。在如今的互联网时代，速度就是一切。由此诞生了敏捷开发、持续集成等在不同节点提升业务上线速度的办法。但是方向是不一致的。
4. 中心化。虽然应用本身实现了分布式与水平扩展，但是 ESB 却成了系统的中枢神经。

#### 微服务架构

直接从【SOA、微服务】这两者的区别入手来理解到底什么是微服务：

|            | 传统 SOA                       | 微服务                                                       |
| ---------- | ------------------------------ | ------------------------------------------------------------ |
| 通信方式   | 基于 ESB，SOAP、W SDL 等重协议 | 点对点通信，开放式协议，如 RESTful、gR PC、或者是轻量级的二进制协议。 |
| 数据管理   | 全局数据模型以及共享存储       | 每个服务独立模型和存储                                       |
| 服务粒度   | 较粗                           | 较细                                                         |
| 诞生的背景 | 企业级应用                     | 互联网                                                       |
| 解决的问题 | 面向企业内，系统集成           | 面向最终产品，解决扩展，维护的问题                           |

通信手段、数据等的不同只是表象，其本质区别还是由于两者诞生于不同历史时期，需要解决的问题域不同。

- SOA 解决的核心问题是**复用**，
- 而微服务解决的核心问题是**扩展**。

*微服务的几个重要概念*

1. 一套小服务
2. 独立进程
3. 轻量级通信协议
4. 可独立部署
5. 多语言 & 不同储技术

*微服务架构图*

![image-20230918174849820](https://cdn.jsdelivr.net/gh/cmty256/imgs-blog@main/basics/image-20230918174849820.4xl6p2ydsa00.webp)

要考虑的问题（主要包括但不限于）：

1. 通过服务实现组件化
2. 根据业务组织系统
3. 做产品而不是做项目
4. 简单高效的通信协议
5. 自动化基础设施
6. 面向失败的设计
7. 具备进化能力的设计

> 今天我们所说的【微服务】是一个庞大且复杂的概念集合，它既是一种架构模式，也是实现这种架构模式时所使用的技术方案的集合。

### 框架篇

#### Spring

在 Spring 框架的早期，大家都喜欢称其为【轻量化】框架，【轻量】是相对于 EJB 等企业级开发框架而言的。

其【轻】的特性体现在：

1. 框架本身的大小很小，早期版本的 jar 包不超过 1MB；
2. 同时不依赖于运行容器，也是说任何容器里都可以运行 Spring 框架；
3. 更加重要的是 Spring 是非侵入的，使用 Spring 开发的应用可以不完全依赖 Spring 的类。

#### SpringBoot

使用 Spring Boot 可以大大简化 Spring 应用的开发工作。

在 Spring Boot 中无论是官方组件还是第三方框架都会提供各种【`starter`】来方便开发者进行依赖和集成。

由于采用了 “**约定大于配置**” 的思想，开发者在引入 “`stater`” 以后只需要做少量的配置工作就可以完成框架集成工作。

> 往往开发者只需要很少量的代码就可以实现以前大量配置文件才能做到的功能。

Spring 官方对 Spring Boot 特色定义如下：

1. 创建独立的 Spring 应用程序 
2. 直接嵌入 Tomcat，Jetty 或 Undertow（无需部署 WAR 文件）
3. 提供自以为是的 “`starter`” 依赖项，以简化构建配置
4. 尽可能自动配置 Spring 和三方类库
5. 提供可用于生产的功能，例如指标，运行状况检查和外部化配置
6. 完全没有代码生成，也不需要 XML 配置

#### Spring Cloud

“分布式系统中的常见模式” 给了 Spring Cloud 一个清晰的定位，即“模式”。也就是说 Spring Cloud 是针对分布式系统开发所做的通用抽象，是标准模式的实现。

Spring 官方给出的一个 Height Light 的架构图：

![image-20230918180448462](https://cdn.jsdelivr.net/gh/cmty256/imgs-blog@main/basics/image-20230918180448462.6ovu8naeg8s0.webp)

> 结论：Spring Cloud 是以微服务为核心的分布式系统的一个构建标准。

#### Spring Cloud Alibaba

既然说 Spring Cloud 是标准，那么自然少不了针对标准的实现。

参与这个标准的实现有很多，比如：

1. Google 的 Spring Cloud GCP
2. Netflix 的 Spring Cloud Netflix
3. Microsoft 的 Spring Cloud Azure 
4. 阿里巴巴的 Spring Cloud Alibaba

*介绍图*

![image-20230918180717293](https://cdn.jsdelivr.net/gh/cmty256/imgs-blog@main/basics/image-20230918180717293.5eca0ci9nds0.webp)

图中深色的部分，其实它就是 Spring Cloud 标准，一共有 3 层。

1. 中间颜色最深的部分就是及整个微服务最核心的内容，包括了 “RPC 调用” 以及 “服务注册与发现”。
2. 第二层，也就是围绕着核心的这一圈，是一些辅助微服务更好的工作功能，包括了负载均衡、路由、网关、断路器，还有就是追踪等等这些内容。
3. 再外层的话，主要是些分布式云环境里的通用能力。

最外面这一圈，是 Spring Cloud Alibaba 对 Spring Cloud 的实现。

- 右上部分是 对于 Spring Cloud 标准的实现。例如，我们通过 Dubbo 实现了 RPC 调用功能，通过 Nacos 实现了“服务注册与发现”、“分布式配置”，通过 Sentinel 实现了断路器等等。
- 左下部分是我们 Spring Cloud Alibaba 对阿里云**各种服务的集成**。

*为什么要加上【集成】这一部分呢？*

因为在实际生产过程中，单独使用微服务框架其实并不足以支撑我们去构建一个完整的系统。所以这部分是用阿里帮助开发者完成微服务以外的云产品集成的功能。

*包含组件*

目前，Spring Cloud Alibaba 包含如下组件：

**开源部分**

1. Sentinel：把流量作为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。
2. Nacos：一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。
3. RocketMQ：一款开源的分布式消息系统，基于高可用分布式集群技术，提供低延时的、高可靠的消息发布与订阅服务。
4. Dubbo：Apache Dubbo 是一款高性能 Java RPC 框架。
5. Seata：阿里巴巴开源产品，一个易于使用的高性能微服务分布式事务解决方案。

**平台服务部分**

1. Alibaba Cloud OSS: 阿里云对象存储服务（Object Storage Service，简称 OSS），是阿里云提供的海量、安全、低成本、高可靠的云存储服务。您可以在任何应用、任何时间、任何地点存储和访问任意类型的数据。
2. Alibaba Cloud SchedulerX: 阿里中间件团队开发的一款分布式任务调度产品，提供秒级、精准、高可靠、高可用的定时（基于 Cron 表达式）任务调度服务。
3. Alibaba Cloud SMS: 覆盖全球的短信服务，友好、高效、智能的互联化通讯能力， 帮助企业迅速搭建客户触达通道。

### 工具篇

#### Java 工程脚手架

脚手架的访问地址是：[云原生应用脚手架](https://start.aliyun.com/bootstrap.html)

#### Sandbox 沙箱环境

Sandbox 沙箱环境，为开发者带来一套快速上手、免除任何环境依赖、免费、便捷的 开发&运行环境。允许开发者在上面查看、修改、部署示例代码，并且由平台提供相关运行 资源。

## 分布式配置

### 1、简介

Nacos 提供用于存储配置和其他元数据的 key/value 存储，为分布式系统中的外部化配置提供服务器端和客户端支持。

Spring Cloud Alibaba Nacos Config 是 Config Server 和 Client 的替代方案，在特殊的 bootstrap 阶段，配置被加载到 Spring 环境中。

### 2、学习目标

- 使用 Nacos Config 作为 Spring Cloud 分布式配置
- 使用 Nacos Config 实现 Bean 动态刷新
- 了解 Nacos Config 高级配置

### 3、详细内容

- **快速上手**：使用 Nacos Config 作为外部化配置源
- **多文件扩展名支持**：以 `YAML` 文件扩展名为例，讨论 Nacos Config 多文件扩展名支持
- **动态配置更新**：演示 `@RefreshScope` 特性，实现 Bean 动态刷新
- **自定义扩展**：自定义 namespace、Group 以及 Data Id 的配置扩展
- **运维特性**：演示 Nacos Config 高级外部化配置以及 Endpoint 内部细节

### 4、快速上手

#### 引入 Nacos Config 的两种方式

Nacos Config 引入的方式同样也有两种，即 Aliyun Java Initializr([云原生应用脚手架](https://start.aliyun.com/bootstrap.html))引入和 Maven pom.xml 依赖。

官方推荐使用 Aliyun Java Initializr 方式引入 Nacos Discovery，以便简化组件之间的依赖关系。

#### 快速上手

> 以脚手架引入为例

![image-20230919095857755](https://cdn.jsdelivr.net/gh/cmty256/imgs-blog@main/basics/image-20230919095857755.6fvzphvl1wo0.webp)

> 生成的相应依赖

```xml
        <dependency>
            <groupId>com.alibaba.cloud</groupId>
            <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>
        </dependency>
```

> 版本号问题

不过该 starter 并未指定版本，具体的版本声明在 `com.alibaba.cloud:springcloud-alibaba-dependencies` 部分

```xml
    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-dependencies</artifactId>
                <version>${spring-boot.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
            <dependency>
                <groupId>com.alibaba.cloud</groupId>
                <artifactId>spring-cloud-alibaba-dependencies</artifactId>
                <version>${spring-cloud-alibaba.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>
```

它们的版本定义在 `<properties>` 元素中，即 `2.2.1.RELEASE` 和 `2.3.0.RELEASE`

```xml
<properties>
	<java.version>1.8</java.version>
	<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
	<project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
	<spring-boot.version>2.3.0.RELEASE</spring-boot.version>
	<spring-cloud-alibaba.version>2.2.1.RELEASE</spring-cloud-alibaba.version>
</properties>
```

#### 启动 Nacos 服务器

阿里为开发者提供了一套免费的 Nacos Server ：进入 [http://139.196.203.133:8848/nacos/](http://139.196.203.133:8848/nacos/) 查看控制台(账号名/密码为 nacos-configuration/nacos-configuration)。

> 具体启动方式参考 [Nacos 快速开始](https://nacos.io/zh-cn/docs/quick-start.html)。

**操作流程官方示例**：

1. 选择 "配置管理/配置列表"

2. 由于服务是公共免费的，为了做好隔离，所以分布式配置的功能，请选择在 sandbox -configuration 的命名空间下操作

3. Data ID 由应用名（`nacos-config-sample`）+ 文件后缀名(`.properties`) 组成，配置内容：

   ```properties
   user.name=nacos-config-sampleuser.age=90
   ```

   > 应用名：对应 `spring.application.name=xxx` 中的 xxx 部分

4. 回到应用 nacos-config-sample 工程，在 resources 目录下新建名为 “`application.properties`" 文件，并配置以下内容：

   ```properties
   spring.cloud.nacos.config.server-addr=139.196.203.133:8848
   spring.cloud.nacos.config.username=nacos-configuration
   spring.cloud.nacos.config.password=nacos-configuration
   spring.cloud.nacos.config.namespace=sandbox-configuration
   ```

5. 读取 Nacos Config 实现

   ```java
   	@SpringBootApplicationpublic class NacosConfigSampleApplication {
   		@Value("${user.name}")
   		private String userName;
   		@Value("${user.age}")
   		private int userAge;
   		@PostConstruct
   		public void init() {
   			System.out.printf("[init] user name : %s , age : %d%n", userName, userAge);
   		}
   		public static void main(String[] args) {
   			SpringApplication.run(NacosConfigSampleApplication.class, args);
   		}
   	}
   ```

6. 启动 Nacos Config 应用

   运行 nacos-config-sample 引导类 `NacosConfigSampleApplication`，观察控制台结果（截取关键日志信息）：

   ```
   [init] user name : nacos-config-sample , age : 9
   ```

### 5、使用 Nacos Config 实现 Bean 动态刷新

Nacos Config 支持标准 Spring Cloud `@RefreshScope` 特性，即**应用订阅某个 Nacos 配置后，当配置内容变化时，Refresh Scope Beans 中的绑定配置的属性将有条件的更新**。

所谓的条件是指 Bean 必须：

1. 必须条件：Bean 的声明类必须标注 `@RefreshScope`
2. 二选一条件：
   - 属性（非 static 字段）标注 `@Value`
   - `@ConfigurationProperties Bean`

除此之外，Nacos Config 也引入了 Nacos Client 底层数据变化监听接口， 即 `com.alibaba.nacos.api.config.listener.Listener`。

> Nacos Client：Nacos 客户端 API，也是 Nacos Config 底层依赖

#### @Value 场景分析

*代码实现*

```java
@SpringBootApplication
@RestController
@RefreshScopepublic
class NacosConfigSampleApplication {
    @Value("${user.name}")
    private String userName;
    @Value("${user.age}")
    private int userAge;

    @PostConstruct
    public void init() {
        System.out.printf("[init] user name : %s , age : %d%n", userName, userAge);
    }

    @PreDestroy
    public void destroy() {
        System.out.printf("[destroy] user name : %s , age : %d%n", userName, userAge);
    }
}
```

当 Nacos Config 接收到服务端配置变更时，对应的 `@RefreshScope Bean` 生命周期回调方法会被调用，并且是【先销毁】，然后又【重新初始化】。 

**要意识到 NacosConfig 配置变更对 `@RefreshScope Bean` 生命周期回调方法的影响，避免出现重复初始化等操作。**

> 注： Nacos Config 配置变更调用了 Spring Cloud API `ContextRefresher`，该 API 会执行以上行为。同理，执行 Spring Cloud Acutator Endpoint `refresh` 也会使用 `ContextRefresher`。

#### @ConfigurationProperties Bean 的场景分析

1、新增 User 类

```java
@RefreshScope
@ConfigurationProperties(prefix = "user")
public class User implements InitializingBean, DisposableBean {

    private String name;

    private int age;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "User{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
}
```

2、修改 NacosConfigSampleApplication 代码

```java
@SpringBootApplication
@RestController
@RefreshScope
@EnableConfigurationProperties(User.class)
public class NacosConfigSampleApplication {
    @Value("${user.name}")
    private String userName;
    @Value("${user.age}")
    private int userAge;
    @Autowired
    private User user;

    @PostConstruct
    public void init() {
        System.out.printf("[init] user name : %s , age : %d%n", userName, userAge);
    }

    @PreDestroy
    public void destroy() {
        System.out.printf("[destroy] user name : %s , age : %d%n", userName, userAge);
    }

    @RequestMapping("/user")
    public String user() {
        return "[HTTP] " + user;
    }

    public static void main(String[] args) {
        SpringApplication.run(NacosConfigSampleApplication.class, args);
    }
}
```

主要改点：

- 激活 @ConfigurationProperties Bean `@EnableConfigurationProperties(User.class)`。
- 通过 `@Autowired` 依赖注入 User Bean。
- 使用 user Bean 的 `toString()` 方法替换 `user()` 中的实现

#### Nacos Config 监听实现 Bean 属性动态刷新

*代码实现*

```java
@Configuration
@EnableConfigurationProperties(User.class)
public class NacosConfigDemoConfiguration {

    @Autowired
    private NacosConfigManager nacosConfigManager;

    @Autowired
    private User user;

    @Value("${user.name}")
    private String userName;

    @Value("${user.age}")
    private int userAge;

    @Bean
    public ApplicationRunner runner() {
        return args -> {
            String dataId = "nacos-config-sample.properties";
            String group = "DEFAULT_GROUP";
            nacosConfigManager.getConfigService().addListener(dataId, group, new AbstractListener() {
                @Override
                public void receiveConfigInfo(String configInfo) {
                    System.out.println("[Listener] " + configInfo);
                    System.out.println("[Before User] " + user);

                    Properties properties = new Properties();
                    try {
                        properties.load(new StringReader(configInfo));
                        String name = properties.getProperty("user.name");
                        int age = Integer.valueOf(properties.getProperty("user.age"));
                        user.setName(name);
                        user.setAge(age);
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                    System.out.println("[After User] " + user);
                }
            });
        };
    }


    @PostConstruct
    public void init() {
        System.out.printf("[init] user name : %s , age : %d%n", userName, userAge);
    }

    @PreDestroy
    public void destroy() {
        System.out.printf("[destroy] user name : %s , age : %d%n", userName, userAge);
    }
}
```

代码主要变化：

1. `@Autowired` 依赖注入 `NacosConfigManager`。

2. 新增 `runner()` 方法，通过 `NacosConfigManagerBean` 获取 `ConfigService`，并增加了 `AbstractListener`( Listener 抽象类）实现，

   监听 `dataId = "nacos-configsample.properties"` 和 `group = "DEFAULT_GROUP"` 

重启应用，并将配置 user.age 从 90 调整到 19，观察日志变化：

```bash
[Listener] user.name=nacos-config-sampleuser.age= 19
[Before User] User{name='nacos-config-sample', age=90}
[After User] User{name='nacos-config-sample', age=19}
```

#### 总结

上述三个例子均围绕着 Nacos Config 实现 Bean 属性动态更新，不过它们是 **Spring Cloud** 使用场景。

如果读者的应用仅使用 **Spring 或者 Spring Boot**，可以考虑 Nacos Spring 工程，Github 地址：[https://github.com/nacos-group/nacos-spring-project](https://github.com/nacos-group/nacos-spring-project)，其中 `@NacosValue` 支持属性粒度的更新。

### 6、Nacos Config 高级配置

#### 支持自定义 namespace 的配置

例如：

```properties
spring.cloud.nacos.config.namespace=b3404bc0-d7dc-4855-b519-570ed34b62d7
```

> 注：该配置必须放在 bootstrap.properties 文件中

#### 支持自定义 Group 的配置

例如：

```properties
spring.cloud.nacos.config.group=DEVELOP_GROUP
```

#### 支持自定义扩展的 Data Id 配置

一个完整的配置案例如下所示：

```properties
spring.application.name=opensource-service-provider
spring.cloud.nacos.config.server-addr=127.0.0.1:8848
# config external configuration
# 1、Data Id 在默认的组 DEFAULT_GROUP,不支持配置的动态刷新
spring.cloud.nacos.config.extension-configs[0].data-id=ext-config-common01.properties
# 2、Data Id 不在默认的组，不支持动态刷新
spring.cloud.nacos.config.extension-configs[1].data-id=ext-config-common02.properties
spring.cloud.nacos.config.extension-configs[1].group=GLOBALE_GROUP
# 3、Data Id 既不在默认的组，也支持动态刷新
spring.cloud.nacos.config.extension-configs[2].data-id=ext-config-common03.properties
spring.cloud.nacos.config.extension-configs[2].group=REFRESH_GROUP
spring.cloud.nacos.config.extension-configs[2].refresh=true
```

可以看到：

1. 通过 `spring.cloud.nacos.config.extension-configs[n].data-id` 的配置方式来支持多个 Data Id 的配置。
2. 通过 `spring.cloud.nacos.config.extension-configs[n].group` 的配置方式自定义 Data Id 所在的组，不明确配置的话，默认是 DEFAULT_GROUP。
3. 通过 `spring.cloud.nacos.config.extension-configs[n].refresh` 的配置方式来控制该 Data Id 在配置变更时，是否支持应用中可动态刷新，感知到最新的配置值。默认是不支持的。

需要注意的点：

- 多个 Data Id 同时配置时，他的优先级关系是 `spring.cloud.nacos.config.extension-configs[n].data-id` 其中 **n 的值越大，优先级越高**。 
- `spring.cloud.nacos.config.extension-configs[n].data-id` 的**值必须带文件扩展名**，文件扩展名既可支持 properties，又可以支持 yaml/yml。

*清晰案例*

```properties
# 配置支持共享的 Data Id
spring.cloud.nacos.config.shared-configs[0].data-id=common.yaml
# 配置 Data Id 所在分组，缺省默认 DEFAULT_GROUP
spring.cloud.nacos.config.shared-configs[0].group=GROUP_APP1
# 配置 Data Id 在配置变更时，是否动态刷新，缺省默认 false
spring.cloud.nacos.config.shared-configs[0].refresh=true
```

#### 配置的优先级

目前提供了**三种**配置能力从 Nacos 拉取相关的配置。

A: 通过 `spring.cloud.nacos.config.shared-configs[n].data-id` 支持多个共享 Data Id 的配置

B: 通过 `spring.cloud.nacos.config.extension-configs[n].data-id` 的方式支持多个扩展 Data Id 的配置

C: 通过内部相关规则(应用名、应用名 + Profile )自动生成相关的 Data Id 配置（运行参数配置）

*当三种方式共同使用时，他们的一个优先级关系是：A < B < C*

#### 完全关闭配置

可以通过设置 `spring.cloud.nacos.config.enabled = false` 来完全关闭 Spring Cloud Nacos Config

#### 7、Nacos Config Actuator Endpoint

Nacos Config 内部提供了一个 Endpoint, 对应的 Endpoint ID 为 nacos-config，其 Actuator Web Endpoint URI 为 /actuator/nacos-config。 

> 注：使用 Nacos Config Spring Cloud 1.x 版本的话，其 URI 地址则为 /nacos-config

其中，Endpoint 暴露的 json 中包含了三种属性（即**服务响应内容**）: 

1. NacosConfigProperties: 当前应用 Nacos 的基础配置信息。
2. RefreshHistory: 配置刷新的历史记录。
3. Sources: 当前应用配置的数据信息

```json
{
    "NacosConfigProperties":{
        "serverAddr":"127.0.0.1:8848",
        "username":"",
        "password":"",
        "encode":null,
        "group":"DEFAULT_GROUP",
        "prefix":null,
        "fileExtension":"properties",
        "timeout":3000,
        "maxRetry":null,
        "configLongPollTimeout":null,
        "configRetryTime":null,
        "enableRemoteSyncConfig":false,
        "endpoint":null,
        "namespace":null,
        "accessKey":null,
        "secretKey":null,
        "contextPath":null,
        "clusterName":null,
        "name":null,
        "sharedConfigs":null,
        "extensionConfigs":null,
        "refreshEnabled":true,
        "sharedDataids":null,
        "refreshableDataids":null,
        "extConfig":null,
        "configServiceProperties":{
            "secretKey":"",
            "namespace":"",
            "username":"",
            "enableRemoteSyncConfig":"false",
            "configLongPollTimeout":"",
            "configRetryTime":"",
            "encode":"",
            "serverAddr":"127.0.0.1:8848",
            "maxRetry":"",
            "clusterName":"",
            "password":"",
            "accessKey":"",
            "endpoint":""
        }
    },
    "RefreshHistory":[

    ],
    "Sources":[
        {
            "lastSynced":"2020-09-14 11:11:37",
            "dataId":"nacos-config-sample.properties"
        },
        {
            "lastSynced":"2020-09-14 11:11:37",
            "dataId":"nacos-config-sample"
        }
    ]
}
```

## 服务注册与发现
